diff --git a/InnovaMotionApp/.cursor/rules/innova.mdc b/InnovaMotionApp/.cursor/rules/innova.mdc
index e4b9e1d..93041cd 100644
--- a/InnovaMotionApp/.cursor/rules/innova.mdc
+++ b/InnovaMotionApp/.cursor/rules/innova.mdc
@@ -1,72 +1,72 @@
----
-alwaysApply: true
----
-
-
-### INNOVA Motion App â€” Directional Rules (concise)
-
-**You are**
-- An expert **Android + Java** engineer and an expert **Cursor** pair-programmer.
-
-**Scope (do not wander)**
-- Work only in the Android app codebase, primarily:
-  - `app/src/main/java/com/melisa/innovamotionapp/**`
-  - especially `app/src/main/java/com/melisa/innovamotionapp/activities/**`
-- The **launcher / entry activity is `MainActivity`** (it has `MAIN` + `LAUNCHER` intent-filter in `AndroidManifest.xml`).  
-  `StartActivity` is declared but is **not** the launcher.
-- Avoid unrelated edits (Gradle, resources, manifest, strings, themes) unless strictly required by the refactor.
-
-**Intent**
-- This sprint is a **behavior-preserving refactor**: keep UX and runtime behavior stable.
-- Prefer **small, surgical diffs**.
-- Make code **DRY, modular, decoupled**:
-  - extract helpers/services/managers instead of copying logic
-  - remove duplication, reduce â€œfatâ€ Activities
-  - keep responsibilities single-purpose (SRP)
-
-**Priorities**
-1. Correctness & stability (no regressions)
-2. UI responsiveness (never block the main thread)
-3. Maintainability (clarity, testability, typing/null-safety)
-4. Performance (avoid heavy work in hot paths)
-5. New features only if explicitly requested
-
-**Architecture nudges (lightweight, no big rewrites)**
-- Activities should mostly orchestrate UI + navigation, not business logic.
-- Centralize cross-cutting concerns:
-  - permissions handling (Bluetooth + location + notifications)
-  - navigation / intent extras keys
-  - Bluetooth connection state + device/session management
-  - logging and error mapping (user-friendly messages vs debug logs)
-- Prefer introducing **small classes** (e.g., `*Manager`, `*Repository`, `*UseCase`, `*Navigator`) over framework-heavy changes.
-- If you introduce new abstractions, prefer **interfaces** to enable mocking and reduce coupling.
-
-**Behavior contracts (do not break)**
-- `MainActivity` remains the launcher entry point and its launch behavior stays identical.
-- Public component contracts remain stable:
-  - intent extras keys, action strings, request codes, and command IDs (if any) must not change without strong reason.
-- Bluetooth behavior remains conservative and non-noisy:
-  - no surprise auto-scans, no spammy dialogs/toasts, no new permission loops.
-- `DeviceCommunicationService` behavior/contract stays stable (binding, actions, foreground service type, notification behavior).
-
-**Android-specific constraints**
-- Avoid memory leaks:
-  - donâ€™t store `Activity` in long-lived singletons
-  - be careful with inner classes, callbacks, and static references
-- Threading:
-  - move I/O, Bluetooth operations, and long computations off the UI thread
-  - avoid blocking calls on main thread
-- Lifecycles:
-  - respect Activity lifecycle; cancel/cleanup listeners and callbacks appropriately.
-
-**Style**
-- Java-first, consistent naming, small methods, early returns.
-- Use constants for magic strings/keys/request codes; keep them centralized.
-- Prefer composition over inheritance; minimal side effects.
-- User messages: friendly and actionable; detailed errors go to logs.
-
-**Change protocol**
-- Before changing code: identify call sites and usage patterns (search references).
-- Keep refactors reversible: avoid broad renames or sweeping formatting changes.
-- Add/adjust tests if a test setup already exists; otherwise add small validation helpers or sanity checks.
+---
+alwaysApply: true
+---
+
+
+### INNOVA Motion App â€” Directional Rules (concise)
+
+**You are**
+- An expert **Android + Java** engineer and an expert **Cursor** pair-programmer.
+
+**Scope (do not wander)**
+- Work only in the Android app codebase, primarily:
+  - `app/src/main/java/com/melisa/innovamotionapp/**`
+  - especially `app/src/main/java/com/melisa/innovamotionapp/activities/**`
+- The **launcher / entry activity is `MainActivity`** (it has `MAIN` + `LAUNCHER` intent-filter in `AndroidManifest.xml`).  
+  `StartActivity` is declared but is **not** the launcher.
+- Avoid unrelated edits (Gradle, resources, manifest, strings, themes) unless strictly required by the refactor.
+
+**Intent**
+- This sprint is a **behavior-preserving refactor**: keep UX and runtime behavior stable.
+- Prefer **small, surgical diffs**.
+- Make code **DRY, modular, decoupled**:
+  - extract helpers/services/managers instead of copying logic
+  - remove duplication, reduce â€œfatâ€ Activities
+  - keep responsibilities single-purpose (SRP)
+
+**Priorities**
+1. Correctness & stability (no regressions)
+2. UI responsiveness (never block the main thread)
+3. Maintainability (clarity, testability, typing/null-safety)
+4. Performance (avoid heavy work in hot paths)
+5. New features only if explicitly requested
+
+**Architecture nudges (lightweight, no big rewrites)**
+- Activities should mostly orchestrate UI + navigation, not business logic.
+- Centralize cross-cutting concerns:
+  - permissions handling (Bluetooth + location + notifications)
+  - navigation / intent extras keys
+  - Bluetooth connection state + device/session management
+  - logging and error mapping (user-friendly messages vs debug logs)
+- Prefer introducing **small classes** (e.g., `*Manager`, `*Repository`, `*UseCase`, `*Navigator`) over framework-heavy changes.
+- If you introduce new abstractions, prefer **interfaces** to enable mocking and reduce coupling.
+
+**Behavior contracts (do not break)**
+- `MainActivity` remains the launcher entry point and its launch behavior stays identical.
+- Public component contracts remain stable:
+  - intent extras keys, action strings, request codes, and command IDs (if any) must not change without strong reason.
+- Bluetooth behavior remains conservative and non-noisy:
+  - no surprise auto-scans, no spammy dialogs/toasts, no new permission loops.
+- `DeviceCommunicationService` behavior/contract stays stable (binding, actions, foreground service type, notification behavior).
+
+**Android-specific constraints**
+- Avoid memory leaks:
+  - donâ€™t store `Activity` in long-lived singletons
+  - be careful with inner classes, callbacks, and static references
+- Threading:
+  - move I/O, Bluetooth operations, and long computations off the UI thread
+  - avoid blocking calls on main thread
+- Lifecycles:
+  - respect Activity lifecycle; cancel/cleanup listeners and callbacks appropriately.
+
+**Style**
+- Java-first, consistent naming, small methods, early returns.
+- Use constants for magic strings/keys/request codes; keep them centralized.
+- Prefer composition over inheritance; minimal side effects.
+- User messages: friendly and actionable; detailed errors go to logs.
+
+**Change protocol**
+- Before changing code: identify call sites and usage patterns (search references).
+- Keep refactors reversible: avoid broad renames or sweeping formatting changes.
+- Add/adjust tests if a test setup already exists; otherwise add small validation helpers or sanity checks.
 - When you change something, include a brief â€œwhyâ€ comment or commit-style note in the PR description.
\ No newline at end of file
diff --git a/InnovaMotionApp/.gitignore b/InnovaMotionApp/.gitignore
index 10cfdbf..2a95120 100644
--- a/InnovaMotionApp/.gitignore
+++ b/InnovaMotionApp/.gitignore
@@ -1,10 +1,10 @@
-*.iml
-.gradle
-/local.properties
-/.idea
-.DS_Store
-/build
-/captures
-.externalNativeBuild
-.cxx
-local.properties
+*.iml
+.gradle
+/local.properties
+/.idea
+.DS_Store
+/build
+/captures
+.externalNativeBuild
+.cxx
+local.properties
diff --git "a/InnovaMotionApp/Multi-User Posture Monitoring System - Specifica\310\233ie Client.md" "b/InnovaMotionApp/Multi-User Posture Monitoring System - Specifica\310\233ie Client.md"
index 907ecdf..b8198a7 100644
--- "a/InnovaMotionApp/Multi-User Posture Monitoring System - Specifica\310\233ie Client.md"	
+++ "b/InnovaMotionApp/Multi-User Posture Monitoring System - Specifica\310\233ie Client.md"	
@@ -1,280 +1,280 @@
-
-# Sistem de Monitorizare PosturÄƒ Multi-Utilizator â€” SpecificaÈ›ie IteraÈ›ie (ActualizatÄƒ)
-
-**Domeniu Proiect:** Actualizare Protocol Hardware & ÃmbunÄƒtÄƒÈ›ire FuncÈ›ionalitÄƒÈ›i AplicaÈ›ie Android
-
----
-
-## ğŸ”§ CERINÈšE HARDWARE (Responsabilitatea DumneavoastrÄƒ)
-
-### Protocol Curent (Utilizator Singular)
-
-#### Mesaj trimis via Bluetooth:
-```
-
-0xAB3311\n
-
-```
-- Un singur cod hex per transmisie  
-- ReprezintÄƒ postura unui singur utilizator  
-- Terminat cu newline
-
----
-
-## ğŸ”„ Protocol Nou (Packet Multi-Utilizator)
-
-### Format Mesaj
-```
-
-sensor001;0xAB3311\n
-sensor002;0xEF0112\n
-sensor003;0xBA3311\n
-sensor001;0xBA3311\n
-END_PACKET\n
-
-```
-
-### ModificÄƒri Protocol
-
-1. **AdaugÄƒ ID Copil**  
-PrefixaÈ›i fiecare citire cu un identificator unic (UUID, hash etc.) urmat de `;`  
-Exemplu:
-```
-
-5d6d75ee-b6c8-42d4-a233-b13d137fea38;0xAB3311
-
-```
-
-2. **Terminator Packet (OBLIGATORIU)**
-```
-
-END_PACKET\n
-
-```
-Packet-ul nu este procesat fÄƒrÄƒ acest terminator.
-
-3. **Citiri Multiple per Packet**  
-Packet-ul poate include 1â€¦âˆ citiri.  
-Se pot repeta ID-uri Ã®n acelaÈ™i pachet.
-
----
-
-### Exemplu Packet
-```
-
-// Packet 1 (3 copii, 4 citiri Ã®n total)
-sensor001;0xAB3311\n
-sensor002;0xEF0112\n
-sensor003;0xBA3311\n
-sensor001;0xAB3311\n
-END_PACKET\n
-
-[aÈ™teptare 2 secunde]
-
-// Packet 2 (2 copii, 2 citiri)
-sensor001;0xBA3311\n
-sensor002;0xAB3311\n
-END_PACKET\n
-
-```
-
----
-
-# ğŸ“± FUNCÈšIONALITÄ‚ÈšI NOI APLICAÈšIE
-
-## 1. Colectare Multi-Utilizator
-- Telefonul Android colecteazÄƒ date pentru un numÄƒr **nelimitat** de persoane.
-- Identificarea se face prin ID de la hardware.
-- Stocare automatÄƒ separatÄƒ per persoanÄƒ.
-
-**Beneficiu:** un singur dispozitiv hardware â†’ monitorizare la nivel de clÄƒdire.
-
----
-
-## 2. InterfaÈ›Äƒ Agregator Date (Debug Friendly)
-
-### Tab 1: Monitor Mesaje Live
-- Log Ã®n timp real
-- Timestamp + posture
-- NumÄƒr mesaje per persoanÄƒ
-- **Color coding + risc**
-  - RoÈ™u â†’ cÄƒzut (âš ï¸ risc mare)
-  - Galben â†’ mers / stat Ã®n picioare (risc mediu)
-  - Verde â†’ stat pe scaun (risc mic)
-
-### Tab 2: Vizualizator PosturÄƒ Live
-- Selectarea oricÄƒrei persoane
-- AnimaÈ›ie posturÄƒ live
-- Debug individual
-- **Adaptare video Ã®n funcÈ›ie de persona monitorizatÄƒ**
-
----
-
-## 3. Sistem Denumire Persoane
-
-- Logarea copiilor / persoanelor se face **prin Agregator**
-- Se va deschide o fereastrÄƒ Ã®n care se asociazÄƒ:
-**UUID â†’ nume persoanÄƒ**
-- Exemplu:
-```
-
-5d6d75ee-b6c8-42d4-a233-b13d137fea38 â†’ Ion Popescu
-
-```
-- Numele se sincronizeazÄƒ la toate conturile de supraveghere conectate la acest agregator.
-
----
-
-## 4. Dashboard Supervisor ÃmbunÄƒtÄƒÈ›it
-
-AfiÈ™eazÄƒ:
-- Nume
-- PosturÄƒ curentÄƒ
-- Timp ultimÄƒ actualizare
-- **Nivel risc**
-
-### Niveluri Risc
-| PosturÄƒ | Nivel Risc |
-|--------|-----------|
-| CÄƒzut | â— Mare |
-| Mers / Ãn picioare | âš ï¸ Mediu |
-| Stat pe scaun | ğŸŸ¢ Mic |
-
----
-
-## 5. Vizualizare Detalii PersoanÄƒ IndividualÄƒ
-- Ecran dedicat unui singur utilizator
-- AnimaÈ›ie posturÄƒ live
-- Timeline istoric
-- Statistici:
-  - timp Ã®n picioare
-  - timp aÈ™ezat
-  - timp mers
-- Analiza consum energie
-- **Adaptare video individualÄƒ**
-
----
-
-## 6. PerformanÈ›Äƒ ÃmbunÄƒtÄƒÈ›itÄƒ
-- Upload batch cloud (nu pe fiecare linie)
-- InterogÄƒri agregate pentru mai mulÈ›i utilizatori
-- LatenÈ›Äƒ redusÄƒ notificÄƒri live
-
----
-
-# âœ¨ FUNCÈšIONALITÄ‚ÈšI NOI (Solicitate)
-
-### ğŸ”¹ A. Adaptare Video Per PersoanÄƒ
-- UI schimbÄƒ animaÈ›iile/video Ã®n funcÈ›ie de postura ID-ului selectat
-- Modul dedicat dacÄƒ se deschide profilul persoanei
-
-### ğŸ”¹ B. Sign Out â†’ Deconectare Bluetooth
-- ApÄƒsarea butonului **Sign Out**:
-  - Conexiunea Bluetooth se Ã®nchide imediat
-  - listener-ele sunt curÄƒÈ›ate
-  - aplicaÈ›ia revine Ã®n starea iniÈ›ialÄƒ
-
-### ğŸ”¹ C. Sistem Risc
-RegulÄƒ simplÄƒ:
-- CÄƒzut â†’ risc mare
-- Ãn picioare / deplasare â†’ risc mediu
-- Stat pe scaun â†’ risc mic
-
-Implementat Ã®n:
-- Feed live
-- Dashboard
-- NotificÄƒri
-
-### ğŸ”¹ D. Logare prin Agregator
-- NU existÄƒ conturi pentru copii
-- Doar UUID
-- Agregatorul introduce nume friendly
-- Mapping sincronizat automat cloud
-
-### ğŸ”¹ E. Vizualizare Multi-Supervisor
-- Datele de la o persoanÄƒ pot fi vizualizate simultan de mai mulÈ›i supervisori
-- Niciun limit numeric
-
----
-
-# ğŸ§© PREZENTARE ARHITECTURÄ‚
-
-## Sistem Actual
-```
-
-1 Telefon <-> 1 Dispozitiv Bluetooth <-> 1 PersoanÄƒ
-
-```
-
-## Sistem Nou
-```
-
-1 Telefon Agregator <-> 1 Dispozitiv Bluetooth <-> Persoane Multiple
-â†“
-BazÄƒ Cloud
-â†“
-Supraveghetori Multipli
-
-```
-
----
-
-# ğŸ‘¤ ROLURI UTILIZATORI
-
-## ğŸ”· Cont Agregator (Colectare)
-- Conexiune hardware Bluetooth
-- PrimeÈ™te pachete multi-ID
-- Gestionare nume persoane
-- Upload cloud
-- Dashboard de debugging
-- **Sign Out = Ã®ntrerupe conexiunea Bluetooth**
-
-## ğŸ”· Cont Supervisor
-- Conectat la un agregator
-- VizualizeazÄƒ ansamblu
-- Alerte risc
-- Vizualizare detaliu persoanÄƒ
-- **Mai mulÈ›i supervisori pot vedea aceeaÈ™i persoanÄƒ**
-
-## ğŸ”· Copil / PersoanÄƒ MonitorizatÄƒ
-- Nu are cont
-- Trimite doar ID via hardware
-- Apare cu numele atribuit de Agregator
-
----
-
-# ğŸ” FLUX DATE
-
-```
-
-Hardware-ul dumneavoastrÄƒ
-â†“ transmite packeturi multi-ID
-Telefon Agregator
-â†“ proceseazÄƒ + mapare nume + upload batch
-BazÄƒ de Date Cloud
-â†“ sincronizare timp real
-Telefoane Supervisor (multipli)
-â†“ vizualizare + risc + video individual
-
-```
-
----
-
-# ğŸ“… TIMELINE + COST
-
-**Timeline:** 3â€“4 sÄƒptÄƒmÃ¢ni  
-**Cost Total:** â‚¬3.000
-
-### Termeni PlatÄƒ:
-- 10% avans (â‚¬300) â€” demarare dezvoltare
-- 90% (â‚¬2.700) â€” livrare + testare
-
-Include:
-- Implementare completÄƒ
-- Testare hardware/software
-- DocumentaÈ›ie
-- Suport post-deployment
-
----
-
-**Upgrade-ul transformÄƒ sistemul dumneavoastrÄƒ din single-user â†’ multi-user, cu modificÄƒri minime Ã®n hardware È™i expansiune majorÄƒ Ã®n software.**
+
+# Sistem de Monitorizare PosturÄƒ Multi-Utilizator â€” SpecificaÈ›ie IteraÈ›ie (ActualizatÄƒ)
+
+**Domeniu Proiect:** Actualizare Protocol Hardware & ÃmbunÄƒtÄƒÈ›ire FuncÈ›ionalitÄƒÈ›i AplicaÈ›ie Android
+
+---
+
+## ğŸ”§ CERINÈšE HARDWARE (Responsabilitatea DumneavoastrÄƒ)
+
+### Protocol Curent (Utilizator Singular)
+
+#### Mesaj trimis via Bluetooth:
+```
+
+0xAB3311\n
+
+```
+- Un singur cod hex per transmisie  
+- ReprezintÄƒ postura unui singur utilizator  
+- Terminat cu newline
+
+---
+
+## ğŸ”„ Protocol Nou (Packet Multi-Utilizator)
+
+### Format Mesaj
+```
+
+sensor001;0xAB3311\n
+sensor002;0xEF0112\n
+sensor003;0xBA3311\n
+sensor001;0xBA3311\n
+END_PACKET\n
+
+```
+
+### ModificÄƒri Protocol
+
+1. **AdaugÄƒ ID Copil**  
+PrefixaÈ›i fiecare citire cu un identificator unic (UUID, hash etc.) urmat de `;`  
+Exemplu:
+```
+
+5d6d75ee-b6c8-42d4-a233-b13d137fea38;0xAB3311
+
+```
+
+2. **Terminator Packet (OBLIGATORIU)**
+```
+
+END_PACKET\n
+
+```
+Packet-ul nu este procesat fÄƒrÄƒ acest terminator.
+
+3. **Citiri Multiple per Packet**  
+Packet-ul poate include 1â€¦âˆ citiri.  
+Se pot repeta ID-uri Ã®n acelaÈ™i pachet.
+
+---
+
+### Exemplu Packet
+```
+
+// Packet 1 (3 copii, 4 citiri Ã®n total)
+sensor001;0xAB3311\n
+sensor002;0xEF0112\n
+sensor003;0xBA3311\n
+sensor001;0xAB3311\n
+END_PACKET\n
+
+[aÈ™teptare 2 secunde]
+
+// Packet 2 (2 copii, 2 citiri)
+sensor001;0xBA3311\n
+sensor002;0xAB3311\n
+END_PACKET\n
+
+```
+
+---
+
+# ğŸ“± FUNCÈšIONALITÄ‚ÈšI NOI APLICAÈšIE
+
+## 1. Colectare Multi-Utilizator
+- Telefonul Android colecteazÄƒ date pentru un numÄƒr **nelimitat** de persoane.
+- Identificarea se face prin ID de la hardware.
+- Stocare automatÄƒ separatÄƒ per persoanÄƒ.
+
+**Beneficiu:** un singur dispozitiv hardware â†’ monitorizare la nivel de clÄƒdire.
+
+---
+
+## 2. InterfaÈ›Äƒ Agregator Date (Debug Friendly)
+
+### Tab 1: Monitor Mesaje Live
+- Log Ã®n timp real
+- Timestamp + posture
+- NumÄƒr mesaje per persoanÄƒ
+- **Color coding + risc**
+  - RoÈ™u â†’ cÄƒzut (âš ï¸ risc mare)
+  - Galben â†’ mers / stat Ã®n picioare (risc mediu)
+  - Verde â†’ stat pe scaun (risc mic)
+
+### Tab 2: Vizualizator PosturÄƒ Live
+- Selectarea oricÄƒrei persoane
+- AnimaÈ›ie posturÄƒ live
+- Debug individual
+- **Adaptare video Ã®n funcÈ›ie de persona monitorizatÄƒ**
+
+---
+
+## 3. Sistem Denumire Persoane
+
+- Logarea copiilor / persoanelor se face **prin Agregator**
+- Se va deschide o fereastrÄƒ Ã®n care se asociazÄƒ:
+**UUID â†’ nume persoanÄƒ**
+- Exemplu:
+```
+
+5d6d75ee-b6c8-42d4-a233-b13d137fea38 â†’ Ion Popescu
+
+```
+- Numele se sincronizeazÄƒ la toate conturile de supraveghere conectate la acest agregator.
+
+---
+
+## 4. Dashboard Supervisor ÃmbunÄƒtÄƒÈ›it
+
+AfiÈ™eazÄƒ:
+- Nume
+- PosturÄƒ curentÄƒ
+- Timp ultimÄƒ actualizare
+- **Nivel risc**
+
+### Niveluri Risc
+| PosturÄƒ | Nivel Risc |
+|--------|-----------|
+| CÄƒzut | â— Mare |
+| Mers / Ãn picioare | âš ï¸ Mediu |
+| Stat pe scaun | ğŸŸ¢ Mic |
+
+---
+
+## 5. Vizualizare Detalii PersoanÄƒ IndividualÄƒ
+- Ecran dedicat unui singur utilizator
+- AnimaÈ›ie posturÄƒ live
+- Timeline istoric
+- Statistici:
+  - timp Ã®n picioare
+  - timp aÈ™ezat
+  - timp mers
+- Analiza consum energie
+- **Adaptare video individualÄƒ**
+
+---
+
+## 6. PerformanÈ›Äƒ ÃmbunÄƒtÄƒÈ›itÄƒ
+- Upload batch cloud (nu pe fiecare linie)
+- InterogÄƒri agregate pentru mai mulÈ›i utilizatori
+- LatenÈ›Äƒ redusÄƒ notificÄƒri live
+
+---
+
+# âœ¨ FUNCÈšIONALITÄ‚ÈšI NOI (Solicitate)
+
+### ğŸ”¹ A. Adaptare Video Per PersoanÄƒ
+- UI schimbÄƒ animaÈ›iile/video Ã®n funcÈ›ie de postura ID-ului selectat
+- Modul dedicat dacÄƒ se deschide profilul persoanei
+
+### ğŸ”¹ B. Sign Out â†’ Deconectare Bluetooth
+- ApÄƒsarea butonului **Sign Out**:
+  - Conexiunea Bluetooth se Ã®nchide imediat
+  - listener-ele sunt curÄƒÈ›ate
+  - aplicaÈ›ia revine Ã®n starea iniÈ›ialÄƒ
+
+### ğŸ”¹ C. Sistem Risc
+RegulÄƒ simplÄƒ:
+- CÄƒzut â†’ risc mare
+- Ãn picioare / deplasare â†’ risc mediu
+- Stat pe scaun â†’ risc mic
+
+Implementat Ã®n:
+- Feed live
+- Dashboard
+- NotificÄƒri
+
+### ğŸ”¹ D. Logare prin Agregator
+- NU existÄƒ conturi pentru copii
+- Doar UUID
+- Agregatorul introduce nume friendly
+- Mapping sincronizat automat cloud
+
+### ğŸ”¹ E. Vizualizare Multi-Supervisor
+- Datele de la o persoanÄƒ pot fi vizualizate simultan de mai mulÈ›i supervisori
+- Niciun limit numeric
+
+---
+
+# ğŸ§© PREZENTARE ARHITECTURÄ‚
+
+## Sistem Actual
+```
+
+1 Telefon <-> 1 Dispozitiv Bluetooth <-> 1 PersoanÄƒ
+
+```
+
+## Sistem Nou
+```
+
+1 Telefon Agregator <-> 1 Dispozitiv Bluetooth <-> Persoane Multiple
+â†“
+BazÄƒ Cloud
+â†“
+Supraveghetori Multipli
+
+```
+
+---
+
+# ğŸ‘¤ ROLURI UTILIZATORI
+
+## ğŸ”· Cont Agregator (Colectare)
+- Conexiune hardware Bluetooth
+- PrimeÈ™te pachete multi-ID
+- Gestionare nume persoane
+- Upload cloud
+- Dashboard de debugging
+- **Sign Out = Ã®ntrerupe conexiunea Bluetooth**
+
+## ğŸ”· Cont Supervisor
+- Conectat la un agregator
+- VizualizeazÄƒ ansamblu
+- Alerte risc
+- Vizualizare detaliu persoanÄƒ
+- **Mai mulÈ›i supervisori pot vedea aceeaÈ™i persoanÄƒ**
+
+## ğŸ”· Copil / PersoanÄƒ MonitorizatÄƒ
+- Nu are cont
+- Trimite doar ID via hardware
+- Apare cu numele atribuit de Agregator
+
+---
+
+# ğŸ” FLUX DATE
+
+```
+
+Hardware-ul dumneavoastrÄƒ
+â†“ transmite packeturi multi-ID
+Telefon Agregator
+â†“ proceseazÄƒ + mapare nume + upload batch
+BazÄƒ de Date Cloud
+â†“ sincronizare timp real
+Telefoane Supervisor (multipli)
+â†“ vizualizare + risc + video individual
+
+```
+
+---
+
+# ğŸ“… TIMELINE + COST
+
+**Timeline:** 3â€“4 sÄƒptÄƒmÃ¢ni  
+**Cost Total:** â‚¬3.000
+
+### Termeni PlatÄƒ:
+- 10% avans (â‚¬300) â€” demarare dezvoltare
+- 90% (â‚¬2.700) â€” livrare + testare
+
+Include:
+- Implementare completÄƒ
+- Testare hardware/software
+- DocumentaÈ›ie
+- Suport post-deployment
+
+---
+
+**Upgrade-ul transformÄƒ sistemul dumneavoastrÄƒ din single-user â†’ multi-user, cu modificÄƒri minime Ã®n hardware È™i expansiune majorÄƒ Ã®n software.**
diff --git a/InnovaMotionApp/app/build.gradle.kts b/InnovaMotionApp/app/build.gradle.kts
index aef403e..67bd4e0 100644
--- a/InnovaMotionApp/app/build.gradle.kts
+++ b/InnovaMotionApp/app/build.gradle.kts
@@ -1,76 +1,76 @@
-plugins {
-    alias(libs.plugins.android.application)
-    alias(libs.plugins.google.gms.google.services)
-}
-
-android {
-    namespace = "com.melisa.innovamotionapp"
-    compileSdk = 35
-
-    defaultConfig {
-        applicationId = "com.melisa.innovamotionapp"
-        minSdk = 26
-        targetSdk = 34
-        versionCode = 1
-        versionName = "1.0"
-
-        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
-    }
-
-    buildTypes {
-        release {
-            isMinifyEnabled = false
-            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
-        }
-    }
-    compileOptions {
-        sourceCompatibility = JavaVersion.VERSION_1_8
-        targetCompatibility = JavaVersion.VERSION_1_8
-    }
-    buildFeatures {
-        viewBinding = true
-    }
-    
-    // Allow Android framework classes to return default values in unit tests
-    // This prevents RuntimeException for Log.d(), etc.
-    testOptions {
-        unitTests.isReturnDefaultValues = true
-    }
-}
-
-dependencies {
-    implementation(libs.appcompat)
-    implementation(libs.material)
-    implementation(libs.activity)
-    implementation(libs.constraintlayout)
-    implementation(libs.navigation.fragment)
-    implementation(libs.navigation.ui)
-    implementation(libs.annotation)
-    implementation(libs.lifecycle.livedata.ktx)
-    implementation(libs.lifecycle.viewmodel.ktx)
-    implementation(libs.room.runtime)
-    implementation(libs.google.material)
-    implementation(libs.swiperefreshlayout)
-    annotationProcessor(libs.androidx.room.compiler)
-    testImplementation(libs.junit)
-    androidTestImplementation(libs.ext.junit)
-    androidTestImplementation(libs.espresso.core)
-    // https://mvnrepository.com/artifact/com.github.PhilJay/MPAndroidChart
-    implementation(libs.mpandroidchart)
-
-
-
-    // Firebase BOM - manages all Firebase library versions
-    implementation(platform(libs.firebase.bom))
-    implementation(libs.firebase.auth)
-    implementation(libs.firebase.firestore)
-
-    // Google Play Services BOM - manages all Play Services library versions
-    implementation(libs.credentials)
-    implementation(libs.credentials.play.services.auth)
-    implementation(libs.googleid)
-
-    testImplementation(libs.junit)
-    androidTestImplementation(libs.ext.junit)
-    androidTestImplementation(libs.espresso.core)
+plugins {
+    alias(libs.plugins.android.application)
+    alias(libs.plugins.google.gms.google.services)
+}
+
+android {
+    namespace = "com.melisa.innovamotionapp"
+    compileSdk = 35
+
+    defaultConfig {
+        applicationId = "com.melisa.innovamotionapp"
+        minSdk = 26
+        targetSdk = 34
+        versionCode = 1
+        versionName = "1.0"
+
+        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+    }
+
+    buildTypes {
+        release {
+            isMinifyEnabled = false
+            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
+        }
+    }
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_1_8
+        targetCompatibility = JavaVersion.VERSION_1_8
+    }
+    buildFeatures {
+        viewBinding = true
+    }
+    
+    // Allow Android framework classes to return default values in unit tests
+    // This prevents RuntimeException for Log.d(), etc.
+    testOptions {
+        unitTests.isReturnDefaultValues = true
+    }
+}
+
+dependencies {
+    implementation(libs.appcompat)
+    implementation(libs.material)
+    implementation(libs.activity)
+    implementation(libs.constraintlayout)
+    implementation(libs.navigation.fragment)
+    implementation(libs.navigation.ui)
+    implementation(libs.annotation)
+    implementation(libs.lifecycle.livedata.ktx)
+    implementation(libs.lifecycle.viewmodel.ktx)
+    implementation(libs.room.runtime)
+    implementation(libs.google.material)
+    implementation(libs.swiperefreshlayout)
+    annotationProcessor(libs.androidx.room.compiler)
+    testImplementation(libs.junit)
+    androidTestImplementation(libs.ext.junit)
+    androidTestImplementation(libs.espresso.core)
+    // https://mvnrepository.com/artifact/com.github.PhilJay/MPAndroidChart
+    implementation(libs.mpandroidchart)
+
+
+
+    // Firebase BOM - manages all Firebase library versions
+    implementation(platform(libs.firebase.bom))
+    implementation(libs.firebase.auth)
+    implementation(libs.firebase.firestore)
+
+    // Google Play Services BOM - manages all Play Services library versions
+    implementation(libs.credentials)
+    implementation(libs.credentials.play.services.auth)
+    implementation(libs.googleid)
+
+    testImplementation(libs.junit)
+    androidTestImplementation(libs.ext.junit)
+    androidTestImplementation(libs.espresso.core)
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/google-services.json b/InnovaMotionApp/app/google-services.json
index 85c738c..9af5346 100644
--- a/InnovaMotionApp/app/google-services.json
+++ b/InnovaMotionApp/app/google-services.json
@@ -1,84 +1,84 @@
-{
-  "project_info": {
-    "project_number": "398515951058",
-    "project_id": "innovamotion-app",
-    "storage_bucket": "innovamotion-app.firebasestorage.app"
-  },
-  "client": [
-    {
-      "client_info": {
-        "mobilesdk_app_id": "1:398515951058:android:d0a0fa1541739f796fe40b",
-        "android_client_info": {
-          "package_name": "com.googlesignintest"
-        }
-      },
-      "oauth_client": [
-        {
-          "client_id": "398515951058-g0m0eu210o6rmifbqjvdsra31lht8g8f.apps.googleusercontent.com",
-          "client_type": 3
-        }
-      ],
-      "api_key": [
-        {
-          "current_key": "AIzaSyAjxq82b_7UCH-B1ufCO3ePEyb952xXVrQ"
-        }
-      ],
-      "services": {
-        "appinvite_service": {
-          "other_platform_oauth_client": [
-            {
-              "client_id": "398515951058-1ioolsnd4fr4sp9aa8239st5kt42cn4u.apps.googleusercontent.com",
-              "client_type": 3
-            }
-          ]
-        }
-      }
-    },
-    {
-      "client_info": {
-        "mobilesdk_app_id": "1:398515951058:android:ef6c4ed2b6f783ba6fe40b",
-        "android_client_info": {
-          "package_name": "com.melisa.innovamotionapp"
-        }
-      },
-      "oauth_client": [
-        {
-          "client_id": "398515951058-n5kk9p43g06q5jaj5u2ou0jnbf7sobq2.apps.googleusercontent.com",
-          "client_type": 1,
-          "android_info": {
-            "package_name": "com.melisa.innovamotionapp",
-            "certificate_hash": "a852f728f647c9784196d416854bf9ff44fb3bc4"
-          }
-        },
-        {
-          "client_id": "398515951058-srj49j4lultbkt1avp14jjqqou1p9cf9.apps.googleusercontent.com",
-          "client_type": 1,
-          "android_info": {
-            "package_name": "com.melisa.innovamotionapp",
-            "certificate_hash": "7b9fa1ebc909207c5df1cfb211cc158bf17f30ce"
-          }
-        },
-        {
-          "client_id": "398515951058-g0m0eu210o6rmifbqjvdsra31lht8g8f.apps.googleusercontent.com",
-          "client_type": 3
-        }
-      ],
-      "api_key": [
-        {
-          "current_key": "AIzaSyAjxq82b_7UCH-B1ufCO3ePEyb952xXVrQ"
-        }
-      ],
-      "services": {
-        "appinvite_service": {
-          "other_platform_oauth_client": [
-            {
-              "client_id": "398515951058-1ioolsnd4fr4sp9aa8239st5kt42cn4u.apps.googleusercontent.com",
-              "client_type": 3
-            }
-          ]
-        }
-      }
-    }
-  ],
-  "configuration_version": "1"
+{
+  "project_info": {
+    "project_number": "398515951058",
+    "project_id": "innovamotion-app",
+    "storage_bucket": "innovamotion-app.firebasestorage.app"
+  },
+  "client": [
+    {
+      "client_info": {
+        "mobilesdk_app_id": "1:398515951058:android:d0a0fa1541739f796fe40b",
+        "android_client_info": {
+          "package_name": "com.googlesignintest"
+        }
+      },
+      "oauth_client": [
+        {
+          "client_id": "398515951058-g0m0eu210o6rmifbqjvdsra31lht8g8f.apps.googleusercontent.com",
+          "client_type": 3
+        }
+      ],
+      "api_key": [
+        {
+          "current_key": "AIzaSyAjxq82b_7UCH-B1ufCO3ePEyb952xXVrQ"
+        }
+      ],
+      "services": {
+        "appinvite_service": {
+          "other_platform_oauth_client": [
+            {
+              "client_id": "398515951058-1ioolsnd4fr4sp9aa8239st5kt42cn4u.apps.googleusercontent.com",
+              "client_type": 3
+            }
+          ]
+        }
+      }
+    },
+    {
+      "client_info": {
+        "mobilesdk_app_id": "1:398515951058:android:ef6c4ed2b6f783ba6fe40b",
+        "android_client_info": {
+          "package_name": "com.melisa.innovamotionapp"
+        }
+      },
+      "oauth_client": [
+        {
+          "client_id": "398515951058-n5kk9p43g06q5jaj5u2ou0jnbf7sobq2.apps.googleusercontent.com",
+          "client_type": 1,
+          "android_info": {
+            "package_name": "com.melisa.innovamotionapp",
+            "certificate_hash": "a852f728f647c9784196d416854bf9ff44fb3bc4"
+          }
+        },
+        {
+          "client_id": "398515951058-srj49j4lultbkt1avp14jjqqou1p9cf9.apps.googleusercontent.com",
+          "client_type": 1,
+          "android_info": {
+            "package_name": "com.melisa.innovamotionapp",
+            "certificate_hash": "7b9fa1ebc909207c5df1cfb211cc158bf17f30ce"
+          }
+        },
+        {
+          "client_id": "398515951058-g0m0eu210o6rmifbqjvdsra31lht8g8f.apps.googleusercontent.com",
+          "client_type": 3
+        }
+      ],
+      "api_key": [
+        {
+          "current_key": "AIzaSyAjxq82b_7UCH-B1ufCO3ePEyb952xXVrQ"
+        }
+      ],
+      "services": {
+        "appinvite_service": {
+          "other_platform_oauth_client": [
+            {
+              "client_id": "398515951058-1ioolsnd4fr4sp9aa8239st5kt42cn4u.apps.googleusercontent.com",
+              "client_type": 3
+            }
+          ]
+        }
+      }
+    }
+  ],
+  "configuration_version": "1"
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/proguard-rules.pro b/InnovaMotionApp/app/proguard-rules.pro
index 481bb43..64b4a05 100644
--- a/InnovaMotionApp/app/proguard-rules.pro
+++ b/InnovaMotionApp/app/proguard-rules.pro
@@ -1,21 +1,21 @@
-# Add project specific ProGuard rules here.
-# You can control the set of applied configuration files using the
-# proguardFiles setting in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
 #-renamesourcefileattribute SourceFile
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/androidTest/java/com/melisa/innovamotionapp/ExampleInstrumentedTest.java b/InnovaMotionApp/app/src/androidTest/java/com/melisa/innovamotionapp/ExampleInstrumentedTest.java
index 0cab44d..f1dc26b 100644
--- a/InnovaMotionApp/app/src/androidTest/java/com/melisa/innovamotionapp/ExampleInstrumentedTest.java
+++ b/InnovaMotionApp/app/src/androidTest/java/com/melisa/innovamotionapp/ExampleInstrumentedTest.java
@@ -1,26 +1,26 @@
-package com.melisa.innovamotionapp;
-
-import static org.junit.Assert.assertEquals;
-
-import android.content.Context;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-import androidx.test.platform.app.InstrumentationRegistry;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/**
- * Instrumented test, which will execute on an Android device.
- *
- * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
- */
-@RunWith(AndroidJUnit4.class)
-public class ExampleInstrumentedTest {
-    @Test
-    public void useAppContext() {
-        // Context of the app under test.
-        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
-        assertEquals("com.melisa.innovamotionapp", appContext.getPackageName());
-    }
+package com.melisa.innovamotionapp;
+
+import static org.junit.Assert.assertEquals;
+
+import android.content.Context;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        assertEquals("com.melisa.innovamotionapp", appContext.getPackageName());
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/AndroidManifest.xml b/InnovaMotionApp/app/src/main/AndroidManifest.xml
index 745a983..4ba70b7 100644
--- a/InnovaMotionApp/app/src/main/AndroidManifest.xml
+++ b/InnovaMotionApp/app/src/main/AndroidManifest.xml
@@ -1,107 +1,107 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools">
-    <uses-permission android:name="android.permission.INTERNET" />
-
-
-    <!-- Request legacy Bluetooth permissions for devices on API 29,30. -->
-    <uses-permission
-        android:name="android.permission.BLUETOOTH"
-        android:maxSdkVersion="30" />
-    <uses-permission
-        android:name="android.permission.BLUETOOTH_ADMIN"
-        android:maxSdkVersion="30" />
-    <uses-permission
-        android:name="android.permission.ACCESS_FINE_LOCATION"
-        android:maxSdkVersion="30" />
-    <uses-permission
-        android:name="android.permission.ACCESS_COARSE_LOCATION"
-        android:maxSdkVersion="30" />
-
-    <!-- Request Bluetooth permissions for devices on API 31,32. -->
-    <uses-permission
-        android:name="android.permission.BLUETOOTH_SCAN"
-        android:usesPermissionFlags="neverForLocation"
-        tools:targetApi="s" />
-    <!-- Needed only if your app communicates with already-paired Bluetooth
-             devices. -->
-    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
-    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
-    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
-    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"
-        android:minSdkVersion="33"/>
-
-    <!-- Since Bluetooth is a basic requirement for our app -->
-    <uses-feature
-        android:name="android.hardware.bluetooth"
-        android:required="true" />
-
-
-    <application
-        android:name=".utils.GlobalData"
-        android:allowBackup="true"
-        android:dataExtractionRules="@xml/data_extraction_rules"
-        android:fullBackupContent="@xml/backup_rules"
-        android:icon="@mipmap/ic_launcher"
-        android:label="@string/app_name"
-        android:roundIcon="@mipmap/ic_launcher_round"
-        android:supportsRtl="true"
-        android:theme="@style/Theme.InnovaMotionApp"
-        tools:targetApi="31">
-
-        <activity
-            android:name=".activities.AggregatorDashboardActivity"
-            android:exported="false"
-            android:label="@string/app_name" />
-        <activity
-            android:name=".activities.PersonNamesActivity"
-            android:exported="false"
-            android:parentActivityName=".activities.AggregatorDashboardActivity" />
-        <activity
-            android:name=".activities.SupervisorDashboardActivity"
-            android:exported="false"
-            android:label="@string/supervisor_dashboard" />
-        <activity
-            android:name=".activities.EnergyConsumptionActivity"/>
-        <activity
-            android:name=".activities.TimeLapseActivity"/>
-        <activity
-            android:name=".activities.StatisticsActivity"/>
-        <activity
-            android:name=".activities.BtConnectedActivity"
-            android:windowSoftInputMode="adjustNothing"/>
-        <activity
-            android:name=".activities.BtSettingsActivity"
-            android:exported="false"
-            android:windowSoftInputMode="adjustNothing"/>
-        <activity
-            android:name="com.melisa.innovamotionapp._login.login.LoginActivity"
-            android:exported="false"
-            android:label="@string/title_activity_login" />
-        <activity
-            android:name=".activities.StartActivity"
-            android:exported="false">
-            <!--            android:exported="true">-->
-            <!--            <intent-filter>-->
-            <!--                <action android:name="android.intent.action.MAIN" />-->
-
-            <!--                <category android:name="android.intent.category.LAUNCHER" />-->
-            <!--            </intent-filter>-->
-        </activity>
-        <activity
-            android:name=".activities.MainActivity"
-            android:exported="true"
-            android:theme="@style/Theme.InnovaMotionApp">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-        <service
-            android:name=".bluetooth.DeviceCommunicationService"
-            android:exported="false"
-            android:foregroundServiceType="dataSync" />
-    </application>
-
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools">
+    <uses-permission android:name="android.permission.INTERNET" />
+
+
+    <!-- Request legacy Bluetooth permissions for devices on API 29,30. -->
+    <uses-permission
+        android:name="android.permission.BLUETOOTH"
+        android:maxSdkVersion="30" />
+    <uses-permission
+        android:name="android.permission.BLUETOOTH_ADMIN"
+        android:maxSdkVersion="30" />
+    <uses-permission
+        android:name="android.permission.ACCESS_FINE_LOCATION"
+        android:maxSdkVersion="30" />
+    <uses-permission
+        android:name="android.permission.ACCESS_COARSE_LOCATION"
+        android:maxSdkVersion="30" />
+
+    <!-- Request Bluetooth permissions for devices on API 31,32. -->
+    <uses-permission
+        android:name="android.permission.BLUETOOTH_SCAN"
+        android:usesPermissionFlags="neverForLocation"
+        tools:targetApi="s" />
+    <!-- Needed only if your app communicates with already-paired Bluetooth
+             devices. -->
+    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
+    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
+    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
+    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"
+        android:minSdkVersion="33"/>
+
+    <!-- Since Bluetooth is a basic requirement for our app -->
+    <uses-feature
+        android:name="android.hardware.bluetooth"
+        android:required="true" />
+
+
+    <application
+        android:name=".utils.GlobalData"
+        android:allowBackup="true"
+        android:dataExtractionRules="@xml/data_extraction_rules"
+        android:fullBackupContent="@xml/backup_rules"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:roundIcon="@mipmap/ic_launcher_round"
+        android:supportsRtl="true"
+        android:theme="@style/Theme.InnovaMotionApp"
+        tools:targetApi="31">
+
+        <activity
+            android:name=".activities.AggregatorDashboardActivity"
+            android:exported="false"
+            android:label="@string/app_name" />
+        <activity
+            android:name=".activities.PersonNamesActivity"
+            android:exported="false"
+            android:parentActivityName=".activities.AggregatorDashboardActivity" />
+        <activity
+            android:name=".activities.SupervisorDashboardActivity"
+            android:exported="false"
+            android:label="@string/supervisor_dashboard" />
+        <activity
+            android:name=".activities.EnergyConsumptionActivity"/>
+        <activity
+            android:name=".activities.TimeLapseActivity"/>
+        <activity
+            android:name=".activities.StatisticsActivity"/>
+        <activity
+            android:name=".activities.BtConnectedActivity"
+            android:windowSoftInputMode="adjustNothing"/>
+        <activity
+            android:name=".activities.BtSettingsActivity"
+            android:exported="false"
+            android:windowSoftInputMode="adjustNothing"/>
+        <activity
+            android:name="com.melisa.innovamotionapp._login.login.LoginActivity"
+            android:exported="false"
+            android:label="@string/title_activity_login" />
+        <activity
+            android:name=".activities.StartActivity"
+            android:exported="false">
+            <!--            android:exported="true">-->
+            <!--            <intent-filter>-->
+            <!--                <action android:name="android.intent.action.MAIN" />-->
+
+            <!--                <category android:name="android.intent.category.LAUNCHER" />-->
+            <!--            </intent-filter>-->
+        </activity>
+        <activity
+            android:name=".activities.MainActivity"
+            android:exported="true"
+            android:theme="@style/Theme.InnovaMotionApp">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <service
+            android:name=".bluetooth.DeviceCommunicationService"
+            android:exported="false"
+            android:foregroundServiceType="dataSync" />
+    </application>
+
 </manifest>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginDataSource.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginDataSource.java
index 163b65e..70ffc3d 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginDataSource.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginDataSource.java
@@ -1,29 +1,29 @@
-package com.melisa.innovamotionapp._login.data;
-
-import com.melisa.innovamotionapp._login.data.model.LoggedInUser;
-
-import java.io.IOException;
-
-/**
- * Class that handles authentication w/ login credentials and retrieves user information.
- */
-public class LoginDataSource {
-
-    public Result<LoggedInUser> login(String username, String password) {
-
-        try {
-            // This legacy email/password flow is deprecated in favor of Google Sign-In.
-            // Keep a fake success to preserve sample behavior if used.
-            LoggedInUser placeholderUser = new LoggedInUser(
-                            java.util.UUID.randomUUID().toString(),
-                            username);
-            return new Result.Success<>(placeholderUser);
-        } catch (Exception e) {
-            return new Result.Error(new IOException("Error logging in", e));
-        }
-    }
-
-    public void logout() {
-        // TODO: revoke authentication
-    }
+package com.melisa.innovamotionapp._login.data;
+
+import com.melisa.innovamotionapp._login.data.model.LoggedInUser;
+
+import java.io.IOException;
+
+/**
+ * Class that handles authentication w/ login credentials and retrieves user information.
+ */
+public class LoginDataSource {
+
+    public Result<LoggedInUser> login(String username, String password) {
+
+        try {
+            // This legacy email/password flow is deprecated in favor of Google Sign-In.
+            // Keep a fake success to preserve sample behavior if used.
+            LoggedInUser placeholderUser = new LoggedInUser(
+                            java.util.UUID.randomUUID().toString(),
+                            username);
+            return new Result.Success<>(placeholderUser);
+        } catch (Exception e) {
+            return new Result.Error(new IOException("Error logging in", e));
+        }
+    }
+
+    public void logout() {
+        // TODO: revoke authentication
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginRepository.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginRepository.java
index 0e68803..afbe1a6 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginRepository.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/LoginRepository.java
@@ -1,54 +1,54 @@
-package com.melisa.innovamotionapp._login.data;
-
-import com.melisa.innovamotionapp._login.data.model.LoggedInUser;
-
-/**
- * Class that requests authentication and user information from the remote data source and
- * maintains an in-memory cache of login status and user credentials information.
- */
-public class LoginRepository {
-
-    private static volatile LoginRepository instance;
-
-    private LoginDataSource dataSource;
-
-    // If user credentials will be cached in local storage, it is recommended it be encrypted
-    // @see https://developer.android.com/training/articles/keystore
-    private LoggedInUser user = null;
-
-    // private constructor : singleton access
-    private LoginRepository(LoginDataSource dataSource) {
-        this.dataSource = dataSource;
-    }
-
-    public static LoginRepository getInstance(LoginDataSource dataSource) {
-        if (instance == null) {
-            instance = new LoginRepository(dataSource);
-        }
-        return instance;
-    }
-
-    public boolean isLoggedIn() {
-        return user != null;
-    }
-
-    public void logout() {
-        user = null;
-        dataSource.logout();
-    }
-
-    private void setLoggedInUser(LoggedInUser user) {
-        this.user = user;
-        // If user credentials will be cached in local storage, it is recommended it be encrypted
-        // @see https://developer.android.com/training/articles/keystore
-    }
-
-    public Result<LoggedInUser> login(String username, String password) {
-        // handle login
-        Result<LoggedInUser> result = dataSource.login(username, password);
-        if (result instanceof Result.Success) {
-            setLoggedInUser(((Result.Success<LoggedInUser>) result).getData());
-        }
-        return result;
-    }
+package com.melisa.innovamotionapp._login.data;
+
+import com.melisa.innovamotionapp._login.data.model.LoggedInUser;
+
+/**
+ * Class that requests authentication and user information from the remote data source and
+ * maintains an in-memory cache of login status and user credentials information.
+ */
+public class LoginRepository {
+
+    private static volatile LoginRepository instance;
+
+    private LoginDataSource dataSource;
+
+    // If user credentials will be cached in local storage, it is recommended it be encrypted
+    // @see https://developer.android.com/training/articles/keystore
+    private LoggedInUser user = null;
+
+    // private constructor : singleton access
+    private LoginRepository(LoginDataSource dataSource) {
+        this.dataSource = dataSource;
+    }
+
+    public static LoginRepository getInstance(LoginDataSource dataSource) {
+        if (instance == null) {
+            instance = new LoginRepository(dataSource);
+        }
+        return instance;
+    }
+
+    public boolean isLoggedIn() {
+        return user != null;
+    }
+
+    public void logout() {
+        user = null;
+        dataSource.logout();
+    }
+
+    private void setLoggedInUser(LoggedInUser user) {
+        this.user = user;
+        // If user credentials will be cached in local storage, it is recommended it be encrypted
+        // @see https://developer.android.com/training/articles/keystore
+    }
+
+    public Result<LoggedInUser> login(String username, String password) {
+        // handle login
+        Result<LoggedInUser> result = dataSource.login(username, password);
+        if (result instanceof Result.Success) {
+            setLoggedInUser(((Result.Success<LoggedInUser>) result).getData());
+        }
+        return result;
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/Result.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/Result.java
index a5abe8b..f7971b0 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/Result.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/Result.java
@@ -1,48 +1,48 @@
-package com.melisa.innovamotionapp._login.data;
-
-/**
- * A generic class that holds a result success w/ data or an error exception.
- */
-public class Result<T> {
-    // hide the private constructor to limit subclass types (Success, Error)
-    private Result() {
-    }
-
-    @Override
-    public String toString() {
-        if (this instanceof Result.Success) {
-            Result.Success success = (Result.Success) this;
-            return "Success[data=" + success.getData().toString() + "]";
-        } else if (this instanceof Result.Error) {
-            Result.Error error = (Result.Error) this;
-            return "Error[exception=" + error.getError().toString() + "]";
-        }
-        return "";
-    }
-
-    // Success sub-class
-    public final static class Success<T> extends Result {
-        private T data;
-
-        public Success(T data) {
-            this.data = data;
-        }
-
-        public T getData() {
-            return this.data;
-        }
-    }
-
-    // Error sub-class
-    public final static class Error extends Result {
-        private Exception error;
-
-        public Error(Exception error) {
-            this.error = error;
-        }
-
-        public Exception getError() {
-            return this.error;
-        }
-    }
+package com.melisa.innovamotionapp._login.data;
+
+/**
+ * A generic class that holds a result success w/ data or an error exception.
+ */
+public class Result<T> {
+    // hide the private constructor to limit subclass types (Success, Error)
+    private Result() {
+    }
+
+    @Override
+    public String toString() {
+        if (this instanceof Result.Success) {
+            Result.Success success = (Result.Success) this;
+            return "Success[data=" + success.getData().toString() + "]";
+        } else if (this instanceof Result.Error) {
+            Result.Error error = (Result.Error) this;
+            return "Error[exception=" + error.getError().toString() + "]";
+        }
+        return "";
+    }
+
+    // Success sub-class
+    public final static class Success<T> extends Result {
+        private T data;
+
+        public Success(T data) {
+            this.data = data;
+        }
+
+        public T getData() {
+            return this.data;
+        }
+    }
+
+    // Error sub-class
+    public final static class Error extends Result {
+        private Exception error;
+
+        public Error(Exception error) {
+            this.error = error;
+        }
+
+        public Exception getError() {
+            return this.error;
+        }
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/model/LoggedInUser.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/model/LoggedInUser.java
index 9bf13b5..99f7f2c 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/model/LoggedInUser.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/data/model/LoggedInUser.java
@@ -1,23 +1,23 @@
-package com.melisa.innovamotionapp._login.data.model;
-
-/**
- * Data class that captures user information for logged in users retrieved from LoginRepository
- */
-public class LoggedInUser {
-
-    private String userId;
-    private String displayName;
-
-    public LoggedInUser(String userId, String displayName) {
-        this.userId = userId;
-        this.displayName = displayName;
-    }
-
-    public String getUserId() {
-        return userId;
-    }
-
-    public String getDisplayName() {
-        return displayName;
-    }
+package com.melisa.innovamotionapp._login.data.model;
+
+/**
+ * Data class that captures user information for logged in users retrieved from LoginRepository
+ */
+public class LoggedInUser {
+
+    private String userId;
+    private String displayName;
+
+    public LoggedInUser(String userId, String displayName) {
+        this.userId = userId;
+        this.displayName = displayName;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public String getDisplayName() {
+        return displayName;
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoggedInUserView.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoggedInUserView.java
index 4dcba21..7485fb3 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoggedInUserView.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoggedInUserView.java
@@ -1,17 +1,17 @@
-package com.melisa.innovamotionapp._login.login;
-
-/**
- * Class exposing authenticated user details to the UI.
- */
-class LoggedInUserView {
-    private String displayName;
-    //... other data fields that may be accessible to the UI
-
-    LoggedInUserView(String displayName) {
-        this.displayName = displayName;
-    }
-
-    String getDisplayName() {
-        return displayName;
-    }
+package com.melisa.innovamotionapp._login.login;
+
+/**
+ * Class exposing authenticated user details to the UI.
+ */
+class LoggedInUserView {
+    private String displayName;
+    //... other data fields that may be accessible to the UI
+
+    LoggedInUserView(String displayName) {
+        this.displayName = displayName;
+    }
+
+    String getDisplayName() {
+        return displayName;
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginActivity.java
index bc20615..70e6b0a 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginActivity.java
@@ -1,806 +1,801 @@
-package com.melisa.innovamotionapp._login.login;
-
-import android.os.Bundle;
-import android.os.CancellationSignal;
-import android.util.Log;
-import android.view.View;
-import android.content.Intent;
-import android.widget.Toast;
-import android.widget.TextView;
-import android.widget.RadioGroup;
-import android.widget.RadioButton;
-
-import androidx.annotation.NonNull;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.core.content.ContextCompat;
-import androidx.credentials.ClearCredentialStateRequest;
-import androidx.credentials.Credential;
-import androidx.credentials.CredentialManager;
-import androidx.credentials.CredentialManagerCallback;
-import androidx.credentials.CustomCredential;
-import androidx.credentials.GetCredentialRequest;
-import androidx.credentials.GetCredentialResponse;
-import androidx.credentials.exceptions.ClearCredentialException;
-import androidx.credentials.exceptions.GetCredentialException;
-
-import com.google.android.libraries.identity.googleid.GetGoogleIdOption;
-import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential;
-import com.google.android.material.button.MaterialButton;
-import com.google.android.material.textfield.TextInputEditText;
-import com.google.android.material.textfield.TextInputLayout;
-import android.text.TextWatcher;
-import android.text.Editable;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-import android.widget.PopupWindow;
-import android.os.Handler;
-import android.os.Looper;
-import android.view.ViewGroup;
-import android.view.LayoutInflater;
-import com.google.firebase.auth.AuthCredential;
-import com.google.firebase.auth.FirebaseAuth;
-import com.google.firebase.auth.FirebaseUser;
-import com.google.firebase.auth.GoogleAuthProvider;
-import com.google.firebase.firestore.DocumentReference;
-import com.google.firebase.firestore.FirebaseFirestore;
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.activities.MainActivity;
-import com.melisa.innovamotionapp.sync.FirestoreSyncService;
-import com.melisa.innovamotionapp.sync.SessionGate;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Executors;
-import java.util.List;
-import java.util.ArrayList;
-
-/**
- * LoginActivity with online-only sign-in flow that pre-fills user preferences:
- * 
- * - For SUPERVISORS: Pre-fills the aggregator email field from server data
- * - For AGGREGATOR accounts: Pre-fills the radio button selection from server data  
- * - Users can edit any pre-filled values before proceeding
- * - All preferences are fetched fresh from server on each sign-in (no local caching)
- */
-public class LoginActivity extends AppCompatActivity {
-
-    private static final String TAG = "LoginActivity";
-    private FirebaseAuth mAuth;
-    private CredentialManager credentialManager;
-    private FirebaseFirestore db;
-
-    // UI Elements
-    private MaterialButton googleSignInButton;
-    private MaterialButton signOutButton;
-    private MaterialButton proceedButton;
-    private View signedInSection;
-    private TextInputEditText aggregatorEmailInput;
-    private TextInputLayout aggregatorEmailLayout;
-    private RadioGroup roleGroup;
-    private RadioButton roleSupervisor;
-    private RadioButton roleAggregator;
-    private TextView signedInAsText;
-    private View loadingProgress;
-
-    // Autocomplete functionality
-    private PopupWindow suggestionPopup;
-    private ListView suggestionListView;
-    private ArrayAdapter<String> emailAdapter;
-    private List<String> aggregatorEmails;
-    private Handler searchHandler;
-    private Runnable searchRunnable;
-    private boolean isSettingTextProgrammatically = false;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.activity_login);
-
-        Log.d(TAG, "LoginActivity onCreate - Initializing components");
-        
-        initializeFirebase();
-        initializeCredentialManager();
-        initializeViews();
-        setupClickListeners();
-    }
-
-    private void initializeFirebase() {
-        Log.d(TAG, "Initializing Firebase Auth and Firestore");
-        mAuth = FirebaseAuth.getInstance();
-        db = FirebaseFirestore.getInstance();
-    }
-
-    private void initializeCredentialManager() {
-        try {
-            credentialManager = CredentialManager.create(this);
-            Log.d(TAG, "CredentialManager initialized successfully");
-        } catch (Exception e) {
-            Log.e(TAG, "Failed to initialize CredentialManager", e);
-            showErrorToast("Error initializing authentication services");
-        }
-    }
-
-    private void initializeViews() {
-        Log.d(TAG, "Initializing UI components");
-        googleSignInButton = findViewById(R.id.google_sign_in_button);
-        signOutButton = findViewById(R.id.sign_out_button);
-        proceedButton = findViewById(R.id.proceed_button);
-        aggregatorEmailInput = findViewById(R.id.aggregator_email);
-        aggregatorEmailLayout = findViewById(R.id.aggregator_email_layout);
-        roleGroup = findViewById(R.id.role_group);
-        roleSupervisor = findViewById(R.id.role_supervisor);
-        roleAggregator = findViewById(R.id.role_aggregator);
-        signedInAsText = findViewById(R.id.signed_in_as_text);
-        signedInSection = findViewById(R.id.signed_in_section);
-        loadingProgress = findViewById(R.id.loading);
-
-        setupAutocomplete();
-    }
-
-    private void setupAutocomplete() {
-        Log.d(TAG, "Setting up email autocomplete functionality");
-        
-        // Initialize autocomplete components
-        aggregatorEmails = new ArrayList<>();
-        emailAdapter = new ArrayAdapter<>(this, R.layout.autocomplete_item, aggregatorEmails);
-        searchHandler = new Handler(Looper.getMainLooper());
-        
-        if (aggregatorEmailInput != null) {
-            createSuggestionPopup();
-            
-            // Add text change listener for real-time search
-            aggregatorEmailInput.addTextChangedListener(new TextWatcher() {
-                @Override
-                public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
-
-                @Override
-                public void onTextChanged(CharSequence s, int start, int before, int count) {
-                    // Skip search if we're setting text programmatically
-                    if (isSettingTextProgrammatically) {
-                        return;
-                    }
-                    
-                    // Cancel previous search
-                    if (searchRunnable != null) {
-                        searchHandler.removeCallbacks(searchRunnable);
-                    }
-                    
-                    // Schedule new search with delay to avoid too many requests
-                    if (s.length() > 1) {
-                        searchRunnable = () -> searchAggregatorUsers(s.toString());
-                        searchHandler.postDelayed(searchRunnable, 300); // 300ms delay
-                    } else {
-                        // Hide popup when input is too short
-                        hideSuggestionPopup();
-                    }
-                }
-
-                @Override
-                public void afterTextChanged(Editable s) {}
-            });
-            
-            // Hide popup when focus is lost
-            aggregatorEmailInput.setOnFocusChangeListener((v, hasFocus) -> {
-                if (!hasFocus) {
-                    hideSuggestionPopup();
-                }
-            });
-            
-            Log.d(TAG, "Autocomplete setup completed");
-        }
-    }
-
-    private void createSuggestionPopup() {
-        // Create ListView for suggestions
-        suggestionListView = new ListView(this);
-        suggestionListView.setAdapter(emailAdapter);
-        suggestionListView.setDividerHeight(1);
-        suggestionListView.setDivider(ContextCompat.getDrawable(this, android.R.color.transparent));
-        suggestionListView.setBackgroundColor(ContextCompat.getColor(this, android.R.color.white));
-        suggestionListView.setElevation(8f);
-        
-        // Handle item clicks
-        suggestionListView.setOnItemClickListener((parent, view, position, id) -> {
-            String selectedEmail = aggregatorEmails.get(position);
-            Log.d(TAG, "Selected aggregator email from suggestions: " + selectedEmail);
-            
-            // Set flag to prevent triggering search when setting text programmatically
-            isSettingTextProgrammatically = true;
-            aggregatorEmailInput.setText(selectedEmail);
-            aggregatorEmailInput.setSelection(selectedEmail.length());
-            isSettingTextProgrammatically = false;
-            
-            aggregatorEmailLayout.setError(null);
-            hideSuggestionPopup();
-        });
-        
-        // Create popup window
-        suggestionPopup = new PopupWindow(suggestionListView, 
-                ViewGroup.LayoutParams.MATCH_PARENT, 
-                ViewGroup.LayoutParams.WRAP_CONTENT);
-        suggestionPopup.setOutsideTouchable(true);
-        suggestionPopup.setFocusable(false);
-        suggestionPopup.setElevation(8f);
-        suggestionPopup.setBackgroundDrawable(ContextCompat.getDrawable(this, android.R.drawable.editbox_dropdown_light_frame));
-    }
-
-    private void setupClickListeners() {
-        Log.d(TAG, "Setting up click listeners");
-        googleSignInButton.setOnClickListener(v -> signInWithGoogle());
-        signOutButton.setOnClickListener(v -> signOut());
-        proceedButton.setOnClickListener(v -> onProceed());
-        
-        // Setup role selection listener
-        if (roleGroup != null) {
-            roleGroup.setOnCheckedChangeListener((group, checkedId) -> {
-                if (checkedId == R.id.role_supervisor) {
-                    Log.d(TAG, "Supervisor role selected - showing email input");
-                    aggregatorEmailLayout.setVisibility(View.VISIBLE);
-                } else if (checkedId == R.id.role_aggregator) {
-                    Log.d(TAG, "Aggregator role selected - hiding email input");
-                    aggregatorEmailLayout.setVisibility(View.GONE);
-                    aggregatorEmailLayout.setError(null);
-                }
-            });
-        }
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        Log.d(TAG, "onStart - Checking current user authentication state");
-        
-        FirebaseUser currentUser = mAuth.getCurrentUser();
-        if (currentUser != null) {
-            Log.d(TAG, "User already authenticated: " + currentUser.getEmail());
-            checkUserInFirestore(currentUser);
-        } else {
-            Log.d(TAG, "No authenticated user found");
-            showSignInUI();
-        }
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        Log.d(TAG, "onDestroy - Cleaning up resources");
-        
-        // Clean up search handler
-        if (searchHandler != null && searchRunnable != null) {
-            searchHandler.removeCallbacks(searchRunnable);
-        }
-        
-        // Clean up popup
-        hideSuggestionPopup();
-    }
-
-    private void signInWithGoogle() {
-        Log.d(TAG, "Starting Google Sign-In process");
-        showLoading("Signing in...");
-
-        if (credentialManager == null) {
-            Log.e(TAG, "CredentialManager is null");
-            showErrorToast("Authentication service not available");
-            hideLoading();
-            return;
-        }
-
-        String webClientId = getString(R.string.default_web_client_id);
-        if (webClientId.startsWith("YOUR_")) {
-            Log.e(TAG, "Web Client ID not configured");
-            showErrorToast("Please configure your Web Client ID in strings.xml");
-            hideLoading();
-            return;
-        }
-
-        GetGoogleIdOption googleIdOption = new GetGoogleIdOption.Builder()
-                .setFilterByAuthorizedAccounts(false)
-                .setServerClientId(webClientId)
-                .build();
-
-        GetCredentialRequest request = new GetCredentialRequest.Builder()
-                .addCredentialOption(googleIdOption)
-                .build();
-
-        credentialManager.getCredentialAsync(
-                this,
-                request,
-                new CancellationSignal(),
-                Executors.newSingleThreadExecutor(),
-                new CredentialManagerCallback<GetCredentialResponse, GetCredentialException>() {
-                    @Override
-                    public void onResult(GetCredentialResponse result) {
-                        Log.d(TAG, "Credential request successful");
-                        handleSignInResult(result.getCredential());
-                    }
-
-                    @Override
-                    public void onError(GetCredentialException e) {
-                        Log.e(TAG, "Sign-in failed: " + e.getLocalizedMessage(), e);
-                        runOnUiThread(() -> {
-                            hideLoading();
-                            String errorMsg = e.getLocalizedMessage();
-                            if (errorMsg != null && errorMsg.contains("Unknown calling package")) {
-                                showErrorToast("Google Play Services issue detected");
-                            } else {
-                                showErrorToast("Sign-in failed: " + errorMsg);
-                            }
-                        });
-                    }
-                }
-        );
-    }
-
-    private void handleSignInResult(Credential credential) {
-        if (credential instanceof CustomCredential
-                && GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL.equals(credential.getType())) {
-            
-            try {
-                GoogleIdTokenCredential googleCredential = GoogleIdTokenCredential.createFrom(
-                        ((CustomCredential) credential).getData());
-                authenticateWithFirebase(googleCredential.getIdToken());
-            } catch (Exception e) {
-                Log.e(TAG, "Invalid Google ID token", e);
-                runOnUiThread(() -> {
-                        hideLoading();
-                    showErrorToast("Invalid Google ID token");
-                });
-            }
-        } else {
-            Log.w(TAG, "Invalid credential type");
-            runOnUiThread(() -> {
-                    hideLoading();
-                showErrorToast("Invalid credential type");
-            });
-        }
-    }
-
-    private void authenticateWithFirebase(String idToken) {
-        Log.d(TAG, "Authenticating with Firebase using Google token");
-        AuthCredential credential = GoogleAuthProvider.getCredential(idToken, null);
-        
-        mAuth.signInWithCredential(credential)
-                .addOnCompleteListener(this, task -> {
-                    if (task.isSuccessful()) {
-                        Log.d(TAG, "Firebase authentication successful");
-                        FirebaseUser user = mAuth.getCurrentUser();
-                        if (user != null) {
-                            showSuccessToast("Welcome " + user.getDisplayName() + "!");
-                            checkUserInFirestore(user);
-                        }
-                    } else {
-                        Log.w(TAG, "Firebase authentication failed", task.getException());
-                        hideLoading();
-                        showErrorToast("Authentication failed");
-                    }
-                });
-    }
-
-    private void checkUserInFirestore(FirebaseUser user) {
-        Log.d(TAG, "Checking user data in Firestore for UID: " + user.getUid());
-        showLoading("Loading profile...");
-        
-        DocumentReference userRef = db.collection("users").document(user.getUid());
-        userRef.get()
-                .addOnSuccessListener(document -> {
-                    if (document.exists()) {
-                        String role = document.getString("role");
-                        Log.d(TAG, "User found with role: " + (role != null ? role : "none"));
-                        // Always show role selection UI for online-only flow with pre-filling
-                        showRoleSelectionUI(user);
-                } else {
-                        Log.d(TAG, "User not found in Firestore - creating profile");
-                        createUserProfile(user);
-                }
-                })
-                .addOnFailureListener(e -> {
-            Log.e(TAG, "Error checking user in Firestore", e);
-                    handleFirestoreError(e);
-                });
-    }
-
-    private void fetchAndPreFillUserPreferences(FirebaseUser user) {
-        Log.d(TAG, "Fetching user preferences from server for UID: " + user.getUid());
-        showLoading(getString(R.string.loading_preferences));
-        
-        DocumentReference userRef = db.collection("users").document(user.getUid());
-        userRef.get()
-                .addOnSuccessListener(document -> {
-                    if (document.exists()) {
-                        String role = document.getString("role");
-                        String aggregatorEmail = document.getString("aggregatorEmail");
-                        String lastSelectedRole = document.getString("lastSelectedRole");
-                        
-                        Log.d(TAG, "Retrieved preferences - role: " + role + 
-                               ", aggregatorEmail: " + aggregatorEmail + 
-                               ", lastSelectedRole: " + lastSelectedRole);
-                        
-                        runOnUiThread(() -> {
-                            hideLoading();
-                            
-                            // Pre-fill based on user type
-                            if ("supervisor".equals(role) && aggregatorEmail != null && !aggregatorEmail.isEmpty()) {
-                                // Pre-fill aggregator email for supervisors
-                                preFillAggregatorEmail(aggregatorEmail);
-                                roleSupervisor.setChecked(true);
-                                aggregatorEmailLayout.setVisibility(View.VISIBLE);
-                                Log.d(TAG, "Pre-filled aggregator email for supervisor: " + aggregatorEmail);
-                            } else if ("aggregator".equals(role)) {
-                                // Pre-fill role selection for aggregator accounts
-                                roleAggregator.setChecked(true);
-                                aggregatorEmailLayout.setVisibility(View.GONE);
-                                Log.d(TAG, "Pre-filled aggregator role selection");
-                            } else if (lastSelectedRole != null) {
-                                // Pre-fill last selected role for users without a set role
-                                if ("supervisor".equals(lastSelectedRole)) {
-                                    roleSupervisor.setChecked(true);
-                                    aggregatorEmailLayout.setVisibility(View.VISIBLE);
-                                    if (aggregatorEmail != null && !aggregatorEmail.isEmpty()) {
-                                        preFillAggregatorEmail(aggregatorEmail);
-                                    }
-                                } else {
-                                    roleAggregator.setChecked(true);
-                                    aggregatorEmailLayout.setVisibility(View.GONE);
-                                }
-                                Log.d(TAG, "Pre-filled last selected role: " + lastSelectedRole);
-                            } else {
-                                // Default to aggregator if no preferences found
-                                roleAggregator.setChecked(true);
-                                aggregatorEmailLayout.setVisibility(View.GONE);
-                                Log.d(TAG, "No preferences found, defaulting to aggregator role");
-                            }
-                        });
-                    } else {
-                        Log.d(TAG, "No user document found, using defaults");
-                        runOnUiThread(() -> {
-                            hideLoading();
-                            roleAggregator.setChecked(true);
-                            aggregatorEmailLayout.setVisibility(View.GONE);
-                        });
-                    }
-                })
-                .addOnFailureListener(e -> {
-                    Log.w(TAG, "Error fetching user preferences: " + e.getMessage(), e);
-                    runOnUiThread(() -> {
-                        hideLoading();
-                        // Continue with defaults if fetch fails
-                        roleAggregator.setChecked(true);
-                        aggregatorEmailLayout.setVisibility(View.GONE);
-                        showErrorToast(getString(R.string.preferences_load_failed));
-                    });
-                });
-    }
-
-    private void preFillAggregatorEmail(String email) {
-        if (aggregatorEmailInput != null && email != null && !email.isEmpty()) {
-            // Set flag to prevent triggering search when setting text programmatically
-            isSettingTextProgrammatically = true;
-            aggregatorEmailInput.setText(email);
-            aggregatorEmailInput.setSelection(email.length());
-            isSettingTextProgrammatically = false;
-            aggregatorEmailLayout.setError(null);
-            Log.d(TAG, "Pre-filled aggregator email field with: " + email);
-        }
-    }
-
-    private void createUserProfile(FirebaseUser user) {
-        Log.d(TAG, "Creating user profile for: " + user.getEmail());
-        
-        Map<String, Object> userData = new HashMap<>();
-        userData.put("uid", user.getUid());
-        userData.put("displayName", user.getDisplayName());
-        userData.put("email", user.getEmail());
-        userData.put("photoUrl", user.getPhotoUrl() != null ? user.getPhotoUrl().toString() : null);
-        userData.put("createdAt", System.currentTimeMillis());
-        userData.put("lastSignIn", System.currentTimeMillis());
-
-        db.collection("users").document(user.getUid())
-                .set(userData)
-                .addOnSuccessListener(aVoid -> {
-                    Log.d(TAG, "User profile created successfully");
-                    showRoleSelectionUI(user);
-                })
-                .addOnFailureListener(e -> {
-                    Log.e(TAG, "Failed to create user profile", e);
-                    handleFirestoreError(e);
-                });
-    }
-
-    private void showRoleSelectionUI(FirebaseUser user) {
-        Log.d(TAG, "Showing role selection UI for: " + user.getEmail());
-        runOnUiThread(() -> {
-            googleSignInButton.setVisibility(View.GONE);
-            signedInSection.setVisibility(View.VISIBLE);
-            signOutButton.setVisibility(View.VISIBLE);
-            
-            signedInAsText.setText("Welcome " + user.getDisplayName() + "!\nPlease select your role:");
-        });
-        
-        // Fetch and pre-fill user preferences from server
-        fetchAndPreFillUserPreferences(user);
-    }
-
-    private void showSignInUI() {
-        Log.d(TAG, "Showing sign-in UI");
-        googleSignInButton.setVisibility(View.VISIBLE);
-        signedInSection.setVisibility(View.GONE);
-        signOutButton.setVisibility(View.GONE);
-        hideLoading();
-    }
-
-    private void onProceed() {
-        Log.d(TAG, "Proceed button clicked");
-        
-        FirebaseUser currentUser = mAuth.getCurrentUser();
-        if (currentUser == null) {
-            Log.w(TAG, "No authenticated user found during proceed");
-            showErrorToast("Authentication required");
-            return;
-        }
-
-        int selectedId = roleGroup.getCheckedRadioButtonId();
-        if (selectedId == -1) {
-            showErrorToast("Please select a role");
-            return;
-        }
-
-        showLoading("Saving your role...");
-        proceedButton.setEnabled(false);
-        signOutButton.setEnabled(false);
-
-        String role = (selectedId == R.id.role_supervisor) ? "supervisor" : "aggregator";
-        String aggregatorEmail = null;
-
-        if (selectedId == R.id.role_supervisor) {
-            aggregatorEmail = aggregatorEmailInput.getText() != null ? 
-                    aggregatorEmailInput.getText().toString().trim() : "";
-            
-            if (aggregatorEmail.isEmpty()) {
-                aggregatorEmailLayout.setError(getString(R.string.aggregator_email_required));
-                aggregatorEmailLayout.requestFocus();
-                hideLoading();
-                proceedButton.setEnabled(true);
-                signOutButton.setEnabled(true);
-                return;
-            }
-            
-            if (!isValidGmail(aggregatorEmail)) {
-                aggregatorEmailLayout.setError(getString(R.string.invalid_email));
-                aggregatorEmailLayout.requestFocus();
-                hideLoading();
-                proceedButton.setEnabled(true);
-                signOutButton.setEnabled(true);
-                return;
-            }
-            
-            aggregatorEmailLayout.setError(null);
-        }
-
-        saveUserRole(currentUser, role, aggregatorEmail);
-    }
-
-    private void saveUserRole(FirebaseUser user, String role, String aggregatorEmail) {
-        Log.d(TAG, "Saving role '" + role + "' for user: " + user.getUid() + 
-               (aggregatorEmail != null ? ", aggregator email: " + aggregatorEmail : ""));
-
-        Map<String, Object> updates = new HashMap<>();
-        updates.put("role", role);
-        updates.put("lastSelectedRole", role); // Save for future pre-filling
-        updates.put("lastSignIn", System.currentTimeMillis());
-        if (aggregatorEmail != null && !aggregatorEmail.isEmpty()) {
-            updates.put("aggregatorEmail", aggregatorEmail);
-        }
-
-        db.collection("users").document(user.getUid())
-                .update(updates)
-                .addOnSuccessListener(aVoid -> {
-                    Log.d(TAG, "âœ… User role and preferences saved to Firestore");
-                    
-                    // Show loading while we reload session
-                    showLoading("Loading your account...");
-                    
-                    // NOW reload session and trigger bootstrap with confirmed role
-                    SessionGate.getInstance(this).reloadSessionAndBootstrap(
-                        new SessionGate.SessionReadyCallback() {
-                            @Override
-                            public void onSessionReady(String userId, String confirmedRole, List<String> supervisedUserIds) {
-                                Log.i(TAG, "âœ… Session ready with confirmed role: " + confirmedRole);
-                                runOnUiThread(() -> {
-                                    hideLoading();
-                                    showSuccessToast("Role set successfully!");
-                                    navigateToMainActivity();
-                                });
-                            }
-                            
-                            @Override
-                            public void onSessionError(String error) {
-                                Log.e(TAG, "âš ï¸ Session reload failed: " + error);
-                                runOnUiThread(() -> {
-                                    hideLoading();
-                                    showErrorToast("Session error: " + error);
-                                    // Proceed anyway - user can try again
-                                    navigateToMainActivity();
-                                });
-                            }
-                        }
-                    );
-                })
-                .addOnFailureListener(e -> {
-                    Log.e(TAG, "Failed to save user role", e);
-                    runOnUiThread(() -> {
-                        hideLoading();
-                        proceedButton.setEnabled(true);
-                        signOutButton.setEnabled(true);
-                        handleFirestoreError(e);
-                    });
-                });
-    }
-
-    private void signOut() {
-        Log.d(TAG, "Starting sign-out process");
-        showLoading("Signing out...");
-        
-        mAuth.signOut();
-
-        ClearCredentialStateRequest clearRequest = new ClearCredentialStateRequest();
-        credentialManager.clearCredentialStateAsync(
-                clearRequest,
-                new CancellationSignal(),
-                Executors.newSingleThreadExecutor(),
-                new CredentialManagerCallback<Void, ClearCredentialException>() {
-                    @Override
-                    public void onResult(@NonNull Void result) {
-                        Log.d(TAG, "Credentials cleared successfully");
-                        runOnUiThread(() -> {
-                            showSignInUI();
-                            showSuccessToast("Signed out successfully");
-                        });
-                    }
-
-                    @Override
-                    public void onError(@NonNull ClearCredentialException e) {
-                        Log.w(TAG, "Error clearing credentials: " + e.getLocalizedMessage());
-                        runOnUiThread(() -> {
-                            showSignInUI();
-                            showSuccessToast("Sign-out completed");
-                        });
-                    }
-                });
-    }
-
-    private void navigateToMainActivity() {
-        Log.d(TAG, "Navigating to MainActivity");
-        Intent intent = new Intent(this, MainActivity.class);
-        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
-        startActivity(intent);
-        finish();
-    }
-
-    private void handleFirestoreError(Exception e) {
-        String errorMessage = e.getMessage() != null ? e.getMessage() : "Unknown error";
-        
-        if (errorMessage.contains("PERMISSION_DENIED")) {
-            Log.w(TAG, "Permission denied - signing out user");
-            showErrorToast("Permission denied. Please sign in again.");
-            signOut();
-        } else {
-            Log.e(TAG, "Firestore error: " + errorMessage);
-            showErrorToast("Database error: " + errorMessage);
-        }
-    }
-
-    private void searchAggregatorUsers(String query) {
-        if (query.trim().isEmpty() || query.length() < 2) {
-            return;
-        }
-
-        Log.d(TAG, "Searching for aggregator users matching: '" + query + "'");
-        
-        // Search for users with role 'aggregator' and email containing the query
-        db.collection("users")
-                .whereEqualTo("role", "aggregator")
-                .get()
-                .addOnSuccessListener(queryDocumentSnapshots -> {
-                    List<String> matchingEmails = new ArrayList<>();
-                    String lowerQuery = query.toLowerCase();
-                    
-                    queryDocumentSnapshots.forEach(document -> {
-                        String email = document.getString("email");
-                        if (email != null && email.toLowerCase().contains(lowerQuery)) {
-                            matchingEmails.add(email);
-                            Log.d(TAG, "Found matching aggregator user: " + email);
-                        }
-                    });
-                    
-                    Log.d(TAG, "Search completed: " + matchingEmails.size() + " aggregator users found matching '" + query + "'");
-                    
-                    runOnUiThread(() -> {
-                        aggregatorEmails.clear();
-                        aggregatorEmails.addAll(matchingEmails);
-                        emailAdapter.notifyDataSetChanged();
-                        
-                        if (!matchingEmails.isEmpty() && aggregatorEmailInput.hasFocus()) {
-                            Log.d(TAG, "Showing popup with " + matchingEmails.size() + " suggestions");
-                            showSuggestionPopup();
-                        } else if (matchingEmails.isEmpty()) {
-                            Log.d(TAG, "No aggregator users found matching '" + query + "' - user can enter manually");
-                            hideSuggestionPopup();
-                        }
-                    });
-                })
-                .addOnFailureListener(e -> {
-                    Log.w(TAG, "Error searching aggregator users: " + e.getMessage(), e);
-                    // Don't show error to user, just continue with manual entry
-                    // This allows the flow to continue even if database is unavailable
-                });
-    }
-
-    private void showSuggestionPopup() {
-        if (suggestionPopup != null && !suggestionPopup.isShowing() && aggregatorEmailInput != null) {
-            try {
-                // Calculate popup width to match the TextInputLayout
-                int width = aggregatorEmailLayout != null ? aggregatorEmailLayout.getWidth() : aggregatorEmailInput.getWidth();
-                suggestionPopup.setWidth(width);
-                
-                // Show popup below the input field
-                suggestionPopup.showAsDropDown(aggregatorEmailInput, 0, 0);
-                Log.d(TAG, "Suggestion popup shown with " + aggregatorEmails.size() + " items");
-            } catch (Exception e) {
-                Log.w(TAG, "Error showing suggestion popup", e);
-            }
-        }
-    }
-
-    private void hideSuggestionPopup() {
-        if (suggestionPopup != null && suggestionPopup.isShowing()) {
-            try {
-                suggestionPopup.dismiss();
-                Log.d(TAG, "Suggestion popup hidden");
-            } catch (Exception e) {
-                Log.w(TAG, "Error hiding suggestion popup", e);
-            }
-        }
-    }
-
-    private boolean isValidGmail(String email) {
-        return email.matches("^[A-Za-z0-9+_.-]+@gmail\\.com$");
-    }
-
-    private void showLoading(String message) {
-        Log.d(TAG, "Showing loading: " + message);
-        runOnUiThread(() -> {
-            loadingProgress.setVisibility(View.VISIBLE);
-        googleSignInButton.setEnabled(false);
-            if (proceedButton != null) {
-                proceedButton.setEnabled(false);
-            }
-            if (signOutButton != null) {
-                signOutButton.setEnabled(false);
-            }
-        });
-    }
-
-    private void hideLoading() {
-        Log.d(TAG, "Hiding loading");
-        runOnUiThread(() -> {
-            loadingProgress.setVisibility(View.GONE);
-        googleSignInButton.setEnabled(true);
-            if (proceedButton != null) {
-                proceedButton.setEnabled(true);
-            }
-            if (signOutButton != null) {
-                signOutButton.setEnabled(true);
-            }
-        });
-    }
-
-    private void showSuccessToast(String message) {
-        Log.i(TAG, "Success: " + message);
-        runOnUiThread(() -> Toast.makeText(this, message, Toast.LENGTH_SHORT).show());
-    }
-
-    private void showErrorToast(String message) {
-        Log.e(TAG, "Error: " + message);
-        runOnUiThread(() -> Toast.makeText(this, message, Toast.LENGTH_LONG).show());
-    }
+package com.melisa.innovamotionapp._login.login;
+
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.util.Log;
+import android.view.View;
+import android.content.Intent;
+import android.widget.Toast;
+import android.widget.TextView;
+import android.widget.RadioGroup;
+import android.widget.RadioButton;
+
+import androidx.annotation.NonNull;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.content.ContextCompat;
+import androidx.credentials.ClearCredentialStateRequest;
+import androidx.credentials.Credential;
+import androidx.credentials.CredentialManager;
+import androidx.credentials.CredentialManagerCallback;
+import androidx.credentials.CustomCredential;
+import androidx.credentials.GetCredentialRequest;
+import androidx.credentials.GetCredentialResponse;
+import androidx.credentials.exceptions.ClearCredentialException;
+import androidx.credentials.exceptions.GetCredentialException;
+
+import com.google.android.libraries.identity.googleid.GetGoogleIdOption;
+import com.google.android.libraries.identity.googleid.GoogleIdTokenCredential;
+import com.google.android.material.button.MaterialButton;
+import com.google.android.material.textfield.TextInputEditText;
+import com.google.android.material.textfield.TextInputLayout;
+import android.text.TextWatcher;
+import android.text.Editable;
+import android.widget.ArrayAdapter;
+import android.widget.ListView;
+import android.widget.PopupWindow;
+import android.os.Handler;
+import android.os.Looper;
+import android.view.ViewGroup;
+import android.view.LayoutInflater;
+import com.google.firebase.auth.AuthCredential;
+import com.google.firebase.auth.FirebaseAuth;
+import com.google.firebase.auth.FirebaseUser;
+import com.google.firebase.auth.GoogleAuthProvider;
+import com.google.firebase.firestore.DocumentReference;
+import com.google.firebase.firestore.FirebaseFirestore;
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.activities.MainActivity;
+import com.melisa.innovamotionapp.sync.FirestoreSyncService;
+import com.melisa.innovamotionapp.sync.SessionGate;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executors;
+import java.util.List;
+import java.util.ArrayList;
+
+/**
+ * LoginActivity with online-only sign-in flow that pre-fills user preferences:
+ * 
+ * - For SUPERVISORS: Pre-fills the aggregator email field from server data
+ * - For AGGREGATOR accounts: Pre-fills the radio button selection from server data  
+ * - Users can edit any pre-filled values before proceeding
+ * - All preferences are fetched fresh from server on each sign-in (no local caching)
+ */
+public class LoginActivity extends AppCompatActivity {
+
+    private static final String TAG = "LoginActivity";
+    private FirebaseAuth mAuth;
+    private CredentialManager credentialManager;
+    private FirebaseFirestore db;
+
+    // UI Elements
+    private MaterialButton googleSignInButton;
+    private MaterialButton signOutButton;
+    private MaterialButton proceedButton;
+    private View signedInSection;
+    private TextInputEditText aggregatorEmailInput;
+    private TextInputLayout aggregatorEmailLayout;
+    private RadioGroup roleGroup;
+    private RadioButton roleSupervisor;
+    private RadioButton roleAggregator;
+    private TextView signedInAsText;
+    private View loadingProgress;
+
+    // Autocomplete functionality
+    private PopupWindow suggestionPopup;
+    private ListView suggestionListView;
+    private ArrayAdapter<String> emailAdapter;
+    private List<String> aggregatorEmails;
+    private Handler searchHandler;
+    private Runnable searchRunnable;
+    private boolean isSettingTextProgrammatically = false;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_login);
+
+        Log.d(TAG, "LoginActivity onCreate - Initializing components");
+        
+        initializeFirebase();
+        initializeCredentialManager();
+        initializeViews();
+        setupClickListeners();
+    }
+
+    private void initializeFirebase() {
+        Log.d(TAG, "Initializing Firebase Auth and Firestore");
+        mAuth = FirebaseAuth.getInstance();
+        db = FirebaseFirestore.getInstance();
+    }
+
+    private void initializeCredentialManager() {
+        try {
+            credentialManager = CredentialManager.create(this);
+            Log.d(TAG, "CredentialManager initialized successfully");
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to initialize CredentialManager", e);
+            showErrorToast("Error initializing authentication services");
+        }
+    }
+
+    private void initializeViews() {
+        Log.d(TAG, "Initializing UI components");
+        googleSignInButton = findViewById(R.id.google_sign_in_button);
+        signOutButton = findViewById(R.id.sign_out_button);
+        proceedButton = findViewById(R.id.proceed_button);
+        aggregatorEmailInput = findViewById(R.id.aggregator_email);
+        aggregatorEmailLayout = findViewById(R.id.aggregator_email_layout);
+        roleGroup = findViewById(R.id.role_group);
+        roleSupervisor = findViewById(R.id.role_supervisor);
+        roleAggregator = findViewById(R.id.role_aggregator);
+        signedInAsText = findViewById(R.id.signed_in_as_text);
+        signedInSection = findViewById(R.id.signed_in_section);
+        loadingProgress = findViewById(R.id.loading);
+
+        setupAutocomplete();
+    }
+
+    private void setupAutocomplete() {
+        Log.d(TAG, "Setting up email autocomplete functionality");
+        
+        // Initialize autocomplete components
+        aggregatorEmails = new ArrayList<>();
+        emailAdapter = new ArrayAdapter<>(this, R.layout.autocomplete_item, aggregatorEmails);
+        searchHandler = new Handler(Looper.getMainLooper());
+        
+        if (aggregatorEmailInput != null) {
+            createSuggestionPopup();
+            
+            // Add text change listener for real-time search
+            aggregatorEmailInput.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+                    // Skip search if we're setting text programmatically
+                    if (isSettingTextProgrammatically) {
+                        return;
+                    }
+                    
+                    // Cancel previous search
+                    if (searchRunnable != null) {
+                        searchHandler.removeCallbacks(searchRunnable);
+                    }
+                    
+                    // Schedule new search with delay to avoid too many requests
+                    if (s.length() > 1) {
+                        searchRunnable = () -> searchAggregatorUsers(s.toString());
+                        searchHandler.postDelayed(searchRunnable, 300); // 300ms delay
+                    } else {
+                        // Hide popup when input is too short
+                        hideSuggestionPopup();
+                    }
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {}
+            });
+            
+            // Hide popup when focus is lost
+            aggregatorEmailInput.setOnFocusChangeListener((v, hasFocus) -> {
+                if (!hasFocus) {
+                    hideSuggestionPopup();
+                }
+            });
+            
+            Log.d(TAG, "Autocomplete setup completed");
+        }
+    }
+
+    private void createSuggestionPopup() {
+        // Create ListView for suggestions
+        suggestionListView = new ListView(this);
+        suggestionListView.setAdapter(emailAdapter);
+        suggestionListView.setDividerHeight(1);
+        suggestionListView.setDivider(ContextCompat.getDrawable(this, android.R.color.transparent));
+        suggestionListView.setBackgroundColor(ContextCompat.getColor(this, android.R.color.white));
+        suggestionListView.setElevation(8f);
+        
+        // Handle item clicks
+        suggestionListView.setOnItemClickListener((parent, view, position, id) -> {
+            String selectedEmail = aggregatorEmails.get(position);
+            Log.d(TAG, "Selected aggregator email from suggestions: " + selectedEmail);
+            
+            // Set flag to prevent triggering search when setting text programmatically
+            isSettingTextProgrammatically = true;
+            aggregatorEmailInput.setText(selectedEmail);
+            aggregatorEmailInput.setSelection(selectedEmail.length());
+            isSettingTextProgrammatically = false;
+            
+            aggregatorEmailLayout.setError(null);
+            hideSuggestionPopup();
+        });
+        
+        // Create popup window
+        suggestionPopup = new PopupWindow(suggestionListView, 
+                ViewGroup.LayoutParams.MATCH_PARENT, 
+                ViewGroup.LayoutParams.WRAP_CONTENT);
+        suggestionPopup.setOutsideTouchable(true);
+        suggestionPopup.setFocusable(false);
+        suggestionPopup.setElevation(8f);
+        suggestionPopup.setBackgroundDrawable(ContextCompat.getDrawable(this, android.R.drawable.editbox_dropdown_light_frame));
+    }
+
+    private void setupClickListeners() {
+        Log.d(TAG, "Setting up click listeners");
+        googleSignInButton.setOnClickListener(v -> signInWithGoogle());
+        signOutButton.setOnClickListener(v -> signOut());
+        proceedButton.setOnClickListener(v -> onProceed());
+        
+        // Setup role selection listener
+        // Note: Supervisor no longer needs to enter aggregator email - sensors are pre-assigned in Firestore
+        if (roleGroup != null) {
+            roleGroup.setOnCheckedChangeListener((group, checkedId) -> {
+                if (checkedId == R.id.role_supervisor) {
+                    Log.d(TAG, "Supervisor role selected - no email input needed (sensors pre-assigned)");
+                    aggregatorEmailLayout.setVisibility(View.GONE);
+                    aggregatorEmailLayout.setError(null);
+                } else if (checkedId == R.id.role_aggregator) {
+                    Log.d(TAG, "Aggregator role selected - hiding email input");
+                    aggregatorEmailLayout.setVisibility(View.GONE);
+                    aggregatorEmailLayout.setError(null);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        Log.d(TAG, "onStart - Checking current user authentication state");
+        
+        FirebaseUser currentUser = mAuth.getCurrentUser();
+        if (currentUser != null) {
+            Log.d(TAG, "User already authenticated: " + currentUser.getEmail());
+            
+            // Check for user switch and clear local data if needed
+            android.content.SharedPreferences prefs = getSharedPreferences("app_prefs", MODE_PRIVATE);
+            String lastUid = prefs.getString("last_logged_in_uid", null);
+            
+            if (lastUid != null && !lastUid.equals(currentUser.getUid())) {
+                // User switch detected - must clear local data BEFORE proceeding
+                // to prevent race conditions between clear and backfill
+                Log.i(TAG, "User switched from " + lastUid + " to " + currentUser.getUid() + " - clearing local DB");
+                showLoading("Switching accounts...");
+                
+                FirestoreSyncService.getInstance(this).clearLocalData(() -> {
+                    // Callback runs on main thread after clear completes
+                    Log.i(TAG, "Local DB cleared, now proceeding with new user");
+                    prefs.edit().putString("last_logged_in_uid", currentUser.getUid()).apply();
+                    checkUserInFirestore(currentUser);
+                });
+            } else {
+                // No user switch - proceed immediately
+                prefs.edit().putString("last_logged_in_uid", currentUser.getUid()).apply();
+                checkUserInFirestore(currentUser);
+            }
+        } else {
+            Log.d(TAG, "No authenticated user found");
+            showSignInUI();
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        Log.d(TAG, "onDestroy - Cleaning up resources");
+        
+        // Clean up search handler
+        if (searchHandler != null && searchRunnable != null) {
+            searchHandler.removeCallbacks(searchRunnable);
+        }
+        
+        // Clean up popup
+        hideSuggestionPopup();
+    }
+
+    private void signInWithGoogle() {
+        Log.d(TAG, "Starting Google Sign-In process");
+        showLoading("Signing in...");
+
+        if (credentialManager == null) {
+            Log.e(TAG, "CredentialManager is null");
+            showErrorToast("Authentication service not available");
+            hideLoading();
+            return;
+        }
+
+        String webClientId = getString(R.string.default_web_client_id);
+        if (webClientId.startsWith("YOUR_")) {
+            Log.e(TAG, "Web Client ID not configured");
+            showErrorToast("Please configure your Web Client ID in strings.xml");
+            hideLoading();
+            return;
+        }
+
+        GetGoogleIdOption googleIdOption = new GetGoogleIdOption.Builder()
+                .setFilterByAuthorizedAccounts(false)
+                .setServerClientId(webClientId)
+                .build();
+
+        GetCredentialRequest request = new GetCredentialRequest.Builder()
+                .addCredentialOption(googleIdOption)
+                .build();
+
+        credentialManager.getCredentialAsync(
+                this,
+                request,
+                new CancellationSignal(),
+                Executors.newSingleThreadExecutor(),
+                new CredentialManagerCallback<GetCredentialResponse, GetCredentialException>() {
+                    @Override
+                    public void onResult(GetCredentialResponse result) {
+                        Log.d(TAG, "Credential request successful");
+                        handleSignInResult(result.getCredential());
+                    }
+
+                    @Override
+                    public void onError(GetCredentialException e) {
+                        Log.e(TAG, "Sign-in failed: " + e.getLocalizedMessage(), e);
+                        runOnUiThread(() -> {
+                            hideLoading();
+                            String errorMsg = e.getLocalizedMessage();
+                            if (errorMsg != null && errorMsg.contains("Unknown calling package")) {
+                                showErrorToast("Google Play Services issue detected");
+                            } else {
+                                showErrorToast("Sign-in failed: " + errorMsg);
+                            }
+                        });
+                    }
+                }
+        );
+    }
+
+    private void handleSignInResult(Credential credential) {
+        if (credential instanceof CustomCredential
+                && GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL.equals(credential.getType())) {
+            
+            try {
+                GoogleIdTokenCredential googleCredential = GoogleIdTokenCredential.createFrom(
+                        ((CustomCredential) credential).getData());
+                authenticateWithFirebase(googleCredential.getIdToken());
+            } catch (Exception e) {
+                Log.e(TAG, "Invalid Google ID token", e);
+                runOnUiThread(() -> {
+                        hideLoading();
+                    showErrorToast("Invalid Google ID token");
+                });
+            }
+        } else {
+            Log.w(TAG, "Invalid credential type");
+            runOnUiThread(() -> {
+                    hideLoading();
+                showErrorToast("Invalid credential type");
+            });
+        }
+    }
+
+    private void authenticateWithFirebase(String idToken) {
+        Log.d(TAG, "Authenticating with Firebase using Google token");
+        AuthCredential credential = GoogleAuthProvider.getCredential(idToken, null);
+        
+        mAuth.signInWithCredential(credential)
+                .addOnCompleteListener(this, task -> {
+                    if (task.isSuccessful()) {
+                        Log.d(TAG, "Firebase authentication successful");
+                        FirebaseUser user = mAuth.getCurrentUser();
+                        if (user != null) {
+                            showSuccessToast("Welcome " + user.getDisplayName() + "!");
+                            checkUserInFirestore(user);
+                        }
+                    } else {
+                        Log.w(TAG, "Firebase authentication failed", task.getException());
+                        hideLoading();
+                        showErrorToast("Authentication failed");
+                    }
+                });
+    }
+
+    private void checkUserInFirestore(FirebaseUser user) {
+        Log.d(TAG, "Checking user data in Firestore for UID: " + user.getUid());
+        showLoading("Loading profile...");
+        
+        DocumentReference userRef = db.collection("users").document(user.getUid());
+        userRef.get()
+                .addOnSuccessListener(document -> {
+                    if (document.exists()) {
+                        String role = document.getString("role");
+                        Log.d(TAG, "User found with role: " + (role != null ? role : "none"));
+                        // Always show role selection UI for online-only flow with pre-filling
+                        showRoleSelectionUI(user);
+                } else {
+                        Log.d(TAG, "User not found in Firestore - creating profile");
+                        createUserProfile(user);
+                }
+                })
+                .addOnFailureListener(e -> {
+            Log.e(TAG, "Error checking user in Firestore", e);
+                    handleFirestoreError(e);
+                });
+    }
+
+    private void fetchAndPreFillUserPreferences(FirebaseUser user) {
+        Log.d(TAG, "Fetching user preferences from server for UID: " + user.getUid());
+        showLoading(getString(R.string.loading_preferences));
+        
+        DocumentReference userRef = db.collection("users").document(user.getUid());
+        userRef.get()
+                .addOnSuccessListener(document -> {
+                    if (document.exists()) {
+                        String role = document.getString("role");
+                        String aggregatorEmail = document.getString("aggregatorEmail");
+                        String lastSelectedRole = document.getString("lastSelectedRole");
+                        
+                        Log.d(TAG, "Retrieved preferences - role: " + role + 
+                               ", aggregatorEmail: " + aggregatorEmail + 
+                               ", lastSelectedRole: " + lastSelectedRole);
+                        
+                        runOnUiThread(() -> {
+                            hideLoading();
+                            
+                            // Pre-fill based on user type
+                            // Note: Supervisors no longer need email input - sensors are pre-assigned in Firestore
+                            if ("supervisor".equals(role)) {
+                                roleSupervisor.setChecked(true);
+                                aggregatorEmailLayout.setVisibility(View.GONE);
+                                Log.d(TAG, "Pre-filled supervisor role (sensors pre-assigned in Firestore)");
+                            } else if ("aggregator".equals(role)) {
+                                // Pre-fill role selection for aggregator accounts
+                                roleAggregator.setChecked(true);
+                                aggregatorEmailLayout.setVisibility(View.GONE);
+                                Log.d(TAG, "Pre-filled aggregator role selection");
+                            } else if (lastSelectedRole != null) {
+                                // Pre-fill last selected role for users without a set role
+                                if ("supervisor".equals(lastSelectedRole)) {
+                                    roleSupervisor.setChecked(true);
+                                    aggregatorEmailLayout.setVisibility(View.GONE);
+                                } else {
+                                    roleAggregator.setChecked(true);
+                                    aggregatorEmailLayout.setVisibility(View.GONE);
+                                }
+                                Log.d(TAG, "Pre-filled last selected role: " + lastSelectedRole);
+                            } else {
+                                // Default to aggregator if no preferences found
+                                roleAggregator.setChecked(true);
+                                aggregatorEmailLayout.setVisibility(View.GONE);
+                                Log.d(TAG, "No preferences found, defaulting to aggregator role");
+                            }
+                        });
+                    } else {
+                        Log.d(TAG, "No user document found, using defaults");
+                        runOnUiThread(() -> {
+                            hideLoading();
+                            roleAggregator.setChecked(true);
+                            aggregatorEmailLayout.setVisibility(View.GONE);
+                        });
+                    }
+                })
+                .addOnFailureListener(e -> {
+                    Log.w(TAG, "Error fetching user preferences: " + e.getMessage(), e);
+                    runOnUiThread(() -> {
+                        hideLoading();
+                        // Continue with defaults if fetch fails
+                        roleAggregator.setChecked(true);
+                        aggregatorEmailLayout.setVisibility(View.GONE);
+                        showErrorToast(getString(R.string.preferences_load_failed));
+                    });
+                });
+    }
+
+    private void preFillAggregatorEmail(String email) {
+        if (aggregatorEmailInput != null && email != null && !email.isEmpty()) {
+            // Set flag to prevent triggering search when setting text programmatically
+            isSettingTextProgrammatically = true;
+            aggregatorEmailInput.setText(email);
+            aggregatorEmailInput.setSelection(email.length());
+            isSettingTextProgrammatically = false;
+            aggregatorEmailLayout.setError(null);
+            Log.d(TAG, "Pre-filled aggregator email field with: " + email);
+        }
+    }
+
+    private void createUserProfile(FirebaseUser user) {
+        Log.d(TAG, "Creating user profile for: " + user.getEmail());
+        
+        Map<String, Object> userData = new HashMap<>();
+        userData.put("uid", user.getUid());
+        userData.put("displayName", user.getDisplayName());
+        userData.put("email", user.getEmail());
+        userData.put("photoUrl", user.getPhotoUrl() != null ? user.getPhotoUrl().toString() : null);
+        userData.put("createdAt", System.currentTimeMillis());
+        userData.put("lastSignIn", System.currentTimeMillis());
+
+        db.collection("users").document(user.getUid())
+                .set(userData)
+                .addOnSuccessListener(aVoid -> {
+                    Log.d(TAG, "User profile created successfully");
+                    showRoleSelectionUI(user);
+                })
+                .addOnFailureListener(e -> {
+                    Log.e(TAG, "Failed to create user profile", e);
+                    handleFirestoreError(e);
+                });
+    }
+
+    private void showRoleSelectionUI(FirebaseUser user) {
+        Log.d(TAG, "Showing role selection UI for: " + user.getEmail());
+        runOnUiThread(() -> {
+            googleSignInButton.setVisibility(View.GONE);
+            signedInSection.setVisibility(View.VISIBLE);
+            signOutButton.setVisibility(View.VISIBLE);
+            
+            signedInAsText.setText("Welcome " + user.getDisplayName() + "!\nPlease select your role:");
+        });
+        
+        // Fetch and pre-fill user preferences from server
+        fetchAndPreFillUserPreferences(user);
+    }
+
+    private void showSignInUI() {
+        Log.d(TAG, "Showing sign-in UI");
+        googleSignInButton.setVisibility(View.VISIBLE);
+        signedInSection.setVisibility(View.GONE);
+        signOutButton.setVisibility(View.GONE);
+        hideLoading();
+    }
+
+    private void onProceed() {
+        Log.d(TAG, "Proceed button clicked");
+        
+        FirebaseUser currentUser = mAuth.getCurrentUser();
+        if (currentUser == null) {
+            Log.w(TAG, "No authenticated user found during proceed");
+            showErrorToast("Authentication required");
+            return;
+        }
+
+        int selectedId = roleGroup.getCheckedRadioButtonId();
+        if (selectedId == -1) {
+            showErrorToast("Please select a role");
+            return;
+        }
+
+        showLoading("Saving your role...");
+        proceedButton.setEnabled(false);
+        signOutButton.setEnabled(false);
+
+        String role = (selectedId == R.id.role_supervisor) ? "supervisor" : "aggregator";
+        
+        // Supervisor no longer requires email input - sensors are pre-assigned in Firestore by aggregator
+        // Just save the role and proceed
+        saveUserRole(currentUser, role, null);
+    }
+
+    private void saveUserRole(FirebaseUser user, String role, String aggregatorEmail) {
+        Log.d(TAG, "Saving role '" + role + "' for user: " + user.getUid() + 
+               (aggregatorEmail != null ? ", aggregator email: " + aggregatorEmail : ""));
+
+        Map<String, Object> updates = new HashMap<>();
+        updates.put("role", role);
+        updates.put("lastSelectedRole", role); // Save for future pre-filling
+        updates.put("lastSignIn", System.currentTimeMillis());
+        if (aggregatorEmail != null && !aggregatorEmail.isEmpty()) {
+            updates.put("aggregatorEmail", aggregatorEmail);
+        }
+
+        db.collection("users").document(user.getUid())
+                .update(updates)
+                .addOnSuccessListener(aVoid -> {
+                    Log.d(TAG, "âœ… User role and preferences saved to Firestore");
+                    
+                    // Show loading while we reload session
+                    showLoading("Loading your account...");
+                    
+                    // NOW reload session and trigger bootstrap with confirmed role
+                    SessionGate.getInstance(this).reloadSessionAndBootstrap(
+                        new SessionGate.SessionReadyCallback() {
+                            @Override
+                            public void onSessionReady(String userId, String confirmedRole, List<String> supervisedUserIds) {
+                                Log.i(TAG, "âœ… Session ready with confirmed role: " + confirmedRole);
+                                runOnUiThread(() -> {
+                                    hideLoading();
+                                    showSuccessToast("Role set successfully!");
+                                    navigateToMainActivity();
+                                });
+                            }
+                            
+                            @Override
+                            public void onSessionError(String error) {
+                                Log.e(TAG, "âš ï¸ Session reload failed: " + error);
+                                runOnUiThread(() -> {
+                                    hideLoading();
+                                    showErrorToast("Session error: " + error);
+                                    // Proceed anyway - user can try again
+                                    navigateToMainActivity();
+                                });
+                            }
+                        }
+                    );
+                })
+                .addOnFailureListener(e -> {
+                    Log.e(TAG, "Failed to save user role", e);
+                    runOnUiThread(() -> {
+                        hideLoading();
+                        proceedButton.setEnabled(true);
+                        signOutButton.setEnabled(true);
+                        handleFirestoreError(e);
+                    });
+                });
+    }
+
+    private void signOut() {
+        Log.d(TAG, "Starting sign-out process");
+        showLoading("Signing out...");
+        
+        mAuth.signOut();
+
+        ClearCredentialStateRequest clearRequest = new ClearCredentialStateRequest();
+        credentialManager.clearCredentialStateAsync(
+                clearRequest,
+                new CancellationSignal(),
+                Executors.newSingleThreadExecutor(),
+                new CredentialManagerCallback<Void, ClearCredentialException>() {
+                    @Override
+                    public void onResult(@NonNull Void result) {
+                        Log.d(TAG, "Credentials cleared successfully");
+                        runOnUiThread(() -> {
+                            showSignInUI();
+                            showSuccessToast("Signed out successfully");
+                        });
+                    }
+
+                    @Override
+                    public void onError(@NonNull ClearCredentialException e) {
+                        Log.w(TAG, "Error clearing credentials: " + e.getLocalizedMessage());
+                        runOnUiThread(() -> {
+                            showSignInUI();
+                            showSuccessToast("Sign-out completed");
+                        });
+                    }
+                });
+    }
+
+    private void navigateToMainActivity() {
+        Log.d(TAG, "Navigating to MainActivity");
+        Intent intent = new Intent(this, MainActivity.class);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+        startActivity(intent);
+        finish();
+    }
+
+    private void handleFirestoreError(Exception e) {
+        String errorMessage = e.getMessage() != null ? e.getMessage() : "Unknown error";
+        
+        if (errorMessage.contains("PERMISSION_DENIED")) {
+            Log.w(TAG, "Permission denied - signing out user");
+            showErrorToast("Permission denied. Please sign in again.");
+            signOut();
+        } else {
+            Log.e(TAG, "Firestore error: " + errorMessage);
+            showErrorToast("Database error: " + errorMessage);
+        }
+    }
+
+    private void searchAggregatorUsers(String query) {
+        if (query.trim().isEmpty() || query.length() < 2) {
+            return;
+        }
+
+        Log.d(TAG, "Searching for aggregator users matching: '" + query + "'");
+        
+        // Search for users with role 'aggregator' and email containing the query
+        db.collection("users")
+                .whereEqualTo("role", "aggregator")
+                .get()
+                .addOnSuccessListener(queryDocumentSnapshots -> {
+                    List<String> matchingEmails = new ArrayList<>();
+                    String lowerQuery = query.toLowerCase();
+                    
+                    queryDocumentSnapshots.forEach(document -> {
+                        String email = document.getString("email");
+                        if (email != null && email.toLowerCase().contains(lowerQuery)) {
+                            matchingEmails.add(email);
+                            Log.d(TAG, "Found matching aggregator user: " + email);
+                        }
+                    });
+                    
+                    Log.d(TAG, "Search completed: " + matchingEmails.size() + " aggregator users found matching '" + query + "'");
+                    
+                    runOnUiThread(() -> {
+                        aggregatorEmails.clear();
+                        aggregatorEmails.addAll(matchingEmails);
+                        emailAdapter.notifyDataSetChanged();
+                        
+                        if (!matchingEmails.isEmpty() && aggregatorEmailInput.hasFocus()) {
+                            Log.d(TAG, "Showing popup with " + matchingEmails.size() + " suggestions");
+                            showSuggestionPopup();
+                        } else if (matchingEmails.isEmpty()) {
+                            Log.d(TAG, "No aggregator users found matching '" + query + "' - user can enter manually");
+                            hideSuggestionPopup();
+                        }
+                    });
+                })
+                .addOnFailureListener(e -> {
+                    Log.w(TAG, "Error searching aggregator users: " + e.getMessage(), e);
+                    // Don't show error to user, just continue with manual entry
+                    // This allows the flow to continue even if database is unavailable
+                });
+    }
+
+    private void showSuggestionPopup() {
+        if (suggestionPopup != null && !suggestionPopup.isShowing() && aggregatorEmailInput != null) {
+            try {
+                // Calculate popup width to match the TextInputLayout
+                int width = aggregatorEmailLayout != null ? aggregatorEmailLayout.getWidth() : aggregatorEmailInput.getWidth();
+                suggestionPopup.setWidth(width);
+                
+                // Show popup below the input field
+                suggestionPopup.showAsDropDown(aggregatorEmailInput, 0, 0);
+                Log.d(TAG, "Suggestion popup shown with " + aggregatorEmails.size() + " items");
+            } catch (Exception e) {
+                Log.w(TAG, "Error showing suggestion popup", e);
+            }
+        }
+    }
+
+    private void hideSuggestionPopup() {
+        if (suggestionPopup != null && suggestionPopup.isShowing()) {
+            try {
+                suggestionPopup.dismiss();
+                Log.d(TAG, "Suggestion popup hidden");
+            } catch (Exception e) {
+                Log.w(TAG, "Error hiding suggestion popup", e);
+            }
+        }
+    }
+
+    private boolean isValidGmail(String email) {
+        return email.matches("^[A-Za-z0-9+_.-]+@gmail\\.com$");
+    }
+
+    private void showLoading(String message) {
+        Log.d(TAG, "Showing loading: " + message);
+        runOnUiThread(() -> {
+            loadingProgress.setVisibility(View.VISIBLE);
+        googleSignInButton.setEnabled(false);
+            if (proceedButton != null) {
+                proceedButton.setEnabled(false);
+            }
+            if (signOutButton != null) {
+                signOutButton.setEnabled(false);
+            }
+        });
+    }
+
+    private void hideLoading() {
+        Log.d(TAG, "Hiding loading");
+        runOnUiThread(() -> {
+            loadingProgress.setVisibility(View.GONE);
+        googleSignInButton.setEnabled(true);
+            if (proceedButton != null) {
+                proceedButton.setEnabled(true);
+            }
+            if (signOutButton != null) {
+                signOutButton.setEnabled(true);
+            }
+        });
+    }
+
+    private void showSuccessToast(String message) {
+        Log.i(TAG, "Success: " + message);
+        runOnUiThread(() -> Toast.makeText(this, message, Toast.LENGTH_SHORT).show());
+    }
+
+    private void showErrorToast(String message) {
+        Log.e(TAG, "Error: " + message);
+        runOnUiThread(() -> Toast.makeText(this, message, Toast.LENGTH_LONG).show());
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginFormState.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginFormState.java
index 34ff72a..a57c6ea 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginFormState.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginFormState.java
@@ -1,40 +1,40 @@
-package com.melisa.innovamotionapp._login.login;
-
-import androidx.annotation.Nullable;
-
-/**
- * Data validation state of the login form.
- */
-class LoginFormState {
-    @Nullable
-    private Integer usernameError;
-    @Nullable
-    private Integer passwordError;
-    private boolean isDataValid;
-
-    LoginFormState(@Nullable Integer usernameError, @Nullable Integer passwordError) {
-        this.usernameError = usernameError;
-        this.passwordError = passwordError;
-        this.isDataValid = false;
-    }
-
-    LoginFormState(boolean isDataValid) {
-        this.usernameError = null;
-        this.passwordError = null;
-        this.isDataValid = isDataValid;
-    }
-
-    @Nullable
-    Integer getUsernameError() {
-        return usernameError;
-    }
-
-    @Nullable
-    Integer getPasswordError() {
-        return passwordError;
-    }
-
-    boolean isDataValid() {
-        return isDataValid;
-    }
+package com.melisa.innovamotionapp._login.login;
+
+import androidx.annotation.Nullable;
+
+/**
+ * Data validation state of the login form.
+ */
+class LoginFormState {
+    @Nullable
+    private Integer usernameError;
+    @Nullable
+    private Integer passwordError;
+    private boolean isDataValid;
+
+    LoginFormState(@Nullable Integer usernameError, @Nullable Integer passwordError) {
+        this.usernameError = usernameError;
+        this.passwordError = passwordError;
+        this.isDataValid = false;
+    }
+
+    LoginFormState(boolean isDataValid) {
+        this.usernameError = null;
+        this.passwordError = null;
+        this.isDataValid = isDataValid;
+    }
+
+    @Nullable
+    Integer getUsernameError() {
+        return usernameError;
+    }
+
+    @Nullable
+    Integer getPasswordError() {
+        return passwordError;
+    }
+
+    boolean isDataValid() {
+        return isDataValid;
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginResult.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginResult.java
index b408402..dd46cd8 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginResult.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginResult.java
@@ -1,31 +1,31 @@
-package com.melisa.innovamotionapp._login.login;
-
-import androidx.annotation.Nullable;
-
-/**
- * Authentication result : success (user details) or error message.
- */
-class LoginResult {
-    @Nullable
-    private LoggedInUserView success;
-    @Nullable
-    private Integer error;
-
-    LoginResult(@Nullable Integer error) {
-        this.error = error;
-    }
-
-    LoginResult(@Nullable LoggedInUserView success) {
-        this.success = success;
-    }
-
-    @Nullable
-    LoggedInUserView getSuccess() {
-        return success;
-    }
-
-    @Nullable
-    Integer getError() {
-        return error;
-    }
+package com.melisa.innovamotionapp._login.login;
+
+import androidx.annotation.Nullable;
+
+/**
+ * Authentication result : success (user details) or error message.
+ */
+class LoginResult {
+    @Nullable
+    private LoggedInUserView success;
+    @Nullable
+    private Integer error;
+
+    LoginResult(@Nullable Integer error) {
+        this.error = error;
+    }
+
+    LoginResult(@Nullable LoggedInUserView success) {
+        this.success = success;
+    }
+
+    @Nullable
+    LoggedInUserView getSuccess() {
+        return success;
+    }
+
+    @Nullable
+    Integer getError() {
+        return error;
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModel.java
index 60184af..6287258 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModel.java
@@ -1,70 +1,70 @@
-package com.melisa.innovamotionapp._login.login;
-
-import android.util.Patterns;
-
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.ViewModel;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp._login.data.LoginRepository;
-import com.melisa.innovamotionapp._login.data.Result;
-import com.melisa.innovamotionapp._login.data.model.LoggedInUser;
-
-public class LoginViewModel extends ViewModel {
-
-    private MutableLiveData<LoginFormState> loginFormState = new MutableLiveData<>();
-    private MutableLiveData<LoginResult> loginResult = new MutableLiveData<>();
-    private LoginRepository loginRepository;
-
-    LoginViewModel(LoginRepository loginRepository) {
-        this.loginRepository = loginRepository;
-    }
-
-    LiveData<LoginFormState> getLoginFormState() {
-        return loginFormState;
-    }
-
-    LiveData<LoginResult> getLoginResult() {
-        return loginResult;
-    }
-
-    public void login(String username, String password) {
-        // can be launched in a separate asynchronous job
-        Result<LoggedInUser> result = loginRepository.login(username, password);
-
-        if (result instanceof Result.Success) {
-            LoggedInUser data = ((Result.Success<LoggedInUser>) result).getData();
-            loginResult.setValue(new LoginResult(new LoggedInUserView(data.getDisplayName())));
-        } else {
-            loginResult.setValue(new LoginResult(R.string.login_failed));
-        }
-    }
-
-    public void loginDataChanged(String username, String password) {
-        if (!isUserNameValid(username)) {
-            loginFormState.setValue(new LoginFormState(R.string.invalid_username, null));
-        } else if (!isPasswordValid(password)) {
-            loginFormState.setValue(new LoginFormState(null, R.string.invalid_password));
-        } else {
-            loginFormState.setValue(new LoginFormState(true));
-        }
-    }
-
-    // A placeholder username validation check
-    private boolean isUserNameValid(String username) {
-        if (username == null) {
-            return false;
-        }
-        if (username.contains("@")) {
-            return Patterns.EMAIL_ADDRESS.matcher(username).matches();
-        } else {
-            return !username.trim().isEmpty();
-        }
-    }
-
-    // A placeholder password validation check
-    private boolean isPasswordValid(String password) {
-        return password != null && password.trim().length() > 5;
-    }
+package com.melisa.innovamotionapp._login.login;
+
+import android.util.Patterns;
+
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.ViewModel;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp._login.data.LoginRepository;
+import com.melisa.innovamotionapp._login.data.Result;
+import com.melisa.innovamotionapp._login.data.model.LoggedInUser;
+
+public class LoginViewModel extends ViewModel {
+
+    private MutableLiveData<LoginFormState> loginFormState = new MutableLiveData<>();
+    private MutableLiveData<LoginResult> loginResult = new MutableLiveData<>();
+    private LoginRepository loginRepository;
+
+    LoginViewModel(LoginRepository loginRepository) {
+        this.loginRepository = loginRepository;
+    }
+
+    LiveData<LoginFormState> getLoginFormState() {
+        return loginFormState;
+    }
+
+    LiveData<LoginResult> getLoginResult() {
+        return loginResult;
+    }
+
+    public void login(String username, String password) {
+        // can be launched in a separate asynchronous job
+        Result<LoggedInUser> result = loginRepository.login(username, password);
+
+        if (result instanceof Result.Success) {
+            LoggedInUser data = ((Result.Success<LoggedInUser>) result).getData();
+            loginResult.setValue(new LoginResult(new LoggedInUserView(data.getDisplayName())));
+        } else {
+            loginResult.setValue(new LoginResult(R.string.login_failed));
+        }
+    }
+
+    public void loginDataChanged(String username, String password) {
+        if (!isUserNameValid(username)) {
+            loginFormState.setValue(new LoginFormState(R.string.invalid_username, null));
+        } else if (!isPasswordValid(password)) {
+            loginFormState.setValue(new LoginFormState(null, R.string.invalid_password));
+        } else {
+            loginFormState.setValue(new LoginFormState(true));
+        }
+    }
+
+    // A placeholder username validation check
+    private boolean isUserNameValid(String username) {
+        if (username == null) {
+            return false;
+        }
+        if (username.contains("@")) {
+            return Patterns.EMAIL_ADDRESS.matcher(username).matches();
+        } else {
+            return !username.trim().isEmpty();
+        }
+    }
+
+    // A placeholder password validation check
+    private boolean isPasswordValid(String password) {
+        return password != null && password.trim().length() > 5;
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModelFactory.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModelFactory.java
index 07bdc2d..e09d8dd 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModelFactory.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/_login/login/LoginViewModelFactory.java
@@ -1,26 +1,26 @@
-package com.melisa.innovamotionapp._login.login;
-
-import androidx.lifecycle.ViewModel;
-import androidx.lifecycle.ViewModelProvider;
-import androidx.annotation.NonNull;
-
-import com.melisa.innovamotionapp._login.data.LoginDataSource;
-import com.melisa.innovamotionapp._login.data.LoginRepository;
-
-/**
- * ViewModel provider factory to instantiate LoginViewModel.
- * Required given LoginViewModel has a non-empty constructor
- */
-public class LoginViewModelFactory implements ViewModelProvider.Factory {
-
-    @NonNull
-    @Override
-    @SuppressWarnings("unchecked")
-    public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
-        if (modelClass.isAssignableFrom(LoginViewModel.class)) {
-            return (T) new LoginViewModel(LoginRepository.getInstance(new LoginDataSource()));
-        } else {
-            throw new IllegalArgumentException("Unknown ViewModel class");
-        }
-    }
+package com.melisa.innovamotionapp._login.login;
+
+import androidx.lifecycle.ViewModel;
+import androidx.lifecycle.ViewModelProvider;
+import androidx.annotation.NonNull;
+
+import com.melisa.innovamotionapp._login.data.LoginDataSource;
+import com.melisa.innovamotionapp._login.data.LoginRepository;
+
+/**
+ * ViewModel provider factory to instantiate LoginViewModel.
+ * Required given LoginViewModel has a non-empty constructor
+ */
+public class LoginViewModelFactory implements ViewModelProvider.Factory {
+
+    @NonNull
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
+        if (modelClass.isAssignableFrom(LoginViewModel.class)) {
+            return (T) new LoginViewModel(LoginRepository.getInstance(new LoginDataSource()));
+        } else {
+            throw new IllegalArgumentException("Unknown ViewModel class");
+        }
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/AggregatorDashboardActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/AggregatorDashboardActivity.java
index 894921e..a20c744 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/AggregatorDashboardActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/AggregatorDashboardActivity.java
@@ -34,6 +34,8 @@ public class AggregatorDashboardActivity extends BaseActivity {
         binding = ActivityAggregatorDashboardBinding.inflate(getLayoutInflater());
         setContentView(binding.getRoot());
         
+        setSupportActionBar(binding.toolbar);
+        
         setupViewPager();
         setupTabLayout();
         
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java
index 0540217..20ca560 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java
@@ -1,188 +1,188 @@
-package com.melisa.innovamotionapp.activities;
-
-import static android.content.ContentValues.TAG;
-
-import android.bluetooth.BluetoothAdapter;
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.Toast;
-
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.lifecycle.ViewModelProvider;
-
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
-import com.melisa.innovamotionapp.data.posture.Posture;
-import com.melisa.innovamotionapp.data.posture.PostureFactory;
-import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
-import com.melisa.innovamotionapp.data.posture.types.UnusedFootwearPosture;
-import com.melisa.innovamotionapp.databinding.BtConnectedActivityBinding;
-import com.melisa.innovamotionapp.ui.viewmodels.SupervisorFeedViewModel;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.RoleProvider;
-
-
-/**
- * Activity for displaying posture data for a single person.
- * 
- * Supports two modes:
- * 1. Legacy mode: Shows data from GlobalData (Bluetooth connection)
- * 2. Sensor-specific mode: Shows data for a specific sensorId (Supervisor viewing from dashboard)
- */
-public class BtConnectedActivity extends AppCompatActivity {
-    
-    // Intent extras for sensor-specific viewing
-    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
-    public static final String EXTRA_PERSON_NAME = "extra_person_name";
-    
-    private static final int REQUEST_ENABLE_BT = 1;
-    private BluetoothAdapter mBluetoothAdapter;
-    private BtConnectedActivityBinding binding;
-    private final GlobalData globalData = GlobalData.getInstance();
-    private SupervisorFeedViewModel supervisorFeedViewModel;
-    private boolean isFirstPosture = true;
-    private Posture currentPosture = null;
-    
-    // Sensor-specific fields
-    private String sensorId;
-    private String personName;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        binding = BtConnectedActivityBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-
-        // Extract intent extras
-        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
-        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
-        
-        // Set initial title/name
-        if (personName != null && !personName.isEmpty()) {
-            // Supervisor viewing specific person - show their name
-            binding.descriptionTextView.setText(personName);
-        } else {
-            // Legacy behavior - use global userName
-            binding.descriptionTextView.setText(globalData.userName);
-        }
-
-        // Choose observation mode based on whether sensorId is provided
-        if (sensorId != null && !sensorId.isEmpty() && RoleProvider.isSupervisor()) {
-            // Supervisor viewing a specific person from dashboard
-            Log.d(TAG, "Supervisor viewing specific person: sensorId=" + sensorId + ", name=" + personName);
-            observeSensorSpecificData();
-        } else {
-            // Legacy behavior: GlobalData observer for Bluetooth connection
-            observeGlobalData();
-        }
-
-        // Modified connection observer: supervisors don't need to exit on disconnect
-        GlobalData.getInstance().getIsConnectedDevice().observe(this, isConnected -> {
-            if (!isConnected && RoleProvider.getCurrentRole() != RoleProvider.Role.SUPERVISOR) {
-                // Exit this activity only for supervised users when device connection is terminated
-                // Supervisors stay in the activity to continue monitoring Room data
-                finish();
-            }
-        });
-    }
-
-    /**
-     * Observe sensor-specific data from Room database.
-     * Used when supervisor views a specific person from the dashboard.
-     */
-    private void observeSensorSpecificData() {
-        ReceivedBtDataDao dao = InnovaDatabase.getInstance(this).receivedBtDataDao();
-        dao.getLatestForSensor(sensorId).observe(this, entity -> {
-            if (entity != null) {
-                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
-                Log.d(TAG, "Sensor-specific: received posture for " + sensorId);
-                displayPostureData(posture);
-            }
-        });
-    }
-
-    /**
-     * Observe global data from GlobalData and SupervisorFeedViewModel.
-     * Legacy behavior for Bluetooth connection mode.
-     */
-    private void observeGlobalData() {
-        // Existing observer stays: observe LiveData for device data
-        globalData.getReceivedPosture().observe(this, posture -> {
-            if (posture == null) return; // wait for real data
-            displayPostureData(posture);
-        });
-
-        // New: if supervisor, observe latest message from Room so we always show the freshest posture
-        if (RoleProvider.getCurrentRole() == RoleProvider.Role.SUPERVISOR) {
-            Log.d(TAG, "Supervisor detected: setting up Room-based posture feed");
-            supervisorFeedViewModel = new ViewModelProvider(this).get(SupervisorFeedViewModel.class);
-            supervisorFeedViewModel.getLatestPosture().observe(this, posture -> {
-                if (posture != null) {
-                    Log.d(TAG, "Supervisor: received latest posture from Room");
-                    displayPostureData(posture);
-                }
-            });
-        }
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        if (currentPosture != null) {
-            displayPostureData(currentPosture);
-        }
-    }
-
-    public void displayPostureData(Posture livePosture) {
-        if (livePosture == null) return; // extra guard
-
-        Posture postureToDisplay = livePosture;
-        if (isFirstPosture && postureToDisplay instanceof UnknownPosture) {
-            postureToDisplay = new UnusedFootwearPosture();
-        } else if (!(livePosture instanceof UnknownPosture)) {
-            isFirstPosture = false;
-        }
-
-        currentPosture = postureToDisplay;
-
-        // Use personName if available, otherwise fall back to globalData.userName
-        String displayName = (personName != null && !personName.isEmpty()) 
-                ? personName 
-                : globalData.userName;
-        String postureMessageWithName = getString(postureToDisplay.getTextCode(), displayName);
-        binding.descriptionTextView.setText(postureMessageWithName);
-
-        binding.riskValueTextView.setText(getString(postureToDisplay.getRisc()));
-
-        if (postureToDisplay instanceof UnknownPosture) {
-            // The posture is an instance of UnknownPosture
-            binding.videoView.stopPlayback(); // Stop any ongoing playback
-            binding.videoView.setVideoURI(null); // Clear the video content
-        } else {
-            // Handle other cases
-            String videoPath = "android.resource://" + getPackageName() + "/" + postureToDisplay.getVideoCode();
-            binding.videoView.setVideoPath(videoPath);
-            binding.videoView.start(); // Start playing the video
-        }
-    }
-
-    /**
-     * Get the current sensorId (for passing to child activities).
-     */
-    public String getSensorId() {
-        return sensorId;
-    }
-
-    /**
-     * Get the current personName (for passing to child activities).
-     */
-    public String getPersonName() {
-        return personName;
-    }
-
-    public void log(String msg) {
-        Log.d(TAG, msg);
-        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
-    }
-
-}
+package com.melisa.innovamotionapp.activities;
+
+import static android.content.ContentValues.TAG;
+
+import android.bluetooth.BluetoothAdapter;
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.Toast;
+
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.lifecycle.ViewModelProvider;
+
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
+import com.melisa.innovamotionapp.data.posture.Posture;
+import com.melisa.innovamotionapp.data.posture.PostureFactory;
+import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
+import com.melisa.innovamotionapp.data.posture.types.UnusedFootwearPosture;
+import com.melisa.innovamotionapp.databinding.BtConnectedActivityBinding;
+import com.melisa.innovamotionapp.ui.viewmodels.SupervisorFeedViewModel;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.RoleProvider;
+
+
+/**
+ * Activity for displaying posture data for a single person.
+ * 
+ * Supports two modes:
+ * 1. Legacy mode: Shows data from GlobalData (Bluetooth connection)
+ * 2. Sensor-specific mode: Shows data for a specific sensorId (Supervisor viewing from dashboard)
+ */
+public class BtConnectedActivity extends AppCompatActivity {
+    
+    // Intent extras for sensor-specific viewing
+    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
+    public static final String EXTRA_PERSON_NAME = "extra_person_name";
+    
+    private static final int REQUEST_ENABLE_BT = 1;
+    private BluetoothAdapter mBluetoothAdapter;
+    private BtConnectedActivityBinding binding;
+    private final GlobalData globalData = GlobalData.getInstance();
+    private SupervisorFeedViewModel supervisorFeedViewModel;
+    private boolean isFirstPosture = true;
+    private Posture currentPosture = null;
+    
+    // Sensor-specific fields
+    private String sensorId;
+    private String personName;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        binding = BtConnectedActivityBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        // Extract intent extras
+        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
+        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
+        
+        // Set initial title/name
+        if (personName != null && !personName.isEmpty()) {
+            // Supervisor viewing specific person - show their name
+            binding.descriptionTextView.setText(personName);
+        } else {
+            // Legacy behavior - use global userName
+            binding.descriptionTextView.setText(globalData.userName);
+        }
+
+        // Choose observation mode based on whether sensorId is provided
+        if (sensorId != null && !sensorId.isEmpty() && RoleProvider.isSupervisor()) {
+            // Supervisor viewing a specific person from dashboard
+            Log.d(TAG, "Supervisor viewing specific person: sensorId=" + sensorId + ", name=" + personName);
+            observeSensorSpecificData();
+        } else {
+            // Legacy behavior: GlobalData observer for Bluetooth connection
+            observeGlobalData();
+        }
+
+        // Modified connection observer: supervisors don't need to exit on disconnect
+        GlobalData.getInstance().getIsConnectedDevice().observe(this, isConnected -> {
+            if (!isConnected && RoleProvider.getCurrentRole() != RoleProvider.Role.SUPERVISOR) {
+                // Exit this activity only for supervised users when device connection is terminated
+                // Supervisors stay in the activity to continue monitoring Room data
+                finish();
+            }
+        });
+    }
+
+    /**
+     * Observe sensor-specific data from Room database.
+     * Used when supervisor views a specific person from the dashboard.
+     */
+    private void observeSensorSpecificData() {
+        ReceivedBtDataDao dao = InnovaDatabase.getInstance(this).receivedBtDataDao();
+        dao.getLatestForSensor(sensorId).observe(this, entity -> {
+            if (entity != null) {
+                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
+                Log.d(TAG, "Sensor-specific: received posture for " + sensorId);
+                displayPostureData(posture);
+            }
+        });
+    }
+
+    /**
+     * Observe global data from GlobalData and SupervisorFeedViewModel.
+     * Legacy behavior for Bluetooth connection mode.
+     */
+    private void observeGlobalData() {
+        // Existing observer stays: observe LiveData for device data
+        globalData.getReceivedPosture().observe(this, posture -> {
+            if (posture == null) return; // wait for real data
+            displayPostureData(posture);
+        });
+
+        // New: if supervisor, observe latest message from Room so we always show the freshest posture
+        if (RoleProvider.getCurrentRole() == RoleProvider.Role.SUPERVISOR) {
+            Log.d(TAG, "Supervisor detected: setting up Room-based posture feed");
+            supervisorFeedViewModel = new ViewModelProvider(this).get(SupervisorFeedViewModel.class);
+            supervisorFeedViewModel.getLatestPosture().observe(this, posture -> {
+                if (posture != null) {
+                    Log.d(TAG, "Supervisor: received latest posture from Room");
+                    displayPostureData(posture);
+                }
+            });
+        }
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        if (currentPosture != null) {
+            displayPostureData(currentPosture);
+        }
+    }
+
+    public void displayPostureData(Posture livePosture) {
+        if (livePosture == null) return; // extra guard
+
+        Posture postureToDisplay = livePosture;
+        if (isFirstPosture && postureToDisplay instanceof UnknownPosture) {
+            postureToDisplay = new UnusedFootwearPosture();
+        } else if (!(livePosture instanceof UnknownPosture)) {
+            isFirstPosture = false;
+        }
+
+        currentPosture = postureToDisplay;
+
+        // Use personName if available, otherwise fall back to globalData.userName
+        String displayName = (personName != null && !personName.isEmpty()) 
+                ? personName 
+                : globalData.userName;
+        String postureMessageWithName = getString(postureToDisplay.getTextCode(), displayName);
+        binding.descriptionTextView.setText(postureMessageWithName);
+
+        binding.riskValueTextView.setText(getString(postureToDisplay.getRisc()));
+
+        if (postureToDisplay instanceof UnknownPosture) {
+            // The posture is an instance of UnknownPosture
+            binding.videoView.stopPlayback(); // Stop any ongoing playback
+            binding.videoView.setVideoURI(null); // Clear the video content
+        } else {
+            // Handle other cases
+            String videoPath = "android.resource://" + getPackageName() + "/" + postureToDisplay.getVideoCode();
+            binding.videoView.setVideoPath(videoPath);
+            binding.videoView.start(); // Start playing the video
+        }
+    }
+
+    /**
+     * Get the current sensorId (for passing to child activities).
+     */
+    public String getSensorId() {
+        return sensorId;
+    }
+
+    /**
+     * Get the current personName (for passing to child activities).
+     */
+    public String getPersonName() {
+        return personName;
+    }
+
+    public void log(String msg) {
+        Log.d(TAG, msg);
+        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
+    }
+
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtSettingsActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtSettingsActivity.java
index 0b721e3..0e1a123 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtSettingsActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/BtSettingsActivity.java
@@ -1,354 +1,354 @@
-package com.melisa.innovamotionapp.activities;
-
-import static android.content.ContentValues.TAG;
-import static com.melisa.innovamotionapp.ui.viewmodels.BtSettingsViewModel.BtSettingsState;
-
-import android.Manifest;
-import android.app.AlertDialog;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.PackageManager;
-import android.location.LocationManager;
-import android.os.Build;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.util.Log;
-import android.view.View;
-import android.widget.Toast;
-
-import androidx.activity.result.ActivityResult;
-import androidx.activity.result.ActivityResultLauncher;
-import androidx.activity.result.contract.ActivityResultContracts;
-import androidx.annotation.NonNull;
-import androidx.annotation.RequiresApi;
-import androidx.annotation.Nullable;
-import androidx.lifecycle.ViewModelProvider;
-
-import com.google.android.material.button.MaterialButton;
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.databinding.BtSettingsActivityBinding;
-import com.melisa.innovamotionapp.sync.SessionGate;
-import com.melisa.innovamotionapp.ui.adapters.NearbyDeviceDataAdapter;
-import com.melisa.innovamotionapp.ui.viewmodels.BtSettingsViewModel;
-import com.melisa.innovamotionapp.utils.Logger;
-import com.melisa.innovamotionapp.utils.RoleProvider;
-
-import java.util.List;
-
-public class BtSettingsActivity extends BaseActivity {
-
-    private BtSettingsActivityBinding binding;
-    private BtSettingsViewModel viewModel;
-    private MaterialButton signOutButton;
-    private final ActivityResultLauncher<Intent> enableBluetoothLauncher = registerForActivityResult(
-            new ActivityResultContracts.StartActivityForResult(), this::processEnableBluetoothResponse);
-    private AlertDialog locationDialog = null;
-
-
-    @Override
-    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
-        // Early exit for supervisors: they shouldn't need to scan
-        SessionGate.getInstance(this).waitForSessionReady(new SessionGate.SessionReadyCallback() {
-            @Override
-            public void onSessionReady(String userId, String role, List<String> supervisedUserIds) {
-                runOnUiThread(() -> {
-                    if ("supervisor".equals(role)) {
-                        Logger.d(TAG, "Supervisor detected in BtSettingsActivity: redirecting to BtConnectedActivity");
-                        Intent intent = new Intent(BtSettingsActivity.this, BtConnectedActivity.class);
-                        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
-                        startActivity(intent);
-                        finish();
-                        return;
-                    }
-                    
-                    // Continue with normal supervised user flow
-                    initializeSupervisedUserUI();
-                });
-            }
-            
-            @Override
-            public void onSessionError(String error) {
-                Logger.e(TAG, "Session not ready: " + error);
-                // Continue with normal flow if session not ready
-                initializeSupervisedUserUI();
-            }
-        });
-    }
-    
-    private void initializeSupervisedUserUI() {
-        binding = BtSettingsActivityBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-
-        // Initialize ViewModel
-        viewModel = new ViewModelProvider(this).get(BtSettingsViewModel.class);
-
-        // Initialize sign out button
-        signOutButton = findViewById(R.id.sign_out_button);
-        signOutButton.setOnClickListener(v -> signOut());
-
-        // Observe LiveData from ViewModel
-        setupObservers();
-        setupUIListeners();
-
-        viewModel.checkBluetoothState();
-        updateUI(BtSettingsState.BEFORE_BTN_PRESSED);
-        
-        Logger.i(TAG, "BtSettingsActivity UI initialized successfully");
-    }
-
-    private void setupObservers() {
-        // Observe Bluetooth UI state
-        viewModel.getUIState().observe(this, this::updateUI);
-
-        // Observe nearby devices
-        viewModel.getNearbyDevices().observe(this, devices -> {
-            String userName = binding.inputChildName.getText().toString();
-
-
-            // Display nearby devices
-            NearbyDeviceDataAdapter adapter = new NearbyDeviceDataAdapter(
-                    this,
-                    R.layout.nearby_device_layout,
-                    devices
-            );
-            adapter.setOnDeviceClickListener(device -> {
-                viewModel.connectToDevice(device, userName);
-            });
-            binding.deviceListRecyclerView.setAdapter(adapter);
-        });
-
-        globalData.getIsConnectedDevice().observe(this, isConnected -> {
-
-            if (isConnected) {
-                String deviceConnected = globalData.deviceCommunicationManager.getDeviceToConnect().getAddress();
-                globalData.userDeviceSettingsStorage.saveLatestDeviceAddress(deviceConnected);
-                
-                Logger.bluetooth(TAG, deviceConnected, "Device connected successfully");
-
-                // Navigate to the next screen or update UI
-                launchBtConnectedActivity();
-            } else {
-                // Handle the disconnected state if necessary
-                Logger.d(TAG, "Service is disconnected");
-            }
-        });
-    }
-
-
-    private void setupUIListeners() {
-        // UserName text input logic
-        binding.inputChildName.addTextChangedListener(new TextWatcher() {
-            @Override
-            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-                // Not needed
-            }
-
-            @Override
-            public void onTextChanged(CharSequence s, int start, int before, int count) {
-                // Get the trimmed version of the input
-                String trimmedInput = s.toString().trim();
-                // Enable the button if the trimmed input is at least 3 characters
-                binding.btConnection.setEnabled(trimmedInput.length() >= 3);
-            }
-
-            @Override
-            public void afterTextChanged(Editable s) {
-                // Not needed
-            }
-        });
-
-        // Button click logic
-        binding.btConnection.setOnClickListener(this::onStartBtnClicked);
-    }
-
-    private void updateUI(BtSettingsState state) {
-        switch (state) {
-            case BEFORE_BTN_PRESSED: // On activity initialisation
-                binding.inputChildName.setEnabled(true);
-                binding.btConnection.setEnabled(false);
-                binding.inputChildName.setText(globalData.userDeviceSettingsStorage.getLatestUser());
-                break;
-
-            case AFTER_BTN_PRESSED:
-                binding.inputChildName.setEnabled(false);
-                binding.btConnection.setEnabled(false);
-                break;
-
-            case BLUETOOTH_OFF:
-                // Bluetooth needs to be enabled
-                binding.btConnection.setText(R.string.bt_start_to_enable_text);
-                break;
-
-            case ENABLING_BLUETOOTH:
-                binding.btConnection.setText(R.string.bt_enabling_text);
-
-                Intent enableBTIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
-                enableBluetoothLauncher.launch(enableBTIntent);
-                break;
-
-            case READY_TO_CONNECT:
-                // Ready to connect
-                binding.btConnection.setText(R.string.bt_start_to_connect_text);
-                break;
-
-            case SCANNING:
-                binding.btConnection.setText(R.string.bt_scanning_text);
-                binding.btConnection.setEnabled(true);
-                break;
-
-            case SCAN_FINISHED:
-                binding.btConnection.setText(R.string.bt_stopped_scan_text);
-                binding.btConnection.setEnabled(true);
-                break;
-
-            case CONNECTING:
-                binding.btConnection.setText(R.string.bt_connecting_text);
-                binding.btConnection.setEnabled(false);
-                break;
-        }
-    }
-
-    private void onStartBtnClicked(View view) {
-        updateUI(BtSettingsState.AFTER_BTN_PRESSED);
-
-        if (checkAllRequirements()) {
-            // Safe return in case permissions are not allowed.
-            updateUI(BtSettingsState.BEFORE_BTN_PRESSED);
-            return;
-        }
-
-
-        // Start Bluetooth discovery
-        viewModel.startBluetoothDiscovery();
-    }
-
-    private void processEnableBluetoothResponse(ActivityResult activityResult) {
-        if (activityResult.getResultCode() == RESULT_OK) {
-            logAndToast("Bluetooth enabled successfully");
-            viewModel.startBluetoothDiscovery();
-        } else {
-            logErrorAndNotifyUser("Failed to enable Bluetooth", "Bluetooth is required for device connection", null);
-        }
-    }
-
-    private boolean doesNeedRequestPermission(String[] perms) {
-        for (String perm : perms) {
-            if (this.checkSelfPermission(perm) != PackageManager.PERMISSION_GRANTED) {
-
-                this.requestPermissions(new String[]{perm}, 2);
-                return true;
-            }
-        }
-        return false;
-    }
-
-
-
-
-    private void launchBtConnectedActivity() {
-        Logger.userAction(TAG, "Launching BtConnectedActivity");
-        navigateToActivityAndFinish(BtConnectedActivity.class, null);
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        // Register broadcast receivers
-        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
-        registerReceiver(viewModel.getBluetoothStateReceiver(), filter);
-
-        filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
-        registerReceiver(viewModel.getNearbyDeviceDiscoveryReceiver(), filter);
-
-        filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
-        registerReceiver(viewModel.getDiscoveryFinishedReceiver(), filter);
-
-
-        if (checkAllRequirements()) {
-            // Safe return in case permissions are not allowed.
-            return;
-        }
-    }
-
-    private String[] getRequiredPermissions() {
-        String[] requiredPermissions;
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-            requiredPermissions = new String[]{Manifest.permission.POST_NOTIFICATIONS, Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_CONNECT};
-        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
-            requiredPermissions = new String[]{Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_CONNECT};
-        } else {
-            requiredPermissions = new String[]{Manifest.permission.ACCESS_FINE_LOCATION};
-        }
-        return requiredPermissions;
-    }
-
-    /**
-     * Checks if all requirements (permissions + location for older OS) are met.
-     * If not, it requests them or shows a location dialog. Returns `false` if everything
-     * is good, or `true` otherwise.
-     */
-    private boolean checkAllRequirements() {
-        String[] requiredPermissions = getRequiredPermissions();
-
-
-        boolean requirePermissions = doesNeedRequestPermission(requiredPermissions);
-
-        // 2. If we are on an older device (below S), ensure location is enabled
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
-            LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
-            boolean isLocationEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) ||
-                    locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
-            if (!isLocationEnabled) {
-                showLocationDisabledDialog();
-                return true;
-            }
-        }
-
-        return requirePermissions;
-    }
-
-    private void showLocationDisabledDialog() {
-        // If the dialog is already showing, just return
-        if (locationDialog != null && locationDialog.isShowing()) {
-            return;
-        }
-
-        // Otherwise, build a new one
-        locationDialog = new AlertDialog.Builder(this)
-                .setTitle("Location Services Required")
-                .setMessage("Please enable location services for Bluetooth scanning.")
-                .setPositiveButton("Go to Settings", (dialog, which) -> {
-                    Intent settingsIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
-                    startActivity(settingsIntent);
-                })
-                .setNegativeButton("Cancel", (dialog, which) -> {
-                    dialog.dismiss();
-                })
-                .create();
-
-        locationDialog.show();
-    }
-
-
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-
-        // Unregister broadcast receivers
-        unregisterReceiver(viewModel.getBluetoothStateReceiver());
-        unregisterReceiver(viewModel.getNearbyDeviceDiscoveryReceiver());
-        unregisterReceiver(viewModel.getDiscoveryFinishedReceiver());
-
-        if (locationDialog != null && locationDialog.isShowing()) {
-            locationDialog.dismiss();
-            locationDialog = null;
-        }
-    }
-}
+package com.melisa.innovamotionapp.activities;
+
+import static android.content.ContentValues.TAG;
+import static com.melisa.innovamotionapp.ui.viewmodels.BtSettingsViewModel.BtSettingsState;
+
+import android.Manifest;
+import android.app.AlertDialog;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.location.LocationManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.provider.Settings;
+import android.text.Editable;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.View;
+import android.widget.Toast;
+
+import androidx.activity.result.ActivityResult;
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
+import androidx.annotation.Nullable;
+import androidx.lifecycle.ViewModelProvider;
+
+import com.google.android.material.button.MaterialButton;
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.databinding.BtSettingsActivityBinding;
+import com.melisa.innovamotionapp.sync.SessionGate;
+import com.melisa.innovamotionapp.ui.adapters.NearbyDeviceDataAdapter;
+import com.melisa.innovamotionapp.ui.viewmodels.BtSettingsViewModel;
+import com.melisa.innovamotionapp.utils.Logger;
+import com.melisa.innovamotionapp.utils.RoleProvider;
+
+import java.util.List;
+
+public class BtSettingsActivity extends BaseActivity {
+
+    private BtSettingsActivityBinding binding;
+    private BtSettingsViewModel viewModel;
+    private MaterialButton signOutButton;
+    private final ActivityResultLauncher<Intent> enableBluetoothLauncher = registerForActivityResult(
+            new ActivityResultContracts.StartActivityForResult(), this::processEnableBluetoothResponse);
+    private AlertDialog locationDialog = null;
+
+
+    @Override
+    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
+        // Early exit for supervisors: they shouldn't need to scan
+        SessionGate.getInstance(this).waitForSessionReady(new SessionGate.SessionReadyCallback() {
+            @Override
+            public void onSessionReady(String userId, String role, List<String> supervisedUserIds) {
+                runOnUiThread(() -> {
+                    if ("supervisor".equals(role)) {
+                        Logger.d(TAG, "Supervisor detected in BtSettingsActivity: redirecting to BtConnectedActivity");
+                        Intent intent = new Intent(BtSettingsActivity.this, BtConnectedActivity.class);
+                        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
+                        startActivity(intent);
+                        finish();
+                        return;
+                    }
+                    
+                    // Continue with normal supervised user flow
+                    initializeSupervisedUserUI();
+                });
+            }
+            
+            @Override
+            public void onSessionError(String error) {
+                Logger.e(TAG, "Session not ready: " + error);
+                // Continue with normal flow if session not ready
+                initializeSupervisedUserUI();
+            }
+        });
+    }
+    
+    private void initializeSupervisedUserUI() {
+        binding = BtSettingsActivityBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        // Initialize ViewModel
+        viewModel = new ViewModelProvider(this).get(BtSettingsViewModel.class);
+
+        // Initialize sign out button
+        signOutButton = findViewById(R.id.sign_out_button);
+        signOutButton.setOnClickListener(v -> signOut());
+
+        // Observe LiveData from ViewModel
+        setupObservers();
+        setupUIListeners();
+
+        viewModel.checkBluetoothState();
+        updateUI(BtSettingsState.BEFORE_BTN_PRESSED);
+        
+        Logger.i(TAG, "BtSettingsActivity UI initialized successfully");
+    }
+
+    private void setupObservers() {
+        // Observe Bluetooth UI state
+        viewModel.getUIState().observe(this, this::updateUI);
+
+        // Observe nearby devices
+        viewModel.getNearbyDevices().observe(this, devices -> {
+            String userName = binding.inputChildName.getText().toString();
+
+
+            // Display nearby devices
+            NearbyDeviceDataAdapter adapter = new NearbyDeviceDataAdapter(
+                    this,
+                    R.layout.nearby_device_layout,
+                    devices
+            );
+            adapter.setOnDeviceClickListener(device -> {
+                viewModel.connectToDevice(device, userName);
+            });
+            binding.deviceListRecyclerView.setAdapter(adapter);
+        });
+
+        globalData.getIsConnectedDevice().observe(this, isConnected -> {
+
+            if (isConnected) {
+                String deviceConnected = globalData.deviceCommunicationManager.getDeviceToConnect().getAddress();
+                globalData.userDeviceSettingsStorage.saveLatestDeviceAddress(deviceConnected);
+                
+                Logger.bluetooth(TAG, deviceConnected, "Device connected successfully");
+
+                // Navigate to the next screen or update UI
+                launchBtConnectedActivity();
+            } else {
+                // Handle the disconnected state if necessary
+                Logger.d(TAG, "Service is disconnected");
+            }
+        });
+    }
+
+
+    private void setupUIListeners() {
+        // UserName text input logic
+        binding.inputChildName.addTextChangedListener(new TextWatcher() {
+            @Override
+            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+                // Not needed
+            }
+
+            @Override
+            public void onTextChanged(CharSequence s, int start, int before, int count) {
+                // Get the trimmed version of the input
+                String trimmedInput = s.toString().trim();
+                // Enable the button if the trimmed input is at least 3 characters
+                binding.btConnection.setEnabled(trimmedInput.length() >= 3);
+            }
+
+            @Override
+            public void afterTextChanged(Editable s) {
+                // Not needed
+            }
+        });
+
+        // Button click logic
+        binding.btConnection.setOnClickListener(this::onStartBtnClicked);
+    }
+
+    private void updateUI(BtSettingsState state) {
+        switch (state) {
+            case BEFORE_BTN_PRESSED: // On activity initialisation
+                binding.inputChildName.setEnabled(true);
+                binding.btConnection.setEnabled(false);
+                binding.inputChildName.setText(globalData.userDeviceSettingsStorage.getLatestUser());
+                break;
+
+            case AFTER_BTN_PRESSED:
+                binding.inputChildName.setEnabled(false);
+                binding.btConnection.setEnabled(false);
+                break;
+
+            case BLUETOOTH_OFF:
+                // Bluetooth needs to be enabled
+                binding.btConnection.setText(R.string.bt_start_to_enable_text);
+                break;
+
+            case ENABLING_BLUETOOTH:
+                binding.btConnection.setText(R.string.bt_enabling_text);
+
+                Intent enableBTIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
+                enableBluetoothLauncher.launch(enableBTIntent);
+                break;
+
+            case READY_TO_CONNECT:
+                // Ready to connect
+                binding.btConnection.setText(R.string.bt_start_to_connect_text);
+                break;
+
+            case SCANNING:
+                binding.btConnection.setText(R.string.bt_scanning_text);
+                binding.btConnection.setEnabled(true);
+                break;
+
+            case SCAN_FINISHED:
+                binding.btConnection.setText(R.string.bt_stopped_scan_text);
+                binding.btConnection.setEnabled(true);
+                break;
+
+            case CONNECTING:
+                binding.btConnection.setText(R.string.bt_connecting_text);
+                binding.btConnection.setEnabled(false);
+                break;
+        }
+    }
+
+    private void onStartBtnClicked(View view) {
+        updateUI(BtSettingsState.AFTER_BTN_PRESSED);
+
+        if (checkAllRequirements()) {
+            // Safe return in case permissions are not allowed.
+            updateUI(BtSettingsState.BEFORE_BTN_PRESSED);
+            return;
+        }
+
+
+        // Start Bluetooth discovery
+        viewModel.startBluetoothDiscovery();
+    }
+
+    private void processEnableBluetoothResponse(ActivityResult activityResult) {
+        if (activityResult.getResultCode() == RESULT_OK) {
+            logAndToast("Bluetooth enabled successfully");
+            viewModel.startBluetoothDiscovery();
+        } else {
+            logErrorAndNotifyUser("Failed to enable Bluetooth", "Bluetooth is required for device connection", null);
+        }
+    }
+
+    private boolean doesNeedRequestPermission(String[] perms) {
+        for (String perm : perms) {
+            if (this.checkSelfPermission(perm) != PackageManager.PERMISSION_GRANTED) {
+
+                this.requestPermissions(new String[]{perm}, 2);
+                return true;
+            }
+        }
+        return false;
+    }
+
+
+
+
+    private void launchBtConnectedActivity() {
+        Logger.userAction(TAG, "Launching BtConnectedActivity");
+        navigateToActivityAndFinish(BtConnectedActivity.class, null);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        // Register broadcast receivers
+        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+        registerReceiver(viewModel.getBluetoothStateReceiver(), filter);
+
+        filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
+        registerReceiver(viewModel.getNearbyDeviceDiscoveryReceiver(), filter);
+
+        filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
+        registerReceiver(viewModel.getDiscoveryFinishedReceiver(), filter);
+
+
+        if (checkAllRequirements()) {
+            // Safe return in case permissions are not allowed.
+            return;
+        }
+    }
+
+    private String[] getRequiredPermissions() {
+        String[] requiredPermissions;
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+            requiredPermissions = new String[]{Manifest.permission.POST_NOTIFICATIONS, Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_CONNECT};
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
+            requiredPermissions = new String[]{Manifest.permission.BLUETOOTH_SCAN, Manifest.permission.BLUETOOTH_CONNECT};
+        } else {
+            requiredPermissions = new String[]{Manifest.permission.ACCESS_FINE_LOCATION};
+        }
+        return requiredPermissions;
+    }
+
+    /**
+     * Checks if all requirements (permissions + location for older OS) are met.
+     * If not, it requests them or shows a location dialog. Returns `false` if everything
+     * is good, or `true` otherwise.
+     */
+    private boolean checkAllRequirements() {
+        String[] requiredPermissions = getRequiredPermissions();
+
+
+        boolean requirePermissions = doesNeedRequestPermission(requiredPermissions);
+
+        // 2. If we are on an older device (below S), ensure location is enabled
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
+            LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
+            boolean isLocationEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) ||
+                    locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
+            if (!isLocationEnabled) {
+                showLocationDisabledDialog();
+                return true;
+            }
+        }
+
+        return requirePermissions;
+    }
+
+    private void showLocationDisabledDialog() {
+        // If the dialog is already showing, just return
+        if (locationDialog != null && locationDialog.isShowing()) {
+            return;
+        }
+
+        // Otherwise, build a new one
+        locationDialog = new AlertDialog.Builder(this)
+                .setTitle("Location Services Required")
+                .setMessage("Please enable location services for Bluetooth scanning.")
+                .setPositiveButton("Go to Settings", (dialog, which) -> {
+                    Intent settingsIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);
+                    startActivity(settingsIntent);
+                })
+                .setNegativeButton("Cancel", (dialog, which) -> {
+                    dialog.dismiss();
+                })
+                .create();
+
+        locationDialog.show();
+    }
+
+
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+
+        // Unregister broadcast receivers
+        unregisterReceiver(viewModel.getBluetoothStateReceiver());
+        unregisterReceiver(viewModel.getNearbyDeviceDiscoveryReceiver());
+        unregisterReceiver(viewModel.getDiscoveryFinishedReceiver());
+
+        if (locationDialog != null && locationDialog.isShowing()) {
+            locationDialog.dismiss();
+            locationDialog = null;
+        }
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/EnergyConsumptionActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/EnergyConsumptionActivity.java
index 3e3f84e..c9ab932 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/EnergyConsumptionActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/EnergyConsumptionActivity.java
@@ -1,195 +1,195 @@
-package com.melisa.innovamotionapp.activities;
-
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.lifecycle.ViewModelProvider;
-
-import com.github.mikephil.charting.data.PieEntry;
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.data.posture.Posture;
-import com.melisa.innovamotionapp.data.posture.PostureFactory;
-import com.melisa.innovamotionapp.databinding.EnergyConsumptionActivityBinding;
-import com.melisa.innovamotionapp.ui.viewmodels.EnergyConsumptionViewModel;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.TargetUserResolver;
-import com.melisa.innovamotionapp.sync.UserSession;
-
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-/**
- * Activity for displaying energy consumption breakdown.
- * 
- * Supports two modes:
- * 1. User-based filtering: Shows data for the current user
- * 2. Sensor-based filtering: Shows data for a specific sensor (via intent extras)
- */
-public class EnergyConsumptionActivity extends AppCompatActivity {
-    
-    // Intent extras for sensor-specific viewing
-    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
-    public static final String EXTRA_PERSON_NAME = "extra_person_name";
-    
-    private EnergyConsumptionActivityBinding binding;
-    private final GlobalData globalData = GlobalData.getInstance();
-    private InnovaDatabase database;
-    private EnergyConsumptionViewModel viewModel;
-    private boolean displayedOnce;
-    
-    // Sensor-specific fields
-    private String sensorId;
-    private String personName;
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        binding = EnergyConsumptionActivityBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-
-        // Init database with current context
-        database = InnovaDatabase.getInstance(this);
-
-        // Initialize ViewModel
-        viewModel = new ViewModelProvider(this).get(EnergyConsumptionViewModel.class);
-
-        // Boolean init to display data only once
-        displayedOnce = false;
-
-        // Extract intent extras
-        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
-        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
-
-        // Choose filtering mode based on whether sensorId is provided
-        if (sensorId != null && !sensorId.isEmpty()) {
-            // Sensor-specific mode: Show data for this sensor only
-            Log.i("UI/Energy", "Sensor-specific mode: sensorId=" + sensorId + ", name=" + personName);
-            viewModel.setSensorId(sensorId);
-        } else {
-            // User-based mode: Resolve and set target user once session is loaded
-            if (UserSession.getInstance(getApplicationContext()).isLoaded()) {
-                String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
-                Log.i("UI/Energy", "Resolved targetUserId=" + target);
-                viewModel.setTargetUserId(target);
-            } else {
-                UserSession.getInstance(getApplicationContext()).loadUserSession(new UserSession.SessionLoadCallback() {
-                    @Override
-                    public void onSessionLoaded(String uid, String role, java.util.List<String> kids) {
-                        String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
-                        Log.i("UI/Energy", "Resolved targetUserId=" + target);
-                        viewModel.setTargetUserId(target);
-                    }
-
-                    @Override
-                    public void onSessionLoadError(String error) {
-                        Log.w("UI/Energy", "Session load error: " + error);
-                    }
-                });
-            }
-        }
-
-        // Fetch all data for target user or sensor
-        viewModel.getAllForUser().observe(this, list -> {
-//            if (displayedOnce) {
-//                return;
-//            }
-            int size = (list != null ? list.size() : 0);
-            Log.i("UI/Energy", "listSize=" + size);
-            if (list != null && !list.isEmpty()) {
-
-                binding.parentLayout.removeAllViews();
-                // Boolean set to display data only once
-                displayedOnce = true;
-
-                // Display the savedData's dates interval
-                long startDate = list.get(0).getTimestamp(); // Set startDate as the timestamp of the first entry
-                long endDate = list.get(list.size() - 1).getTimestamp(); // Set endDate as the timestamp of the last entry
-                // Format both date and time (dd/MM/yyyy HH:mm:ss)
-                SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
-                String startDateString = sdf.format(new Date(startDate));
-                String endDateString = sdf.format(new Date(endDate));
-                // Creating the date range string
-                String selectedDateRange = startDateString + " - " + endDateString;
-                binding.selectedDateRange.setText(selectedDateRange);
-
-
-                // Convert entities to postures
-                List<Posture> postureListInDateRange = new ArrayList<>();
-                for (ReceivedBtDataEntity entity : list) {
-                    postureListInDateRange.add(PostureFactory.createPosture(entity.getReceivedMsg()));
-                }
-                // TODO: change here
-                // Calculate
-                func(postureListInDateRange);
-            }
-        });
-    }
-
-    private void func(List<Posture> postureListInDateRange) {
-        int sum = 0;
-        // Count occurrences of each posture type
-        Map<String, Integer> postureResourceMap = new HashMap<>(); // To store resource codes for each posture type
-        Map<String, Integer> postureCaloriesMap = new HashMap<>(); // To store sum calories for each posture type
-        for (Posture posture : postureListInDateRange) {
-            sum += posture.getCalories();
-            String postureType = posture.getClass().getSimpleName(); // Assuming each posture has a distinct class
-            postureCaloriesMap.compute(postureType, (key, currentValue) -> (currentValue == null ? 0 : currentValue) + posture.getCalories());
-            postureResourceMap.put(postureType, posture.getPictureCode()); // Save resource code
-        }
-
-
-        // Add rows dynamically
-        for (Map.Entry<String, Integer> entry : postureResourceMap.entrySet()) {
-            String postureName = entry.getKey();
-            int resourceId = entry.getValue();
-
-            // Create a horizontal LinearLayout for each row
-            LinearLayout rowLayout = new LinearLayout(this);
-            rowLayout.setOrientation(LinearLayout.HORIZONTAL);
-            rowLayout.setPadding(8, 8, 8, 8);
-
-            // Set background color for alternating rows (optional)
-            int backgroundColor = postureResourceMap.size() % 2 == 0 ? 0xFFEEEEEE : 0xFFFFFFFF;
-            rowLayout.setBackgroundColor(backgroundColor);
-
-            // Add ImageView for the posture image
-            ImageView imageView = new ImageView(this);
-            imageView.setLayoutParams(new LinearLayout.LayoutParams(100, 100));
-            imageView.setImageResource(resourceId);
-            rowLayout.addView(imageView);
-
-            // Add TextView for the posture name or calories
-            TextView textView = new TextView(this);
-            textView.setLayoutParams(new LinearLayout.LayoutParams(
-                    LinearLayout.LayoutParams.WRAP_CONTENT,
-                    LinearLayout.LayoutParams.WRAP_CONTENT
-            ));
-            textView.setText(postureName + " - " + postureCaloriesMap.get(postureName) + " cal");
-            textView.setPadding(16, 0, 0, 0);
-            rowLayout.addView(textView);
-
-            // Add the row to the parent layout
-            binding.parentLayout.addView(rowLayout);
-        }
-
-        // Add a total consumption TextView
-        TextView totalTextView = new TextView(this);
-        totalTextView.setText("Total consum: " + sum + " calorii");
-        totalTextView.setTextSize(18);
-        totalTextView.setPadding(8, 16, 0, 0);
-        binding.parentLayout.addView(totalTextView);
-
-    }
-
-}
+package com.melisa.innovamotionapp.activities;
+
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.lifecycle.ViewModelProvider;
+
+import com.github.mikephil.charting.data.PieEntry;
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.data.posture.Posture;
+import com.melisa.innovamotionapp.data.posture.PostureFactory;
+import com.melisa.innovamotionapp.databinding.EnergyConsumptionActivityBinding;
+import com.melisa.innovamotionapp.ui.viewmodels.EnergyConsumptionViewModel;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.TargetUserResolver;
+import com.melisa.innovamotionapp.sync.UserSession;
+
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+/**
+ * Activity for displaying energy consumption breakdown.
+ * 
+ * Supports two modes:
+ * 1. User-based filtering: Shows data for the current user
+ * 2. Sensor-based filtering: Shows data for a specific sensor (via intent extras)
+ */
+public class EnergyConsumptionActivity extends AppCompatActivity {
+    
+    // Intent extras for sensor-specific viewing
+    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
+    public static final String EXTRA_PERSON_NAME = "extra_person_name";
+    
+    private EnergyConsumptionActivityBinding binding;
+    private final GlobalData globalData = GlobalData.getInstance();
+    private InnovaDatabase database;
+    private EnergyConsumptionViewModel viewModel;
+    private boolean displayedOnce;
+    
+    // Sensor-specific fields
+    private String sensorId;
+    private String personName;
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        binding = EnergyConsumptionActivityBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        // Init database with current context
+        database = InnovaDatabase.getInstance(this);
+
+        // Initialize ViewModel
+        viewModel = new ViewModelProvider(this).get(EnergyConsumptionViewModel.class);
+
+        // Boolean init to display data only once
+        displayedOnce = false;
+
+        // Extract intent extras
+        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
+        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
+
+        // Choose filtering mode based on whether sensorId is provided
+        if (sensorId != null && !sensorId.isEmpty()) {
+            // Sensor-specific mode: Show data for this sensor only
+            Log.i("UI/Energy", "Sensor-specific mode: sensorId=" + sensorId + ", name=" + personName);
+            viewModel.setSensorId(sensorId);
+        } else {
+            // User-based mode: Resolve and set target user once session is loaded
+            if (UserSession.getInstance(getApplicationContext()).isLoaded()) {
+                String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
+                Log.i("UI/Energy", "Resolved targetUserId=" + target);
+                viewModel.setTargetUserId(target);
+            } else {
+                UserSession.getInstance(getApplicationContext()).loadUserSession(new UserSession.SessionLoadCallback() {
+                    @Override
+                    public void onSessionLoaded(String uid, String role, java.util.List<String> kids) {
+                        String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
+                        Log.i("UI/Energy", "Resolved targetUserId=" + target);
+                        viewModel.setTargetUserId(target);
+                    }
+
+                    @Override
+                    public void onSessionLoadError(String error) {
+                        Log.w("UI/Energy", "Session load error: " + error);
+                    }
+                });
+            }
+        }
+
+        // Fetch all data for target user or sensor
+        viewModel.getAllForUser().observe(this, list -> {
+//            if (displayedOnce) {
+//                return;
+//            }
+            int size = (list != null ? list.size() : 0);
+            Log.i("UI/Energy", "listSize=" + size);
+            if (list != null && !list.isEmpty()) {
+
+                binding.parentLayout.removeAllViews();
+                // Boolean set to display data only once
+                displayedOnce = true;
+
+                // Display the savedData's dates interval
+                long startDate = list.get(0).getTimestamp(); // Set startDate as the timestamp of the first entry
+                long endDate = list.get(list.size() - 1).getTimestamp(); // Set endDate as the timestamp of the last entry
+                // Format both date and time (dd/MM/yyyy HH:mm:ss)
+                SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
+                String startDateString = sdf.format(new Date(startDate));
+                String endDateString = sdf.format(new Date(endDate));
+                // Creating the date range string
+                String selectedDateRange = startDateString + " - " + endDateString;
+                binding.selectedDateRange.setText(selectedDateRange);
+
+
+                // Convert entities to postures
+                List<Posture> postureListInDateRange = new ArrayList<>();
+                for (ReceivedBtDataEntity entity : list) {
+                    postureListInDateRange.add(PostureFactory.createPosture(entity.getReceivedMsg()));
+                }
+                // TODO: change here
+                // Calculate
+                func(postureListInDateRange);
+            }
+        });
+    }
+
+    private void func(List<Posture> postureListInDateRange) {
+        int sum = 0;
+        // Count occurrences of each posture type
+        Map<String, Integer> postureResourceMap = new HashMap<>(); // To store resource codes for each posture type
+        Map<String, Integer> postureCaloriesMap = new HashMap<>(); // To store sum calories for each posture type
+        for (Posture posture : postureListInDateRange) {
+            sum += posture.getCalories();
+            String postureType = posture.getClass().getSimpleName(); // Assuming each posture has a distinct class
+            postureCaloriesMap.compute(postureType, (key, currentValue) -> (currentValue == null ? 0 : currentValue) + posture.getCalories());
+            postureResourceMap.put(postureType, posture.getPictureCode()); // Save resource code
+        }
+
+
+        // Add rows dynamically
+        for (Map.Entry<String, Integer> entry : postureResourceMap.entrySet()) {
+            String postureName = entry.getKey();
+            int resourceId = entry.getValue();
+
+            // Create a horizontal LinearLayout for each row
+            LinearLayout rowLayout = new LinearLayout(this);
+            rowLayout.setOrientation(LinearLayout.HORIZONTAL);
+            rowLayout.setPadding(8, 8, 8, 8);
+
+            // Set background color for alternating rows (optional)
+            int backgroundColor = postureResourceMap.size() % 2 == 0 ? 0xFFEEEEEE : 0xFFFFFFFF;
+            rowLayout.setBackgroundColor(backgroundColor);
+
+            // Add ImageView for the posture image
+            ImageView imageView = new ImageView(this);
+            imageView.setLayoutParams(new LinearLayout.LayoutParams(100, 100));
+            imageView.setImageResource(resourceId);
+            rowLayout.addView(imageView);
+
+            // Add TextView for the posture name or calories
+            TextView textView = new TextView(this);
+            textView.setLayoutParams(new LinearLayout.LayoutParams(
+                    LinearLayout.LayoutParams.WRAP_CONTENT,
+                    LinearLayout.LayoutParams.WRAP_CONTENT
+            ));
+            textView.setText(postureName + " - " + postureCaloriesMap.get(postureName) + " cal");
+            textView.setPadding(16, 0, 0, 0);
+            rowLayout.addView(textView);
+
+            // Add the row to the parent layout
+            binding.parentLayout.addView(rowLayout);
+        }
+
+        // Add a total consumption TextView
+        TextView totalTextView = new TextView(this);
+        totalTextView.setText("Total consum: " + sum + " calorii");
+        totalTextView.setTextSize(18);
+        totalTextView.setPadding(8, 16, 0, 0);
+        binding.parentLayout.addView(totalTextView);
+
+    }
+
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/MainActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/MainActivity.java
index 1f46983..3fad285 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/MainActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/MainActivity.java
@@ -1,91 +1,91 @@
-package com.melisa.innovamotionapp.activities;
-
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.os.Build;
-import android.os.Bundle;
-import android.view.View;
-
-import androidx.annotation.Nullable;
-
-import com.google.android.material.button.MaterialButton;
-import com.melisa.innovamotionapp.databinding.MainActivityBinding;
-import com.melisa.innovamotionapp.sync.SessionGate;
-import com.melisa.innovamotionapp.utils.Logger;
-import com.melisa.innovamotionapp.utils.RoleProvider;
-
-import java.util.List;
-
-
-public class MainActivity extends BaseActivity {
-
-    private MainActivityBinding binding;
-    private MaterialButton signOutButton;
-
-    @Override
-    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
-        binding = MainActivityBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-
-        // Initialize sign out button
-        signOutButton = findViewById(com.melisa.innovamotionapp.R.id.sign_out_button);
-        signOutButton.setOnClickListener(v -> signOut());
-
-        Logger.i(TAG, "MainActivity UI initialized successfully");
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-            if (checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)
-                    != PackageManager.PERMISSION_GRANTED) {
-                requestPermissions(new String[]{android.Manifest.permission.POST_NOTIFICATIONS}, 1001);
-            }
-        }
-    }
-
-    public void LaunchMonitoring(View view) {
-        Logger.userAction(TAG, "Launch Monitoring clicked");
-        
-        // Wait for SessionGate to be ready before routing
-        SessionGate.getInstance(this).waitForSessionReady(new SessionGate.SessionReadyCallback() {
-            @Override
-            public void onSessionReady(String userId, String role, List<String> supervisedUserIds) {
-                runOnUiThread(() -> {
-                    if ("supervisor".equals(role)) {
-                        Logger.d(TAG, "Supervisor detected: routing to SupervisorDashboardActivity");
-                        // Supervisor: go to multi-person dashboard
-                        Intent intent = new Intent(MainActivity.this, SupervisorDashboardActivity.class);
-                        startActivity(intent);
-                    } else {
-                        Logger.d(TAG, "Aggregator detected: routing to AggregatorDashboardActivity");
-                        // Aggregator: go to aggregator dashboard for Bluetooth connection
-                        Intent intent = new Intent(MainActivity.this, AggregatorDashboardActivity.class);
-                        startActivity(intent);
-                    }
-                });
-            }
-            
-            @Override
-            public void onSessionError(String error) {
-                Logger.e(TAG, "Session not ready: " + error);
-                // Fallback to supervised flow if session not ready
-                navigateToActivity(BtSettingsActivity.class, null);
-            }
-        });
-    }
-
-    public void LaunchStatistics(View view) {
-        Logger.userAction(TAG, "Launch Statistics clicked");
-        navigateToActivity(StatisticsActivity.class, null);
-    }
-
-    public void LaunchTimelapse(View view) {
-        Logger.userAction(TAG, "Launch Timelapse clicked");
-        navigateToActivity(TimeLapseActivity.class, null);
-    }
-
-    public void LaunchEnergyConsumption(View view) {
-        Logger.userAction(TAG, "Launch Energy Consumption clicked");
-        navigateToActivity(EnergyConsumptionActivity.class, null);
-    }
-
-
+package com.melisa.innovamotionapp.activities;
+
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.view.View;
+
+import androidx.annotation.Nullable;
+
+import com.google.android.material.button.MaterialButton;
+import com.melisa.innovamotionapp.databinding.MainActivityBinding;
+import com.melisa.innovamotionapp.sync.SessionGate;
+import com.melisa.innovamotionapp.utils.Logger;
+import com.melisa.innovamotionapp.utils.RoleProvider;
+
+import java.util.List;
+
+
+public class MainActivity extends BaseActivity {
+
+    private MainActivityBinding binding;
+    private MaterialButton signOutButton;
+
+    @Override
+    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
+        binding = MainActivityBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        // Initialize sign out button
+        signOutButton = findViewById(com.melisa.innovamotionapp.R.id.sign_out_button);
+        signOutButton.setOnClickListener(v -> signOut());
+
+        Logger.i(TAG, "MainActivity UI initialized successfully");
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+            if (checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)
+                    != PackageManager.PERMISSION_GRANTED) {
+                requestPermissions(new String[]{android.Manifest.permission.POST_NOTIFICATIONS}, 1001);
+            }
+        }
+    }
+
+    public void LaunchMonitoring(View view) {
+        Logger.userAction(TAG, "Launch Monitoring clicked");
+        
+        // Wait for SessionGate to be ready before routing
+        SessionGate.getInstance(this).waitForSessionReady(new SessionGate.SessionReadyCallback() {
+            @Override
+            public void onSessionReady(String userId, String role, List<String> supervisedUserIds) {
+                runOnUiThread(() -> {
+                    if ("supervisor".equals(role)) {
+                        Logger.d(TAG, "Supervisor detected: routing to SupervisorDashboardActivity");
+                        // Supervisor: go to multi-person dashboard
+                        Intent intent = new Intent(MainActivity.this, SupervisorDashboardActivity.class);
+                        startActivity(intent);
+                    } else {
+                        Logger.d(TAG, "Aggregator detected: routing to AggregatorDashboardActivity");
+                        // Aggregator: go to aggregator dashboard for Bluetooth connection
+                        Intent intent = new Intent(MainActivity.this, AggregatorDashboardActivity.class);
+                        startActivity(intent);
+                    }
+                });
+            }
+            
+            @Override
+            public void onSessionError(String error) {
+                Logger.e(TAG, "Session not ready: " + error);
+                // Fallback to supervised flow if session not ready
+                navigateToActivity(BtSettingsActivity.class, null);
+            }
+        });
+    }
+
+    public void LaunchStatistics(View view) {
+        Logger.userAction(TAG, "Launch Statistics clicked");
+        navigateToActivity(StatisticsActivity.class, null);
+    }
+
+    public void LaunchTimelapse(View view) {
+        Logger.userAction(TAG, "Launch Timelapse clicked");
+        navigateToActivity(TimeLapseActivity.class, null);
+    }
+
+    public void LaunchEnergyConsumption(View view) {
+        Logger.userAction(TAG, "Launch Energy Consumption clicked");
+        navigateToActivity(EnergyConsumptionActivity.class, null);
+    }
+
+
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/PersonNamesActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/PersonNamesActivity.java
index 410d355..b56dd83 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/PersonNamesActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/PersonNamesActivity.java
@@ -13,15 +13,18 @@ import com.melisa.innovamotionapp.R;
 import com.melisa.innovamotionapp.data.database.MonitoredPerson;
 import com.melisa.innovamotionapp.databinding.ActivityPersonNamesBinding;
 import com.melisa.innovamotionapp.ui.adapters.PersonNamesAdapter;
-import com.melisa.innovamotionapp.ui.dialogs.PersonNameEditDialog;
+import com.melisa.innovamotionapp.ui.dialogs.SensorSettingsDialog;
 import com.melisa.innovamotionapp.ui.viewmodels.PersonNamesViewModel;
 import com.melisa.innovamotionapp.utils.Logger;
 
+import java.util.Map;
+
 /**
- * Activity for managing person display names.
+ * Activity for managing person display names and supervisor assignments.
  * 
- * Allows aggregator users to assign friendly names to sensor IDs.
- * Example: "sensor001" can be renamed to "Ion Popescu".
+ * Allows aggregator users to:
+ * - Assign friendly names to sensor IDs (e.g., "sensor001" â†’ "Ion Popescu")
+ * - Assign supervisors to sensors via email autocomplete
  */
 public class PersonNamesActivity extends BaseActivity {
 
@@ -52,12 +55,13 @@ public class PersonNamesActivity extends BaseActivity {
     }
 
     private void setupRecyclerView() {
-        adapter = new PersonNamesAdapter(this::showEditDialog);
+        adapter = new PersonNamesAdapter(this::showSettingsDialog);
         binding.recyclerView.setLayoutManager(new LinearLayoutManager(this));
         binding.recyclerView.setAdapter(adapter);
     }
 
     private void observeData() {
+        // Observe persons
         viewModel.getAllPersons().observe(this, persons -> {
             adapter.submitList(persons);
 
@@ -68,22 +72,68 @@ public class PersonNamesActivity extends BaseActivity {
 
             Logger.d(TAG, "Loaded " + (persons != null ? persons.size() : 0) + " persons");
         });
+        
+        // Observe supervisor assignments
+        viewModel.getSensorSupervisorMap().observe(this, map -> {
+            adapter.setSupervisorMap(map);
+            Logger.d(TAG, "Loaded " + (map != null ? map.size() : 0) + " supervisor assignments");
+        });
     }
 
     /**
-     * Show dialog to edit a person's display name.
+     * Show dialog to edit sensor settings (name and supervisor).
      */
-    private void showEditDialog(MonitoredPerson person) {
-        PersonNameEditDialog dialog = PersonNameEditDialog.newInstance(
+    private void showSettingsDialog(MonitoredPerson person) {
+        String supervisorEmail = viewModel.getSupervisorForSensor(person.getSensorId());
+        
+        SensorSettingsDialog dialog = SensorSettingsDialog.newInstance(
                 person.getSensorId(),
-                person.getDisplayName()
+                person.getDisplayName(),
+                supervisorEmail
         );
-        dialog.setOnSaveListener((sensorId, newName) -> {
+        
+        dialog.setOnSaveListener((sensorId, newName, newSupervisorEmail) -> {
+            // Update display name
             viewModel.updateDisplayName(sensorId, newName);
             showToast(getString(R.string.name_updated, newName));
             Logger.userAction(TAG, "Updated name for " + sensorId + " to " + newName);
+            
+            // Assign supervisor if email provided
+            if (newSupervisorEmail != null && !newSupervisorEmail.isEmpty()) {
+                viewModel.assignSupervisor(sensorId, newSupervisorEmail, 
+                        new PersonNamesViewModel.AssignmentResultCallback() {
+                    @Override
+                    public void onSuccess() {
+                        showToast(getString(R.string.supervisor_assignment_success));
+                        Logger.userAction(TAG, "Assigned supervisor " + newSupervisorEmail + " to " + sensorId);
+                    }
+
+                    @Override
+                    public void onError(String error) {
+                        showToast(getString(R.string.supervisor_assignment_error, error));
+                        Logger.e(TAG, "Failed to assign supervisor: " + error);
+                    }
+                });
+            }
+        });
+        
+        dialog.setOnUnassignListener(sensorId -> {
+            viewModel.unassignSupervisor(sensorId, new PersonNamesViewModel.AssignmentResultCallback() {
+                @Override
+                public void onSuccess() {
+                    showToast(getString(R.string.supervisor_unassigned_success));
+                    Logger.userAction(TAG, "Unassigned supervisor from " + sensorId);
+                }
+
+                @Override
+                public void onError(String error) {
+                    showToast(getString(R.string.supervisor_assignment_error, error));
+                    Logger.e(TAG, "Failed to unassign supervisor: " + error);
+                }
+            });
         });
-        dialog.show(getSupportFragmentManager(), "edit_name");
+        
+        dialog.show(getSupportFragmentManager(), "sensor_settings");
     }
 
     @Override
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StartActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StartActivity.java
index b8a8459..af639f2 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StartActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StartActivity.java
@@ -1,34 +1,34 @@
-package com.melisa.innovamotionapp.activities;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-
-import androidx.appcompat.app.AppCompatActivity;
-
-import com.melisa.innovamotionapp.databinding.StartActivityBinding;
-
-
-public class StartActivity extends AppCompatActivity {
-
-    // Used to load the 'innovamotionapp' library on application startup.
-//    static {
-//        System.loadLibrary("innovamotionapp");
-//    }
-
-    private StartActivityBinding binding;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        binding = StartActivityBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-    }
-
-    public void mainActivity(View view) {
-        Intent i = new Intent(this, MainActivity.class);
-        startActivity(i);
-    }
-
+package com.melisa.innovamotionapp.activities;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+
+import androidx.appcompat.app.AppCompatActivity;
+
+import com.melisa.innovamotionapp.databinding.StartActivityBinding;
+
+
+public class StartActivity extends AppCompatActivity {
+
+    // Used to load the 'innovamotionapp' library on application startup.
+//    static {
+//        System.loadLibrary("innovamotionapp");
+//    }
+
+    private StartActivityBinding binding;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        binding = StartActivityBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+    }
+
+    public void mainActivity(View view) {
+        Intent i = new Intent(this, MainActivity.class);
+        startActivity(i);
+    }
+
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StatisticsActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StatisticsActivity.java
index 509f3b2..766e421 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StatisticsActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/StatisticsActivity.java
@@ -1,355 +1,355 @@
-package com.melisa.innovamotionapp.activities;
-
-import static android.content.ContentValues.TAG;
-
-import android.content.res.Configuration;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Color;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.util.Log;
-import android.widget.Toast;
-
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.core.util.Pair;
-import androidx.lifecycle.ViewModelProvider;
-
-import com.github.mikephil.charting.charts.PieChart;
-import com.github.mikephil.charting.components.Legend;
-import com.github.mikephil.charting.data.PieData;
-import com.github.mikephil.charting.data.PieDataSet;
-import com.github.mikephil.charting.data.PieEntry;
-import com.github.mikephil.charting.formatter.PercentFormatter;
-import com.github.mikephil.charting.utils.ColorTemplate;
-import com.github.mikephil.charting.utils.MPPointF;
-import com.github.mikephil.charting.utils.ViewPortHandler;
-import com.google.android.material.datepicker.MaterialDatePicker;
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.data.posture.Posture;
-import com.melisa.innovamotionapp.data.posture.PostureFactory;
-import com.melisa.innovamotionapp.databinding.StatisticsActivityBinding;
-import com.melisa.innovamotionapp.ui.viewmodels.StatisticsViewModel;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.TargetUserResolver;
-import com.melisa.innovamotionapp.sync.UserSession;
-
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-
-/**
- * Activity for displaying posture statistics in a pie chart.
- * 
- * Supports two modes:
- * 1. User-based filtering: Shows data for the current user
- * 2. Sensor-based filtering: Shows data for a specific sensor (via intent extras)
- */
-public class StatisticsActivity extends AppCompatActivity {
-    
-    // Intent extras for sensor-specific viewing
-    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
-    public static final String EXTRA_PERSON_NAME = "extra_person_name";
-    
-    private StatisticsActivityBinding binding;
-    private final GlobalData globalData = GlobalData.getInstance();
-    private long startDate;
-    private long endDate;
-    private InnovaDatabase database;
-    private StatisticsViewModel viewModel;
-    private boolean showDefaultData = true;
-    
-    // Sensor-specific fields
-    private String sensorId;
-    private String personName;
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        binding = StatisticsActivityBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-
-        // Init database with current context
-        database = InnovaDatabase.getInstance(this);
-
-        // Initialize ViewModel
-        viewModel = new ViewModelProvider(this).get(StatisticsViewModel.class);
-
-        // Extract intent extras
-        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
-        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
-
-        // Setting click listener for the date picker button
-        binding.dateRangePickerButton.setOnClickListener(view -> datePickerDialog());
-        
-        // Choose filtering mode based on whether sensorId is provided
-        if (sensorId != null && !sensorId.isEmpty()) {
-            // Sensor-specific mode: Show data for this sensor only
-            Log.i("UI/Stats", "Sensor-specific mode: sensorId=" + sensorId + ", name=" + personName);
-            viewModel.setSensorId(sensorId);
-        } else {
-            // User-based mode: Resolve and set target user once session is loaded
-            if (UserSession.getInstance(getApplicationContext()).isLoaded()) {
-                String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
-                viewModel.setTargetUserId(target);
-            } else {
-                UserSession.getInstance(getApplicationContext()).loadUserSession(new UserSession.SessionLoadCallback() {
-                    @Override
-                    public void onSessionLoaded(String userId, String role, java.util.List<String> supervisedUserIds) {
-                        String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
-                        viewModel.setTargetUserId(target);
-                    }
-
-                    @Override
-                    public void onSessionLoadError(String error) {
-                        android.util.Log.w("UI/Stats", "Session load error: " + error);
-                    }
-                });
-            }
-        }
-
-        viewModel.getAllForUser().observe(this, list -> {
-            if (showDefaultData) {
-                Log.i("UI/Stats", "listSize=" + (list != null ? list.size() : 0));
-                if (list != null && !list.isEmpty()) {
-                    startDate = list.get(0).getTimestamp();
-                    endDate = list.get(list.size() - 1).getTimestamp();
-                    ReceivedBtDataEntity last = list.get(list.size() - 1);
-                    Log.d("UI/Stats", "last ts=" + last.getTimestamp() + " msg=" + last.getReceivedMsg());
-                    updateWithDateRange(startDate, endDate);
-                    onSavedDataChange(list);
-                }
-            }
-        });
-
-    }
-
-    // Method to load, rescale and apply transparency
-    public Drawable createRescaledDrawable(int resourceId, int newSizeX, int newSizeY) {
-        // Load the image from resources as a Bitmap
-        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resourceId);
-
-        // Rescale the Bitmap based on the rescale factor
-        Bitmap scaledBitmap = Bitmap.createScaledBitmap(bitmap, newSizeX, newSizeY, false);
-
-        // Release memory from the original bitmap as it is no longer needed
-        bitmap.recycle();
-
-        // Convert the rescaled Bitmap to Drawable
-        BitmapDrawable drawable = new BitmapDrawable(getResources(), scaledBitmap);
-
-        return drawable;
-    }
-
-    // Method to load, rescale and apply transparency
-    public Drawable createRescaledDrawable(int resourceId, float rescaleFactor, int alphaValue) {
-        // Load the image from resources as a Bitmap
-        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resourceId);
-
-        // Rescale the Bitmap based on the rescale factor
-        Bitmap scaledBitmap = Bitmap.createScaledBitmap(bitmap,
-                (int) (bitmap.getWidth() * rescaleFactor),
-                (int) (bitmap.getHeight() * rescaleFactor),
-                false);
-
-        // Release memory from the original bitmap as it is no longer needed
-        bitmap.recycle();
-
-        // Convert the rescaled Bitmap to Drawable
-        BitmapDrawable drawable = new BitmapDrawable(getResources(), scaledBitmap);
-
-        // Apply transparency by setting the alpha value
-        drawable.setAlpha(alphaValue); // 0 is fully transparent, 255 is fully opaque
-
-        return drawable;
-    }
-
-    private void createPieChart(List<Posture> postureListInDateRange) {
-
-        PieChart pieChart = binding.pieChart;
-
-        Legend legend = pieChart.getLegend();
-        legend.setEnabled(true);
-        legend.setWordWrapEnabled(true);
-        legend.setFormSize(10f); // set the size of the legend forms/shapes
-        legend.setForm(Legend.LegendForm.CIRCLE); // set what type of form/shape should be used
-        legend.setTextSize(12f);
-        legend.setXEntrySpace(5f); // space between the legend entries on the x-axis
-        legend.setYEntrySpace(5f); // space between the legend entries on the y-axis
-
-        ArrayList<PieEntry> entries = addDataToPieChart(postureListInDateRange);
-        if (!entries.isEmpty()) {
-            PieDataSet dataSet = new PieDataSet(entries, "");
-            dataSet.setColors(ColorTemplate.VORDIPLOM_COLORS);
-            dataSet.setValueTextSize(20f);
-
-            dataSet.setYValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);
-            dataSet.setValueFormatter(new PercentFormatter());
-//            dataSet.setSliceSpace(5f);
-            PieData data = new PieData(dataSet);
-            dataSet.setSelectionShift(10);
-            dataSet.setIconsOffset(new MPPointF(0, 20));
-            pieChart.setData(data);
-
-            switch (getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK) {
-
-                case Configuration.UI_MODE_NIGHT_YES:
-                    dataSet.setValueTextColor(Color.WHITE);
-                    legend.setTextColor(Color.WHITE);
-                    break;
-                case Configuration.UI_MODE_NIGHT_NO:
-                    break;
-            }
-        } else {
-            // Remove previous dataSet if postureListInDateRange is empty
-            pieChart.clear();
-        }
-
-        // Disable labels on the chart slices (labels won't appear on the slices)
-        pieChart.setDrawSliceText(false);
-        ViewPortHandler handler = pieChart.getViewPortHandler();
-
-        // Styling
-        pieChart.getDescription().setEnabled(false); // Disable the description text
-
-        float y = 10f;
-        pieChart.setDrawHoleEnabled(true);
-        pieChart.setHoleRadius(y);
-
-        pieChart.invalidate(); // Refresh chart
-    }
-
-    /**
-     * @noinspection DataFlowIssue
-     */
-    private ArrayList<PieEntry> addDataToPieChart(List<Posture> postureListInDateRange) {
-        // Count occurrences of each posture type
-        Map<String, Integer> postureCountMap = new HashMap<>();
-        Map<String, Integer> postureResourceMap = new HashMap<>(); // To store resource codes for each posture type
-        for (Posture posture : postureListInDateRange) {
-            String postureType = posture.getClass().getSimpleName(); // Assuming each posture has a distinct class
-            postureCountMap.compute(postureType, (key, currentValue) -> (currentValue == null ? 0 : currentValue) + 1);
-            postureResourceMap.put(postureType, posture.getPictureCode()); // Save resource code
-        }
-
-        int totalPostures = postureListInDateRange.size();
-        ArrayList<PieEntry> pieEntries = new ArrayList<>();
-        float sizeMultiplier = 2;
-        int newSizeX = (int) (75 * sizeMultiplier);
-        int newSizeY = (int) (94 * sizeMultiplier);
-
-        for (Map.Entry<String, Integer> entry : postureCountMap.entrySet()) {
-            String postureType = entry.getKey();
-            int count = entry.getValue();
-            // Calculate percentages
-            float percentage = ((float) count / totalPostures) * 100;
-            // Fetch the resource code for this posture type
-            int resourceCode = postureResourceMap.get(postureType);
-            // Add a PieEntry with the percentage and corresponding label
-            pieEntries.add(new PieEntry(percentage, postureType, createRescaledDrawable(resourceCode, newSizeX, newSizeY)));
-        }
-
-        return pieEntries;
-    }
-
-    private void datePickerDialog() {
-
-        // Creating a MaterialDatePicker builder for selecting a date range
-        MaterialDatePicker.Builder<Pair<Long, Long>> builder = MaterialDatePicker.Builder.dateRangePicker();
-        builder.setTitleText("Select a date range");
-
-        // Building the date picker dialog
-        MaterialDatePicker<Pair<Long, Long>> datePicker = builder.build();
-        datePicker.addOnPositiveButtonClickListener(selection -> {
-            // Adjust startDate to the first time (00:00:00) of the selected date
-            long startDateProcessed  = adjustToStartOfDay(selection.first);
-            // Adjust endDate to the latest time (23:59:59) of the selected date
-            long endDateProcessed  = adjustToEndOfDay(selection.second);
-
-            updateWithDateRange(startDateProcessed, endDateProcessed);
-            // Disable default behaviour
-            showDefaultData = false;
-
-            // Remove any existing observer before adding a new one
-            viewModel.getRangeForUser(startDate, endDate).removeObservers(this);
-            // RANGE
-            viewModel.getRangeForUser(startDate, endDate).observe(this, list -> {
-                if (!showDefaultData) {
-                    Log.i("UI/Stats", "range listSize=" + (list != null ? list.size() : 0));
-                    if (list != null && !list.isEmpty()) {
-                        ReceivedBtDataEntity last = list.get(list.size() - 1);
-                        Log.d("UI/Stats", "range last ts=" + last.getTimestamp() + " msg=" + last.getReceivedMsg());
-                    }
-                    onSavedDataChange(list);
-                }
-            });
-
-        });
-
-        // Showing the date picker dialog
-        datePicker.show(getSupportFragmentManager(), "DATE_PICKER");
-    }
-
-    private long adjustToStartOfDay(long timestamp) {
-        Calendar calendar = Calendar.getInstance();
-        calendar.setTimeInMillis(timestamp);
-        calendar.set(Calendar.HOUR_OF_DAY, 0);
-        calendar.set(Calendar.MINUTE, 0);
-        calendar.set(Calendar.SECOND, 0);
-        calendar.set(Calendar.MILLISECOND, 0); // Optional for precision
-        return calendar.getTimeInMillis();
-    }
-
-    private long adjustToEndOfDay(long timestamp) {
-        Calendar calendar = Calendar.getInstance();
-        calendar.setTimeInMillis(timestamp);
-        calendar.set(Calendar.HOUR_OF_DAY, 23);
-        calendar.set(Calendar.MINUTE, 59);
-        calendar.set(Calendar.SECOND, 59);
-        calendar.set(Calendar.MILLISECOND, 999); // Optional for precision
-        return calendar.getTimeInMillis();
-    }
-
-    private void updateWithDateRange(long selectedStartDate, long selectedEndDate) {
-        // Retrieving the selected start and end dates
-        startDate = selectedStartDate;
-        endDate = selectedEndDate;
-
-
-        // Format both date and time (dd/MM/yyyy HH:mm:ss)
-        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
-        String startDateString = sdf.format(new Date(startDate));
-        String endDateString = sdf.format(new Date(endDate));
-
-        // Creating the date range string
-        String selectedDateRange = startDateString + " - " + endDateString;
-
-        // Displaying the selected date range in the TextView
-        binding.selectedDateRange.setText(selectedDateRange);
-        createPieChart(new ArrayList<>());
-    }
-
-    public void log(String msg) {
-        Log.d(TAG, msg);
-        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
-    }
-
-    private void onSavedDataChange(List<ReceivedBtDataEntity> receivedBtDataEntities) {
-        // Convert entities to postures
-        List<Posture> postureListInDateRange = new ArrayList<>();
-        for (ReceivedBtDataEntity entity : receivedBtDataEntities) {
-            postureListInDateRange.add(PostureFactory.createPosture(entity.getReceivedMsg()));
-        }
-        // Update the pie chart
-        createPieChart(postureListInDateRange);
-    }
-}
+package com.melisa.innovamotionapp.activities;
+
+import static android.content.ContentValues.TAG;
+
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Color;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.util.Log;
+import android.widget.Toast;
+
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.util.Pair;
+import androidx.lifecycle.ViewModelProvider;
+
+import com.github.mikephil.charting.charts.PieChart;
+import com.github.mikephil.charting.components.Legend;
+import com.github.mikephil.charting.data.PieData;
+import com.github.mikephil.charting.data.PieDataSet;
+import com.github.mikephil.charting.data.PieEntry;
+import com.github.mikephil.charting.formatter.PercentFormatter;
+import com.github.mikephil.charting.utils.ColorTemplate;
+import com.github.mikephil.charting.utils.MPPointF;
+import com.github.mikephil.charting.utils.ViewPortHandler;
+import com.google.android.material.datepicker.MaterialDatePicker;
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.data.posture.Posture;
+import com.melisa.innovamotionapp.data.posture.PostureFactory;
+import com.melisa.innovamotionapp.databinding.StatisticsActivityBinding;
+import com.melisa.innovamotionapp.ui.viewmodels.StatisticsViewModel;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.TargetUserResolver;
+import com.melisa.innovamotionapp.sync.UserSession;
+
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+
+/**
+ * Activity for displaying posture statistics in a pie chart.
+ * 
+ * Supports two modes:
+ * 1. User-based filtering: Shows data for the current user
+ * 2. Sensor-based filtering: Shows data for a specific sensor (via intent extras)
+ */
+public class StatisticsActivity extends AppCompatActivity {
+    
+    // Intent extras for sensor-specific viewing
+    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
+    public static final String EXTRA_PERSON_NAME = "extra_person_name";
+    
+    private StatisticsActivityBinding binding;
+    private final GlobalData globalData = GlobalData.getInstance();
+    private long startDate;
+    private long endDate;
+    private InnovaDatabase database;
+    private StatisticsViewModel viewModel;
+    private boolean showDefaultData = true;
+    
+    // Sensor-specific fields
+    private String sensorId;
+    private String personName;
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        binding = StatisticsActivityBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        // Init database with current context
+        database = InnovaDatabase.getInstance(this);
+
+        // Initialize ViewModel
+        viewModel = new ViewModelProvider(this).get(StatisticsViewModel.class);
+
+        // Extract intent extras
+        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
+        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
+
+        // Setting click listener for the date picker button
+        binding.dateRangePickerButton.setOnClickListener(view -> datePickerDialog());
+        
+        // Choose filtering mode based on whether sensorId is provided
+        if (sensorId != null && !sensorId.isEmpty()) {
+            // Sensor-specific mode: Show data for this sensor only
+            Log.i("UI/Stats", "Sensor-specific mode: sensorId=" + sensorId + ", name=" + personName);
+            viewModel.setSensorId(sensorId);
+        } else {
+            // User-based mode: Resolve and set target user once session is loaded
+            if (UserSession.getInstance(getApplicationContext()).isLoaded()) {
+                String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
+                viewModel.setTargetUserId(target);
+            } else {
+                UserSession.getInstance(getApplicationContext()).loadUserSession(new UserSession.SessionLoadCallback() {
+                    @Override
+                    public void onSessionLoaded(String userId, String role, java.util.List<String> supervisedUserIds) {
+                        String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
+                        viewModel.setTargetUserId(target);
+                    }
+
+                    @Override
+                    public void onSessionLoadError(String error) {
+                        android.util.Log.w("UI/Stats", "Session load error: " + error);
+                    }
+                });
+            }
+        }
+
+        viewModel.getAllForUser().observe(this, list -> {
+            if (showDefaultData) {
+                Log.i("UI/Stats", "listSize=" + (list != null ? list.size() : 0));
+                if (list != null && !list.isEmpty()) {
+                    startDate = list.get(0).getTimestamp();
+                    endDate = list.get(list.size() - 1).getTimestamp();
+                    ReceivedBtDataEntity last = list.get(list.size() - 1);
+                    Log.d("UI/Stats", "last ts=" + last.getTimestamp() + " msg=" + last.getReceivedMsg());
+                    updateWithDateRange(startDate, endDate);
+                    onSavedDataChange(list);
+                }
+            }
+        });
+
+    }
+
+    // Method to load, rescale and apply transparency
+    public Drawable createRescaledDrawable(int resourceId, int newSizeX, int newSizeY) {
+        // Load the image from resources as a Bitmap
+        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resourceId);
+
+        // Rescale the Bitmap based on the rescale factor
+        Bitmap scaledBitmap = Bitmap.createScaledBitmap(bitmap, newSizeX, newSizeY, false);
+
+        // Release memory from the original bitmap as it is no longer needed
+        bitmap.recycle();
+
+        // Convert the rescaled Bitmap to Drawable
+        BitmapDrawable drawable = new BitmapDrawable(getResources(), scaledBitmap);
+
+        return drawable;
+    }
+
+    // Method to load, rescale and apply transparency
+    public Drawable createRescaledDrawable(int resourceId, float rescaleFactor, int alphaValue) {
+        // Load the image from resources as a Bitmap
+        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), resourceId);
+
+        // Rescale the Bitmap based on the rescale factor
+        Bitmap scaledBitmap = Bitmap.createScaledBitmap(bitmap,
+                (int) (bitmap.getWidth() * rescaleFactor),
+                (int) (bitmap.getHeight() * rescaleFactor),
+                false);
+
+        // Release memory from the original bitmap as it is no longer needed
+        bitmap.recycle();
+
+        // Convert the rescaled Bitmap to Drawable
+        BitmapDrawable drawable = new BitmapDrawable(getResources(), scaledBitmap);
+
+        // Apply transparency by setting the alpha value
+        drawable.setAlpha(alphaValue); // 0 is fully transparent, 255 is fully opaque
+
+        return drawable;
+    }
+
+    private void createPieChart(List<Posture> postureListInDateRange) {
+
+        PieChart pieChart = binding.pieChart;
+
+        Legend legend = pieChart.getLegend();
+        legend.setEnabled(true);
+        legend.setWordWrapEnabled(true);
+        legend.setFormSize(10f); // set the size of the legend forms/shapes
+        legend.setForm(Legend.LegendForm.CIRCLE); // set what type of form/shape should be used
+        legend.setTextSize(12f);
+        legend.setXEntrySpace(5f); // space between the legend entries on the x-axis
+        legend.setYEntrySpace(5f); // space between the legend entries on the y-axis
+
+        ArrayList<PieEntry> entries = addDataToPieChart(postureListInDateRange);
+        if (!entries.isEmpty()) {
+            PieDataSet dataSet = new PieDataSet(entries, "");
+            dataSet.setColors(ColorTemplate.VORDIPLOM_COLORS);
+            dataSet.setValueTextSize(20f);
+
+            dataSet.setYValuePosition(PieDataSet.ValuePosition.OUTSIDE_SLICE);
+            dataSet.setValueFormatter(new PercentFormatter());
+//            dataSet.setSliceSpace(5f);
+            PieData data = new PieData(dataSet);
+            dataSet.setSelectionShift(10);
+            dataSet.setIconsOffset(new MPPointF(0, 20));
+            pieChart.setData(data);
+
+            switch (getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK) {
+
+                case Configuration.UI_MODE_NIGHT_YES:
+                    dataSet.setValueTextColor(Color.WHITE);
+                    legend.setTextColor(Color.WHITE);
+                    break;
+                case Configuration.UI_MODE_NIGHT_NO:
+                    break;
+            }
+        } else {
+            // Remove previous dataSet if postureListInDateRange is empty
+            pieChart.clear();
+        }
+
+        // Disable labels on the chart slices (labels won't appear on the slices)
+        pieChart.setDrawSliceText(false);
+        ViewPortHandler handler = pieChart.getViewPortHandler();
+
+        // Styling
+        pieChart.getDescription().setEnabled(false); // Disable the description text
+
+        float y = 10f;
+        pieChart.setDrawHoleEnabled(true);
+        pieChart.setHoleRadius(y);
+
+        pieChart.invalidate(); // Refresh chart
+    }
+
+    /**
+     * @noinspection DataFlowIssue
+     */
+    private ArrayList<PieEntry> addDataToPieChart(List<Posture> postureListInDateRange) {
+        // Count occurrences of each posture type
+        Map<String, Integer> postureCountMap = new HashMap<>();
+        Map<String, Integer> postureResourceMap = new HashMap<>(); // To store resource codes for each posture type
+        for (Posture posture : postureListInDateRange) {
+            String postureType = posture.getClass().getSimpleName(); // Assuming each posture has a distinct class
+            postureCountMap.compute(postureType, (key, currentValue) -> (currentValue == null ? 0 : currentValue) + 1);
+            postureResourceMap.put(postureType, posture.getPictureCode()); // Save resource code
+        }
+
+        int totalPostures = postureListInDateRange.size();
+        ArrayList<PieEntry> pieEntries = new ArrayList<>();
+        float sizeMultiplier = 2;
+        int newSizeX = (int) (75 * sizeMultiplier);
+        int newSizeY = (int) (94 * sizeMultiplier);
+
+        for (Map.Entry<String, Integer> entry : postureCountMap.entrySet()) {
+            String postureType = entry.getKey();
+            int count = entry.getValue();
+            // Calculate percentages
+            float percentage = ((float) count / totalPostures) * 100;
+            // Fetch the resource code for this posture type
+            int resourceCode = postureResourceMap.get(postureType);
+            // Add a PieEntry with the percentage and corresponding label
+            pieEntries.add(new PieEntry(percentage, postureType, createRescaledDrawable(resourceCode, newSizeX, newSizeY)));
+        }
+
+        return pieEntries;
+    }
+
+    private void datePickerDialog() {
+
+        // Creating a MaterialDatePicker builder for selecting a date range
+        MaterialDatePicker.Builder<Pair<Long, Long>> builder = MaterialDatePicker.Builder.dateRangePicker();
+        builder.setTitleText("Select a date range");
+
+        // Building the date picker dialog
+        MaterialDatePicker<Pair<Long, Long>> datePicker = builder.build();
+        datePicker.addOnPositiveButtonClickListener(selection -> {
+            // Adjust startDate to the first time (00:00:00) of the selected date
+            long startDateProcessed  = adjustToStartOfDay(selection.first);
+            // Adjust endDate to the latest time (23:59:59) of the selected date
+            long endDateProcessed  = adjustToEndOfDay(selection.second);
+
+            updateWithDateRange(startDateProcessed, endDateProcessed);
+            // Disable default behaviour
+            showDefaultData = false;
+
+            // Remove any existing observer before adding a new one
+            viewModel.getRangeForUser(startDate, endDate).removeObservers(this);
+            // RANGE
+            viewModel.getRangeForUser(startDate, endDate).observe(this, list -> {
+                if (!showDefaultData) {
+                    Log.i("UI/Stats", "range listSize=" + (list != null ? list.size() : 0));
+                    if (list != null && !list.isEmpty()) {
+                        ReceivedBtDataEntity last = list.get(list.size() - 1);
+                        Log.d("UI/Stats", "range last ts=" + last.getTimestamp() + " msg=" + last.getReceivedMsg());
+                    }
+                    onSavedDataChange(list);
+                }
+            });
+
+        });
+
+        // Showing the date picker dialog
+        datePicker.show(getSupportFragmentManager(), "DATE_PICKER");
+    }
+
+    private long adjustToStartOfDay(long timestamp) {
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(timestamp);
+        calendar.set(Calendar.HOUR_OF_DAY, 0);
+        calendar.set(Calendar.MINUTE, 0);
+        calendar.set(Calendar.SECOND, 0);
+        calendar.set(Calendar.MILLISECOND, 0); // Optional for precision
+        return calendar.getTimeInMillis();
+    }
+
+    private long adjustToEndOfDay(long timestamp) {
+        Calendar calendar = Calendar.getInstance();
+        calendar.setTimeInMillis(timestamp);
+        calendar.set(Calendar.HOUR_OF_DAY, 23);
+        calendar.set(Calendar.MINUTE, 59);
+        calendar.set(Calendar.SECOND, 59);
+        calendar.set(Calendar.MILLISECOND, 999); // Optional for precision
+        return calendar.getTimeInMillis();
+    }
+
+    private void updateWithDateRange(long selectedStartDate, long selectedEndDate) {
+        // Retrieving the selected start and end dates
+        startDate = selectedStartDate;
+        endDate = selectedEndDate;
+
+
+        // Format both date and time (dd/MM/yyyy HH:mm:ss)
+        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
+        String startDateString = sdf.format(new Date(startDate));
+        String endDateString = sdf.format(new Date(endDate));
+
+        // Creating the date range string
+        String selectedDateRange = startDateString + " - " + endDateString;
+
+        // Displaying the selected date range in the TextView
+        binding.selectedDateRange.setText(selectedDateRange);
+        createPieChart(new ArrayList<>());
+    }
+
+    public void log(String msg) {
+        Log.d(TAG, msg);
+        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
+    }
+
+    private void onSavedDataChange(List<ReceivedBtDataEntity> receivedBtDataEntities) {
+        // Convert entities to postures
+        List<Posture> postureListInDateRange = new ArrayList<>();
+        for (ReceivedBtDataEntity entity : receivedBtDataEntities) {
+            postureListInDateRange.add(PostureFactory.createPosture(entity.getReceivedMsg()));
+        }
+        // Update the pie chart
+        createPieChart(postureListInDateRange);
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/TimeLapseActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/TimeLapseActivity.java
index 678baa3..4a3b2d3 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/TimeLapseActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/activities/TimeLapseActivity.java
@@ -1,267 +1,267 @@
-package com.melisa.innovamotionapp.activities;
-
-import android.graphics.BitmapFactory;
-import android.os.Bundle;
-import android.os.Handler;
-import android.util.Log;
-import android.widget.SeekBar;
-import android.widget.Toast;
-
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.lifecycle.ViewModelProvider;
-
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.data.posture.Posture;
-import com.melisa.innovamotionapp.data.posture.PostureFactory;
-import com.melisa.innovamotionapp.databinding.TimelapsActivityBinding;
-import com.melisa.innovamotionapp.ui.viewmodels.TimeLapseViewModel;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.TargetUserResolver;
-import com.melisa.innovamotionapp.sync.UserSession;
-
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-
-/**
- * Activity for displaying posture timelapse animation.
- * 
- * Supports two modes:
- * 1. User-based filtering: Shows data for the current user
- * 2. Sensor-based filtering: Shows data for a specific sensor (via intent extras)
- */
-public class TimeLapseActivity extends AppCompatActivity {
-    
-    // Intent extras for sensor-specific viewing
-    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
-    public static final String EXTRA_PERSON_NAME = "extra_person_name";
-    
-    private TimelapsActivityBinding binding;
-    private final GlobalData globalData = GlobalData.getInstance();
-
-
-    private List<Integer> imageIds; // List of image file paths or resource ids
-    private List<String> imageTimestamps; // List of timestamps for the images
-    private int currentIndex = 0; // Track the current image
-    private Handler handler = new Handler(); // To post delayed tasks
-    private Runnable showImageRunnable;
-    private boolean isRunning = false; // Control the playback state
-
-    private int interval = 1000; // Default interval (milliseconds) for showing each image
-    private int speed = 5; // Default speed (1 to 10)
-    private InnovaDatabase database;
-    private TimeLapseViewModel viewModel;
-
-    private boolean displayedOnce = false;
-    
-    // Sensor-specific fields
-    private String sensorId;
-    private String personName;
-
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        binding = TimelapsActivityBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-
-        // Init database with current context
-        database = InnovaDatabase.getInstance(this);
-
-        // Initialize ViewModel
-        viewModel = new ViewModelProvider(this).get(TimeLapseViewModel.class);
-
-
-        // Initialize image paths and timestamps (example)
-        imageIds = new ArrayList<>();
-        imageTimestamps = new ArrayList<>();
-
-        // Boolean init to display data only once
-        displayedOnce = false;
-
-        // Extract intent extras
-        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
-        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
-
-        // Choose filtering mode based on whether sensorId is provided
-        if (sensorId != null && !sensorId.isEmpty()) {
-            // Sensor-specific mode: Show data for this sensor only
-            Log.i("UI/TimeLapse", "Sensor-specific mode: sensorId=" + sensorId + ", name=" + personName);
-            viewModel.setSensorId(sensorId);
-        } else {
-            // User-based mode: Resolve and set target user once session is loaded
-            if (UserSession.getInstance(getApplicationContext()).isLoaded()) {
-                String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
-                Log.i("UI/TimeLapse", "Resolved targetUserId=" + target);
-                viewModel.setTargetUserId(target);
-            } else {
-                UserSession.getInstance(getApplicationContext()).loadUserSession(new UserSession.SessionLoadCallback() {
-                    @Override
-                    public void onSessionLoaded(String uid, String role, java.util.List<String> kids) {
-                        String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
-                        Log.i("UI/TimeLapse", "Resolved targetUserId=" + target);
-                        viewModel.setTargetUserId(target);
-                    }
-
-                    @Override
-                    public void onSessionLoadError(String error) {
-                        Log.w("UI/TimeLapse", "Session load error: " + error);
-                    }
-                });
-            }
-        }
-
-        // Observe target user's or sensor's saved postures
-        viewModel.getAllForUser().observe(this, list -> {
-            if (displayedOnce) {
-                return;
-            }
-            int size = (list != null ? list.size() : 0);
-            Log.i("UI/TimeLapse", "listSize=" + size);
-            if (list != null && !list.isEmpty()) {
-                // Boolean set to display data only once
-                displayedOnce = true;
-
-
-                // Display the savedData's dates interval
-                long startDate = list.get(0).getTimestamp(); // Set startDate as the timestamp of the first entry
-                long endDate = list.get(list.size() - 1).getTimestamp(); // Set endDate as the timestamp of the last entry
-                // Format both date and time (dd/MM/yyyy HH:mm:ss)
-                SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
-                String startDateString = sdf.format(new Date(startDate));
-                String endDateString = sdf.format(new Date(endDate));
-                // Creating the date range string
-                String selectedDateRange = startDateString + " - " + endDateString;
-                binding.selectedDateRange.setText(selectedDateRange);
-
-                // Add images and corresponding timestamps (this should come from your data)
-                for (ReceivedBtDataEntity receivedBtDataEntity : list) {
-                    // Add posture's picture
-                    Posture posture = PostureFactory.createPosture(receivedBtDataEntity.getReceivedMsg());
-
-                    // Save posture's picture
-                    imageIds.add(posture.getPictureCode());
-
-                    // Format posture's timestamp
-                    // Format both date and time (dd/MM/yyyy HH:mm:ss)
-                    String postureFormatedDate = sdf.format(new Date(receivedBtDataEntity.getTimestamp()));
-
-                    // Add posture's formated timestamp
-                    imageTimestamps.add(postureFormatedDate);
-                }
-                setupUi();
-
-                // Initialize with the first image
-                updateImageDisplay();
-            }
-        });
-
-        // Initialize with the first image
-        updateImageDisplay();
-    }
-
-    private void setupUi() {
-        // Set max value of SeekBar to the number of images
-        binding.seekBar.setMax(imageIds.size() - 1);
-
-        // Listener for SeekBar drag to navigate images
-        binding.seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-                if (fromUser) {
-                    currentIndex = progress;
-                    updateImageDisplay(); // Update the image display when dragged
-                }
-            }
-
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-            }
-
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-            }
-        });
-
-        // Speed SeekBar listener
-        binding.speedSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-                if (progress == 0) {
-                    progress = 1;
-                }
-                speed = progress;
-                binding.speedLabel.setText("Speed: " + speed);
-                interval = 1000 / speed; // Adjust interval based on speed
-            }
-
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-            }
-
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-            }
-        });
-
-        // Start button click listener
-        binding.startButton.setOnClickListener(v -> startTimeLapse());
-
-        // Stop button click listener
-        binding.stopButton.setOnClickListener(v -> stopTimeLapse());
-
-        // Runnable for showing images at intervals
-        showImageRunnable = new Runnable() {
-            @Override
-            public void run() {
-                if (currentIndex < imageIds.size()) {
-                    updateImageDisplay(); // Display the current image
-                    currentIndex++;
-                    binding.seekBar.setProgress(currentIndex); // Update SeekBar
-                    handler.postDelayed(this, interval); // Post next task
-                } else {
-                    stopTimeLapse(); // Stop at the end of the list
-                }
-            }
-        };
-    }
-
-    private void updateImageDisplay() {
-        if (currentIndex >= 0 && currentIndex < imageIds.size()) {
-            int imageId = imageIds.get(currentIndex);
-            String timestamp = imageTimestamps.get(currentIndex);
-
-            // Set the image and timestamp
-            binding.imageView.setImageBitmap(BitmapFactory.decodeResource(getResources(), imageId));
-            binding.photoTime.setText("Time: " + timestamp);
-        }
-    }
-
-    private void startTimeLapse() {
-        if (isRunning) {
-            Toast.makeText(this, "Time-lapse already running", Toast.LENGTH_SHORT).show();
-            return;
-        }
-
-        isRunning = true;
-        binding.startButton.setEnabled(false); // Disable start button when running
-        binding.stopButton.setEnabled(true);  // Enable stop button
-
-        // Start the time-lapse
-        handler.post(showImageRunnable);
-    }
-
-    private void stopTimeLapse() {
-        isRunning = false;
-        binding.startButton.setEnabled(true);
-        binding.stopButton.setEnabled(false);
-
-        // Stop the time-lapse
-        handler.removeCallbacks(showImageRunnable);
-        currentIndex = 0; // Reset to the first image
-    }
-
-}
+package com.melisa.innovamotionapp.activities;
+
+import android.graphics.BitmapFactory;
+import android.os.Bundle;
+import android.os.Handler;
+import android.util.Log;
+import android.widget.SeekBar;
+import android.widget.Toast;
+
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.lifecycle.ViewModelProvider;
+
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.data.posture.Posture;
+import com.melisa.innovamotionapp.data.posture.PostureFactory;
+import com.melisa.innovamotionapp.databinding.TimelapsActivityBinding;
+import com.melisa.innovamotionapp.ui.viewmodels.TimeLapseViewModel;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.TargetUserResolver;
+import com.melisa.innovamotionapp.sync.UserSession;
+
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Activity for displaying posture timelapse animation.
+ * 
+ * Supports two modes:
+ * 1. User-based filtering: Shows data for the current user
+ * 2. Sensor-based filtering: Shows data for a specific sensor (via intent extras)
+ */
+public class TimeLapseActivity extends AppCompatActivity {
+    
+    // Intent extras for sensor-specific viewing
+    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
+    public static final String EXTRA_PERSON_NAME = "extra_person_name";
+    
+    private TimelapsActivityBinding binding;
+    private final GlobalData globalData = GlobalData.getInstance();
+
+
+    private List<Integer> imageIds; // List of image file paths or resource ids
+    private List<String> imageTimestamps; // List of timestamps for the images
+    private int currentIndex = 0; // Track the current image
+    private Handler handler = new Handler(); // To post delayed tasks
+    private Runnable showImageRunnable;
+    private boolean isRunning = false; // Control the playback state
+
+    private int interval = 1000; // Default interval (milliseconds) for showing each image
+    private int speed = 5; // Default speed (1 to 10)
+    private InnovaDatabase database;
+    private TimeLapseViewModel viewModel;
+
+    private boolean displayedOnce = false;
+    
+    // Sensor-specific fields
+    private String sensorId;
+    private String personName;
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        binding = TimelapsActivityBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        // Init database with current context
+        database = InnovaDatabase.getInstance(this);
+
+        // Initialize ViewModel
+        viewModel = new ViewModelProvider(this).get(TimeLapseViewModel.class);
+
+
+        // Initialize image paths and timestamps (example)
+        imageIds = new ArrayList<>();
+        imageTimestamps = new ArrayList<>();
+
+        // Boolean init to display data only once
+        displayedOnce = false;
+
+        // Extract intent extras
+        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
+        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
+
+        // Choose filtering mode based on whether sensorId is provided
+        if (sensorId != null && !sensorId.isEmpty()) {
+            // Sensor-specific mode: Show data for this sensor only
+            Log.i("UI/TimeLapse", "Sensor-specific mode: sensorId=" + sensorId + ", name=" + personName);
+            viewModel.setSensorId(sensorId);
+        } else {
+            // User-based mode: Resolve and set target user once session is loaded
+            if (UserSession.getInstance(getApplicationContext()).isLoaded()) {
+                String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
+                Log.i("UI/TimeLapse", "Resolved targetUserId=" + target);
+                viewModel.setTargetUserId(target);
+            } else {
+                UserSession.getInstance(getApplicationContext()).loadUserSession(new UserSession.SessionLoadCallback() {
+                    @Override
+                    public void onSessionLoaded(String uid, String role, java.util.List<String> kids) {
+                        String target = TargetUserResolver.resolveTargetUserId(getApplicationContext());
+                        Log.i("UI/TimeLapse", "Resolved targetUserId=" + target);
+                        viewModel.setTargetUserId(target);
+                    }
+
+                    @Override
+                    public void onSessionLoadError(String error) {
+                        Log.w("UI/TimeLapse", "Session load error: " + error);
+                    }
+                });
+            }
+        }
+
+        // Observe target user's or sensor's saved postures
+        viewModel.getAllForUser().observe(this, list -> {
+            if (displayedOnce) {
+                return;
+            }
+            int size = (list != null ? list.size() : 0);
+            Log.i("UI/TimeLapse", "listSize=" + size);
+            if (list != null && !list.isEmpty()) {
+                // Boolean set to display data only once
+                displayedOnce = true;
+
+
+                // Display the savedData's dates interval
+                long startDate = list.get(0).getTimestamp(); // Set startDate as the timestamp of the first entry
+                long endDate = list.get(list.size() - 1).getTimestamp(); // Set endDate as the timestamp of the last entry
+                // Format both date and time (dd/MM/yyyy HH:mm:ss)
+                SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss", Locale.getDefault());
+                String startDateString = sdf.format(new Date(startDate));
+                String endDateString = sdf.format(new Date(endDate));
+                // Creating the date range string
+                String selectedDateRange = startDateString + " - " + endDateString;
+                binding.selectedDateRange.setText(selectedDateRange);
+
+                // Add images and corresponding timestamps (this should come from your data)
+                for (ReceivedBtDataEntity receivedBtDataEntity : list) {
+                    // Add posture's picture
+                    Posture posture = PostureFactory.createPosture(receivedBtDataEntity.getReceivedMsg());
+
+                    // Save posture's picture
+                    imageIds.add(posture.getPictureCode());
+
+                    // Format posture's timestamp
+                    // Format both date and time (dd/MM/yyyy HH:mm:ss)
+                    String postureFormatedDate = sdf.format(new Date(receivedBtDataEntity.getTimestamp()));
+
+                    // Add posture's formated timestamp
+                    imageTimestamps.add(postureFormatedDate);
+                }
+                setupUi();
+
+                // Initialize with the first image
+                updateImageDisplay();
+            }
+        });
+
+        // Initialize with the first image
+        updateImageDisplay();
+    }
+
+    private void setupUi() {
+        // Set max value of SeekBar to the number of images
+        binding.seekBar.setMax(imageIds.size() - 1);
+
+        // Listener for SeekBar drag to navigate images
+        binding.seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+            @Override
+            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+                if (fromUser) {
+                    currentIndex = progress;
+                    updateImageDisplay(); // Update the image display when dragged
+                }
+            }
+
+            @Override
+            public void onStartTrackingTouch(SeekBar seekBar) {
+            }
+
+            @Override
+            public void onStopTrackingTouch(SeekBar seekBar) {
+            }
+        });
+
+        // Speed SeekBar listener
+        binding.speedSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+            @Override
+            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+                if (progress == 0) {
+                    progress = 1;
+                }
+                speed = progress;
+                binding.speedLabel.setText("Speed: " + speed);
+                interval = 1000 / speed; // Adjust interval based on speed
+            }
+
+            @Override
+            public void onStartTrackingTouch(SeekBar seekBar) {
+            }
+
+            @Override
+            public void onStopTrackingTouch(SeekBar seekBar) {
+            }
+        });
+
+        // Start button click listener
+        binding.startButton.setOnClickListener(v -> startTimeLapse());
+
+        // Stop button click listener
+        binding.stopButton.setOnClickListener(v -> stopTimeLapse());
+
+        // Runnable for showing images at intervals
+        showImageRunnable = new Runnable() {
+            @Override
+            public void run() {
+                if (currentIndex < imageIds.size()) {
+                    updateImageDisplay(); // Display the current image
+                    currentIndex++;
+                    binding.seekBar.setProgress(currentIndex); // Update SeekBar
+                    handler.postDelayed(this, interval); // Post next task
+                } else {
+                    stopTimeLapse(); // Stop at the end of the list
+                }
+            }
+        };
+    }
+
+    private void updateImageDisplay() {
+        if (currentIndex >= 0 && currentIndex < imageIds.size()) {
+            int imageId = imageIds.get(currentIndex);
+            String timestamp = imageTimestamps.get(currentIndex);
+
+            // Set the image and timestamp
+            binding.imageView.setImageBitmap(BitmapFactory.decodeResource(getResources(), imageId));
+            binding.photoTime.setText("Time: " + timestamp);
+        }
+    }
+
+    private void startTimeLapse() {
+        if (isRunning) {
+            Toast.makeText(this, "Time-lapse already running", Toast.LENGTH_SHORT).show();
+            return;
+        }
+
+        isRunning = true;
+        binding.startButton.setEnabled(false); // Disable start button when running
+        binding.stopButton.setEnabled(true);  // Enable stop button
+
+        // Start the time-lapse
+        handler.post(showImageRunnable);
+    }
+
+    private void stopTimeLapse() {
+        isRunning = false;
+        binding.startButton.setEnabled(true);
+        binding.stopButton.setEnabled(false);
+
+        // Stop the time-lapse
+        handler.removeCallbacks(showImageRunnable);
+        currentIndex = 0; // Reset to the first image
+    }
+
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationManager.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationManager.java
index 9818235..94185a6 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationManager.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationManager.java
@@ -1,97 +1,97 @@
-package com.melisa.innovamotionapp.bluetooth;
-
-import android.bluetooth.BluetoothDevice;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.os.IBinder;
-
-import androidx.core.content.ContextCompat;
-
-public class DeviceCommunicationManager {
-    private final Context context;
-    private DeviceCommunicationService deviceCommunicationService;
-
-    public BluetoothDevice getDeviceToConnect() {
-        return deviceToConnect;
-    }
-
-    private BluetoothDevice deviceToConnect; // Store the device to connect
-    private ServiceConnection serviceConnection = new ServiceConnection() {
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-            DeviceCommunicationService.LocalBinder binder = (DeviceCommunicationService.LocalBinder) service;
-            deviceCommunicationService = binder.getService();
-
-
-            // Inform the service to connect to the device
-            deviceCommunicationService.connectToDevice(deviceToConnect);
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-            deviceCommunicationService = null;
-        }
-    };
-
-    public DeviceCommunicationManager(Context context) {
-        this.context = context;
-    }
-
-
-    /**
-     * Start the service and connect to a Bluetooth device.
-     */
-    public void connectDevice(BluetoothDevice device) {
-        // Store the device
-        deviceToConnect = device;
-
-        // Start the service if it's not running yet
-
-        if (deviceCommunicationService == null) {
-            // Create an Intent to start the service
-            Intent serviceIntent = new Intent(context, DeviceCommunicationService.class);
-            // Start the service
-            ContextCompat.startForegroundService(context, serviceIntent);
-            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE);
-        }
-
-        // Connection will be initiated in onServiceConnected()
-    }
-
-    /**
-     * Disconnect the currently connected device and stop the service if no devices are connected.
-     */
-    public void disconnectDevice() {
-        if (deviceCommunicationService != null) {
-            deviceCommunicationService.disconnectDevice();
-        }
-
-        // Optionally stop the service if no device is connected
-        if (!isDeviceConnected()) {
-            stopService();
-        }
-    }
-
-    /**
-     * Check if the current device is connected.
-     *
-     * @return true if a device is connected, false otherwise.
-     */
-    public boolean isDeviceConnected() {
-        return deviceCommunicationService != null && deviceCommunicationService.isDeviceConnected();
-    }
-
-    /**
-     * Stop the service when no device is connected.
-     */
-    public void stopService() {
-        if (deviceCommunicationService != null) {
-            Intent serviceIntent = new Intent(context, DeviceCommunicationService.class);
-            context.unbindService(serviceConnection);
-            context.stopService(serviceIntent);
-            deviceCommunicationService = null;
-        }
-    }
-}
+package com.melisa.innovamotionapp.bluetooth;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+
+import androidx.core.content.ContextCompat;
+
+public class DeviceCommunicationManager {
+    private final Context context;
+    private DeviceCommunicationService deviceCommunicationService;
+
+    public BluetoothDevice getDeviceToConnect() {
+        return deviceToConnect;
+    }
+
+    private BluetoothDevice deviceToConnect; // Store the device to connect
+    private ServiceConnection serviceConnection = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder service) {
+            DeviceCommunicationService.LocalBinder binder = (DeviceCommunicationService.LocalBinder) service;
+            deviceCommunicationService = binder.getService();
+
+
+            // Inform the service to connect to the device
+            deviceCommunicationService.connectToDevice(deviceToConnect);
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            deviceCommunicationService = null;
+        }
+    };
+
+    public DeviceCommunicationManager(Context context) {
+        this.context = context;
+    }
+
+
+    /**
+     * Start the service and connect to a Bluetooth device.
+     */
+    public void connectDevice(BluetoothDevice device) {
+        // Store the device
+        deviceToConnect = device;
+
+        // Start the service if it's not running yet
+
+        if (deviceCommunicationService == null) {
+            // Create an Intent to start the service
+            Intent serviceIntent = new Intent(context, DeviceCommunicationService.class);
+            // Start the service
+            ContextCompat.startForegroundService(context, serviceIntent);
+            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE);
+        }
+
+        // Connection will be initiated in onServiceConnected()
+    }
+
+    /**
+     * Disconnect the currently connected device and stop the service if no devices are connected.
+     */
+    public void disconnectDevice() {
+        if (deviceCommunicationService != null) {
+            deviceCommunicationService.disconnectDevice();
+        }
+
+        // Optionally stop the service if no device is connected
+        if (!isDeviceConnected()) {
+            stopService();
+        }
+    }
+
+    /**
+     * Check if the current device is connected.
+     *
+     * @return true if a device is connected, false otherwise.
+     */
+    public boolean isDeviceConnected() {
+        return deviceCommunicationService != null && deviceCommunicationService.isDeviceConnected();
+    }
+
+    /**
+     * Stop the service when no device is connected.
+     */
+    public void stopService() {
+        if (deviceCommunicationService != null) {
+            Intent serviceIntent = new Intent(context, DeviceCommunicationService.class);
+            context.unbindService(serviceConnection);
+            context.stopService(serviceIntent);
+            deviceCommunicationService = null;
+        }
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java
index 29628a3..5f067ec 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java
@@ -1,356 +1,356 @@
-package com.melisa.innovamotionapp.bluetooth;
-
-import static android.content.ContentValues.TAG;
-
-import android.annotation.SuppressLint;
-import android.app.Notification;
-import android.app.NotificationChannel;
-import android.app.NotificationManager;
-import android.app.Service;
-import android.bluetooth.BluetoothDevice;
-import android.content.Intent;
-import android.os.Binder;
-import android.os.IBinder;
-import android.util.Log;
-
-import androidx.core.app.NotificationCompat;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.activities.MainActivity;
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.data.posture.Posture;
-import com.melisa.innovamotionapp.data.posture.PostureFactory;
-import com.melisa.innovamotionapp.sync.FirestoreSyncService;
-import com.melisa.innovamotionapp.sync.UserSession;
-import com.melisa.innovamotionapp.utils.AlertNotifications;
-import com.melisa.innovamotionapp.utils.Constants;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.NotificationConfig;
-import com.melisa.innovamotionapp.utils.PersonNameManager;
-
-import java.io.File;
-import java.util.List;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-public class DeviceCommunicationService extends Service {
-    private FileOutputStream fileOutputStream;
-
-
-    /**
-     * @noinspection BusyWait
-     */
-    @Override
-    public void onCreate() {
-        super.onCreate();
-
-        // Init database with current context
-        database = InnovaDatabase.getInstance(this);
-        
-        // Initialize Firestore sync service and user session
-        firestoreSyncService = FirestoreSyncService.getInstance(this);
-        userSession = UserSession.getInstance(this);
-        personNameManager = PersonNameManager.getInstance(this);
-
-        // Start thread that will save receivedData on each second
-        // Start the batch-saving thread
-        new Thread(() -> {
-            while (isBatchSavingRunning) {
-                try {
-                    // Wait for 5 seconds
-                    Thread.sleep(Constants.COUNTDOWN_TIMER_IN_MILLISECONDS_FOR_MESSAGE_SAVE);
-
-                    // Copy and clear the list in a thread-safe manner
-                    List<ReceivedBtDataEntity> currentBatch;
-                    synchronized (lock) {
-                        currentBatch = new ArrayList<>(temporaryReceivedBtDataListToSave);
-                        temporaryReceivedBtDataListToSave.clear();
-                    }
-
-                    // Save the batch to the database
-                    if (!currentBatch.isEmpty()) {
-                        database.receivedBtDataDao().insertAll(currentBatch);
-                        
-                        // Sync entire batch to Firestore in a single network call (if aggregator and online)
-                        // This is more efficient than individual writes - single round-trip per batch
-                        firestoreSyncService.syncPacketBatch(currentBatch, new FirestoreSyncService.SyncCallback() {
-                            @Override
-                            public void onSuccess(String message) {
-                                Log.d(TAG, "Batch synced: " + message);
-                            }
-
-                            @Override
-                            public void onError(String error) {
-                                Log.w(TAG, "Batch sync error: " + error);
-                            }
-
-                            @Override
-                            public void onProgress(int current, int total) {
-                                Log.d(TAG, "Batch sync progress: " + current + "/" + total);
-                            }
-                        });
-                    }
-                } catch (InterruptedException e) {
-                    Thread.currentThread().interrupt(); // Restore interrupted status
-                    break;
-                }
-            }
-        }).start();
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return binder;
-    }
-
-    private DeviceCommunicationThread deviceCommunicationThread; // The connection thread that handles communication with a device
-    private int attemptToReconnectCounter = 0;
-    private final int MAX_NUM_CONNECTING_CONSECUTIVE_ATTEMPTS = 2;
-
-    // Database operations
-    private InnovaDatabase database;
-    private final List<ReceivedBtDataEntity> temporaryReceivedBtDataListToSave = new ArrayList<>();
-    private final Object lock = new Object(); // For thread-safe access to the list
-    private volatile boolean isBatchSavingRunning = true; // Flag to stop the batch-saving thread
-    
-    // Firestore sync service and user session
-    private FirestoreSyncService firestoreSyncService;
-    private UserSession userSession;
-    
-    // Person name manager (sensor ID to display name mapping)
-    private PersonNameManager personNameManager;
-    
-    // Multi-user protocol parser
-    private final PacketParser packetParser = new PacketParser();
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-        // Foreground start with a neutral/starting state
-        Notification initial = new androidx.core.app.NotificationCompat.Builder(this, NotificationConfig.CHANNEL_BT_SERVICE)
-                .setSmallIcon(R.drawable.baseline_bluetooth_connected_24)
-                .setContentTitle(getString(R.string.notif_bt_title_init))
-                .setContentText(getString(R.string.notif_bt_text_starting))
-                .setOngoing(true)
-                .build();
-
-        startForeground(NotificationConfig.NOTIF_ID_BT_SERVICE, initial);
-
-        return START_STICKY; // or START_REDELIVER_INTENT
-    }
-
-    private final IBinder binder = new LocalBinder();
-
-    public class LocalBinder extends Binder {
-        public DeviceCommunicationService getService() {
-            return DeviceCommunicationService.this;
-        }
-    }
-
-
-    /**
-     * Starts the connection to a Bluetooth device by initializing the connection thread.
-     */
-    public void connectToDevice(BluetoothDevice device) {
-        // If a device is already connected, cancel the previous thread
-        disconnectDevice();
-
-        try {
-            // Prepare the file to store data from the device
-            fileOutputStream = new FileOutputStream(new File(getFilesDir(), String.format(Constants.POSTURE_DATA_SAVE_FILE_NAME, device.getAddress())));
-
-            // Create a new connection thread to connect to the Bluetooth device
-            deviceCommunicationThread = new DeviceCommunicationThread(device, new DeviceCommunicationThread.DataCallback() {
-
-                @SuppressLint("MissingPermission")
-                @Override
-                public void onConnectionEstablished(BluetoothDevice device) {
-                    GlobalData.getInstance().setIsConnectedDevice(true);
-
-                    // Reset consecutive attempts
-                    attemptToReconnectCounter = 0;
-
-                    // Update the existing foreground notification (donâ€™t create a new one)
-                    updateServiceNotification(
-                            getString(R.string.notif_bt_title_connected, device.getName()),
-                            getString(R.string.notif_bt_text_connected),
-                            R.drawable.baseline_bluetooth_connected_24
-                    );
-                }
-
-                @Override
-                public void onDataReceived(BluetoothDevice device, String receivedData) {
-                    Log.d(TAG, "[Service] MSG: " + receivedData);
-
-                    try {
-                        fileOutputStream.write((receivedData + "\n").getBytes());
-                    } catch (IOException e) {
-                        Log.d(TAG, "ERROR writing posture file", e);
-                    }
-
-                    // Feed line to multi-user protocol parser
-                    List<ParsedReading> readings = packetParser.feedLine(receivedData);
-                    
-                    // If null, the parser is still accumulating (not END_PACKET yet)
-                    if (readings == null) {
-                        return;
-                    }
-                    
-                    // END_PACKET received - process all readings in this packet
-                    if (readings.isEmpty()) {
-                        Log.d(TAG, "[Service] Empty packet received");
-                        return;
-                    }
-
-                    // App policy: user is signed in; Firebase caches UID offline. Fetch UID when aggregator.
-                    String ownerUid = null;
-                    if (userSession.isLoaded() && userSession.isAggregator()) {
-                        ownerUid = firestoreSyncService.getCurrentUserId(); // cached UID even offline
-                    }
-                    
-                    // If not aggregator/signed-in, we can't store data (need owner)
-                    if (ownerUid == null) {
-                        Log.w(TAG, "[Service] Ignoring packet - no authenticated user");
-                        return;
-                    }
-
-                    // Process each reading from the packet
-                    for (ParsedReading reading : readings) {
-                        final ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
-                                device.getAddress(),
-                                reading.getReceivedTimestamp(),
-                                reading.getHexCode(),
-                                ownerUid,
-                                reading.getSensorId()
-                        );
-
-                        // Register sensor if new (async, creates with sensorId as default name)
-                        personNameManager.ensureSensorExists(reading.getSensorId());
-
-                        // Enqueue for local persistence (batch thread will insertAll with IGNORE)
-                        synchronized (lock) {
-                            temporaryReceivedBtDataListToSave.add(entity);
-                        }
-
-                        // Keep existing LiveData/UI updates (use the last reading's posture)
-                        Posture posture = PostureFactory.createPosture(reading.getHexCode());
-                        GlobalData.getInstance().setReceivedPosture(posture);
-
-                        // Notify fall locally (aggregator device)
-                        if (posture instanceof com.melisa.innovamotionapp.data.posture.types.FallingPosture) {
-                            // Get display name asynchronously and show notification
-                            final String sensorId = reading.getSensorId();
-                            personNameManager.getDisplayNameAsync(sensorId, personName -> {
-                                AlertNotifications.notifyFall(
-                                        DeviceCommunicationService.this,
-                                        personName,
-                                        getString(R.string.notif_fall_text_generic)
-                                );
-                            });
-                        }
-                    }
-                    
-                    Log.d(TAG, "[Service] Processed packet with " + readings.size() + " readings");
-                }
-
-                @Override
-                public void onConnectionDisconnected() {
-                    GlobalData.getInstance().setIsConnectedDevice(false);
-                    try {
-                        fileOutputStream.close();
-                    } catch (IOException e) {
-                        Log.d(TAG, "ERROR closing input stream", e);
-                    }
-
-                    // Update the same foreground notification to show weâ€™re reconnecting
-                    updateServiceNotification(
-                            getString(R.string.notif_bt_title_disconnected),
-                            getString(R.string.notif_bt_text_reconnecting),
-                            R.drawable.baseline_bluetooth_disabled_24
-                    );
-
-
-                    if (attemptToReconnectCounter >= MAX_NUM_CONNECTING_CONSECUTIVE_ATTEMPTS) {
-                        // Stop current service
-                        GlobalData.getInstance().deviceCommunicationManager.stopService();
-                        stopForeground(true);
-                        stopSelf();
-                    } else {
-                        attemptToReconnectCounter += 1;
-                        BluetoothDevice deviceToConnect = GlobalData.getInstance().deviceCommunicationManager.getDeviceToConnect();
-                        connectToDevice(deviceToConnect);
-                    }
-
-                }
-            });
-
-            // Start the connection thread
-            deviceCommunicationThread.start();
-        } catch (IOException e) {
-            Log.e(TAG, "[Service] Error at connectToDevice", e);
-        }
-    }
-
-    /**
-     * Disconnect the currently connected device.
-     */
-    public void disconnectDevice() {
-        if (deviceCommunicationThread != null) {
-            if (isDeviceConnected()) {
-                deviceCommunicationThread.interrupt();
-            }
-            deviceCommunicationThread = null;
-        }
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-
-        isBatchSavingRunning = false; // Signal the batch-saving thread to stop
-        
-        // Clean up sync service and user session
-        if (firestoreSyncService != null) {
-            firestoreSyncService.cleanup();
-        }
-        if (userSession != null) {
-            userSession.cleanup();
-        }
-    }
-
-    /**
-     * Check if a device is currently connected.
-     */
-    public boolean isDeviceConnected() {
-        return deviceCommunicationThread != null && deviceCommunicationThread.isAlive();
-    }
-
-    private void updateServiceNotification(String title, String text, int iconRes) {
-        Intent openIntent = new Intent(this, MainActivity.class)
-                .setAction(NotificationConfig.ACTION_OPEN_FROM_SERVICE);
-
-        android.app.PendingIntent contentPI =
-                androidx.core.app.TaskStackBuilder.create(this)
-                        .addNextIntentWithParentStack(openIntent)
-                        .getPendingIntent(
-                                NotificationConfig.RC_OPEN_FROM_SERVICE,
-                                android.os.Build.VERSION.SDK_INT >= 23
-                                        ? android.app.PendingIntent.FLAG_UPDATE_CURRENT | android.app.PendingIntent.FLAG_IMMUTABLE
-                                        : android.app.PendingIntent.FLAG_UPDATE_CURRENT
-                        );
-
-        Notification notification = new androidx.core.app.NotificationCompat.Builder(this, NotificationConfig.CHANNEL_BT_SERVICE)
-                .setSmallIcon(iconRes)
-                .setContentTitle(title)
-                .setContentText(text)
-                .setOngoing(true)
-                .setContentIntent(contentPI)
-                .build();
-
-        android.app.NotificationManager nm = (android.app.NotificationManager) getSystemService(NOTIFICATION_SERVICE);
-        nm.notify(NotificationConfig.NOTIF_ID_BT_SERVICE, notification); // same ID â†’ replaces in place
-    }
-}
-
+package com.melisa.innovamotionapp.bluetooth;
+
+import static android.content.ContentValues.TAG;
+
+import android.annotation.SuppressLint;
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.Service;
+import android.bluetooth.BluetoothDevice;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.IBinder;
+import android.util.Log;
+
+import androidx.core.app.NotificationCompat;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.activities.MainActivity;
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.data.posture.Posture;
+import com.melisa.innovamotionapp.data.posture.PostureFactory;
+import com.melisa.innovamotionapp.sync.FirestoreSyncService;
+import com.melisa.innovamotionapp.sync.UserSession;
+import com.melisa.innovamotionapp.utils.AlertNotifications;
+import com.melisa.innovamotionapp.utils.Constants;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.NotificationConfig;
+import com.melisa.innovamotionapp.utils.PersonNameManager;
+
+import java.io.File;
+import java.util.List;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class DeviceCommunicationService extends Service {
+    private FileOutputStream fileOutputStream;
+
+
+    /**
+     * @noinspection BusyWait
+     */
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        // Init database with current context
+        database = InnovaDatabase.getInstance(this);
+        
+        // Initialize Firestore sync service and user session
+        firestoreSyncService = FirestoreSyncService.getInstance(this);
+        userSession = UserSession.getInstance(this);
+        personNameManager = PersonNameManager.getInstance(this);
+
+        // Start thread that will save receivedData on each second
+        // Start the batch-saving thread
+        new Thread(() -> {
+            while (isBatchSavingRunning) {
+                try {
+                    // Wait for 5 seconds
+                    Thread.sleep(Constants.COUNTDOWN_TIMER_IN_MILLISECONDS_FOR_MESSAGE_SAVE);
+
+                    // Copy and clear the list in a thread-safe manner
+                    List<ReceivedBtDataEntity> currentBatch;
+                    synchronized (lock) {
+                        currentBatch = new ArrayList<>(temporaryReceivedBtDataListToSave);
+                        temporaryReceivedBtDataListToSave.clear();
+                    }
+
+                    // Save the batch to the database
+                    if (!currentBatch.isEmpty()) {
+                        database.receivedBtDataDao().insertAll(currentBatch);
+                        
+                        // Sync entire batch to Firestore in a single network call (if aggregator and online)
+                        // This is more efficient than individual writes - single round-trip per batch
+                        firestoreSyncService.syncPacketBatch(currentBatch, new FirestoreSyncService.SyncCallback() {
+                            @Override
+                            public void onSuccess(String message) {
+                                Log.d(TAG, "Batch synced: " + message);
+                            }
+
+                            @Override
+                            public void onError(String error) {
+                                Log.w(TAG, "Batch sync error: " + error);
+                            }
+
+                            @Override
+                            public void onProgress(int current, int total) {
+                                Log.d(TAG, "Batch sync progress: " + current + "/" + total);
+                            }
+                        });
+                    }
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt(); // Restore interrupted status
+                    break;
+                }
+            }
+        }).start();
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return binder;
+    }
+
+    private DeviceCommunicationThread deviceCommunicationThread; // The connection thread that handles communication with a device
+    private int attemptToReconnectCounter = 0;
+    private final int MAX_NUM_CONNECTING_CONSECUTIVE_ATTEMPTS = 2;
+
+    // Database operations
+    private InnovaDatabase database;
+    private final List<ReceivedBtDataEntity> temporaryReceivedBtDataListToSave = new ArrayList<>();
+    private final Object lock = new Object(); // For thread-safe access to the list
+    private volatile boolean isBatchSavingRunning = true; // Flag to stop the batch-saving thread
+    
+    // Firestore sync service and user session
+    private FirestoreSyncService firestoreSyncService;
+    private UserSession userSession;
+    
+    // Person name manager (sensor ID to display name mapping)
+    private PersonNameManager personNameManager;
+    
+    // Multi-user protocol parser
+    private final PacketParser packetParser = new PacketParser();
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        // Foreground start with a neutral/starting state
+        Notification initial = new androidx.core.app.NotificationCompat.Builder(this, NotificationConfig.CHANNEL_BT_SERVICE)
+                .setSmallIcon(R.drawable.baseline_bluetooth_connected_24)
+                .setContentTitle(getString(R.string.notif_bt_title_init))
+                .setContentText(getString(R.string.notif_bt_text_starting))
+                .setOngoing(true)
+                .build();
+
+        startForeground(NotificationConfig.NOTIF_ID_BT_SERVICE, initial);
+
+        return START_STICKY; // or START_REDELIVER_INTENT
+    }
+
+    private final IBinder binder = new LocalBinder();
+
+    public class LocalBinder extends Binder {
+        public DeviceCommunicationService getService() {
+            return DeviceCommunicationService.this;
+        }
+    }
+
+
+    /**
+     * Starts the connection to a Bluetooth device by initializing the connection thread.
+     */
+    public void connectToDevice(BluetoothDevice device) {
+        // If a device is already connected, cancel the previous thread
+        disconnectDevice();
+
+        try {
+            // Prepare the file to store data from the device
+            fileOutputStream = new FileOutputStream(new File(getFilesDir(), String.format(Constants.POSTURE_DATA_SAVE_FILE_NAME, device.getAddress())));
+
+            // Create a new connection thread to connect to the Bluetooth device
+            deviceCommunicationThread = new DeviceCommunicationThread(device, new DeviceCommunicationThread.DataCallback() {
+
+                @SuppressLint("MissingPermission")
+                @Override
+                public void onConnectionEstablished(BluetoothDevice device) {
+                    GlobalData.getInstance().setIsConnectedDevice(true);
+
+                    // Reset consecutive attempts
+                    attemptToReconnectCounter = 0;
+
+                    // Update the existing foreground notification (donâ€™t create a new one)
+                    updateServiceNotification(
+                            getString(R.string.notif_bt_title_connected, device.getName()),
+                            getString(R.string.notif_bt_text_connected),
+                            R.drawable.baseline_bluetooth_connected_24
+                    );
+                }
+
+                @Override
+                public void onDataReceived(BluetoothDevice device, String receivedData) {
+                    Log.d(TAG, "[Service] MSG: " + receivedData);
+
+                    try {
+                        fileOutputStream.write((receivedData + "\n").getBytes());
+                    } catch (IOException e) {
+                        Log.d(TAG, "ERROR writing posture file", e);
+                    }
+
+                    // Feed line to multi-user protocol parser
+                    List<ParsedReading> readings = packetParser.feedLine(receivedData);
+                    
+                    // If null, the parser is still accumulating (not END_PACKET yet)
+                    if (readings == null) {
+                        return;
+                    }
+                    
+                    // END_PACKET received - process all readings in this packet
+                    if (readings.isEmpty()) {
+                        Log.d(TAG, "[Service] Empty packet received");
+                        return;
+                    }
+
+                    // App policy: user is signed in; Firebase caches UID offline. Fetch UID when aggregator.
+                    String ownerUid = null;
+                    if (userSession.isLoaded() && userSession.isAggregator()) {
+                        ownerUid = firestoreSyncService.getCurrentUserId(); // cached UID even offline
+                    }
+                    
+                    // If not aggregator/signed-in, we can't store data (need owner)
+                    if (ownerUid == null) {
+                        Log.w(TAG, "[Service] Ignoring packet - no authenticated user");
+                        return;
+                    }
+
+                    // Process each reading from the packet
+                    for (ParsedReading reading : readings) {
+                        final ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
+                                device.getAddress(),
+                                reading.getReceivedTimestamp(),
+                                reading.getHexCode(),
+                                ownerUid,
+                                reading.getSensorId()
+                        );
+
+                        // Register sensor if new (async, creates with sensorId as default name)
+                        personNameManager.ensureSensorExists(reading.getSensorId());
+
+                        // Enqueue for local persistence (batch thread will insertAll with IGNORE)
+                        synchronized (lock) {
+                            temporaryReceivedBtDataListToSave.add(entity);
+                        }
+
+                        // Keep existing LiveData/UI updates (use the last reading's posture)
+                        Posture posture = PostureFactory.createPosture(reading.getHexCode());
+                        GlobalData.getInstance().setReceivedPosture(posture);
+
+                        // Notify fall locally (aggregator device)
+                        if (posture instanceof com.melisa.innovamotionapp.data.posture.types.FallingPosture) {
+                            // Get display name asynchronously and show notification
+                            final String sensorId = reading.getSensorId();
+                            personNameManager.getDisplayNameAsync(sensorId, personName -> {
+                                AlertNotifications.notifyFall(
+                                        DeviceCommunicationService.this,
+                                        personName,
+                                        getString(R.string.notif_fall_text_generic)
+                                );
+                            });
+                        }
+                    }
+                    
+                    Log.d(TAG, "[Service] Processed packet with " + readings.size() + " readings");
+                }
+
+                @Override
+                public void onConnectionDisconnected() {
+                    GlobalData.getInstance().setIsConnectedDevice(false);
+                    try {
+                        fileOutputStream.close();
+                    } catch (IOException e) {
+                        Log.d(TAG, "ERROR closing input stream", e);
+                    }
+
+                    // Update the same foreground notification to show weâ€™re reconnecting
+                    updateServiceNotification(
+                            getString(R.string.notif_bt_title_disconnected),
+                            getString(R.string.notif_bt_text_reconnecting),
+                            R.drawable.baseline_bluetooth_disabled_24
+                    );
+
+
+                    if (attemptToReconnectCounter >= MAX_NUM_CONNECTING_CONSECUTIVE_ATTEMPTS) {
+                        // Stop current service
+                        GlobalData.getInstance().deviceCommunicationManager.stopService();
+                        stopForeground(true);
+                        stopSelf();
+                    } else {
+                        attemptToReconnectCounter += 1;
+                        BluetoothDevice deviceToConnect = GlobalData.getInstance().deviceCommunicationManager.getDeviceToConnect();
+                        connectToDevice(deviceToConnect);
+                    }
+
+                }
+            });
+
+            // Start the connection thread
+            deviceCommunicationThread.start();
+        } catch (IOException e) {
+            Log.e(TAG, "[Service] Error at connectToDevice", e);
+        }
+    }
+
+    /**
+     * Disconnect the currently connected device.
+     */
+    public void disconnectDevice() {
+        if (deviceCommunicationThread != null) {
+            if (isDeviceConnected()) {
+                deviceCommunicationThread.interrupt();
+            }
+            deviceCommunicationThread = null;
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        isBatchSavingRunning = false; // Signal the batch-saving thread to stop
+        
+        // Clean up sync service and user session
+        if (firestoreSyncService != null) {
+            firestoreSyncService.cleanup();
+        }
+        if (userSession != null) {
+            userSession.cleanup();
+        }
+    }
+
+    /**
+     * Check if a device is currently connected.
+     */
+    public boolean isDeviceConnected() {
+        return deviceCommunicationThread != null && deviceCommunicationThread.isAlive();
+    }
+
+    private void updateServiceNotification(String title, String text, int iconRes) {
+        Intent openIntent = new Intent(this, MainActivity.class)
+                .setAction(NotificationConfig.ACTION_OPEN_FROM_SERVICE);
+
+        android.app.PendingIntent contentPI =
+                androidx.core.app.TaskStackBuilder.create(this)
+                        .addNextIntentWithParentStack(openIntent)
+                        .getPendingIntent(
+                                NotificationConfig.RC_OPEN_FROM_SERVICE,
+                                android.os.Build.VERSION.SDK_INT >= 23
+                                        ? android.app.PendingIntent.FLAG_UPDATE_CURRENT | android.app.PendingIntent.FLAG_IMMUTABLE
+                                        : android.app.PendingIntent.FLAG_UPDATE_CURRENT
+                        );
+
+        Notification notification = new androidx.core.app.NotificationCompat.Builder(this, NotificationConfig.CHANNEL_BT_SERVICE)
+                .setSmallIcon(iconRes)
+                .setContentTitle(title)
+                .setContentText(text)
+                .setOngoing(true)
+                .setContentIntent(contentPI)
+                .build();
+
+        android.app.NotificationManager nm = (android.app.NotificationManager) getSystemService(NOTIFICATION_SERVICE);
+        nm.notify(NotificationConfig.NOTIF_ID_BT_SERVICE, notification); // same ID â†’ replaces in place
+    }
+}
+
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/PacketParser.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/PacketParser.java
index 8f92812..d68c8e5 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/PacketParser.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/PacketParser.java
@@ -1,227 +1,227 @@
-package com.melisa.innovamotionapp.bluetooth;
-
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.melisa.innovamotionapp.utils.Constants;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Parser for the multi-user Bluetooth protocol.
- * 
- * Buffers incoming lines until END_PACKET is received, then returns all parsed readings as a batch.
- * 
- * Protocol format:
- * <pre>
- * sensor001;0xAB3311\n
- * sensor002;0xEF0112\n
- * sensor003;0xBA3311\n
- * END_PACKET\n
- * </pre>
- * 
- * Usage:
- * <pre>
- * PacketParser parser = new PacketParser();
- * for (String line : incomingLines) {
- *     List<ParsedReading> readings = parser.feedLine(line);
- *     if (readings != null) {
- *         // Complete packet received, process readings
- *         processPacket(readings);
- *     }
- * }
- * </pre>
- * 
- * Thread Safety: This class is NOT thread-safe. Use external synchronization if accessed from multiple threads.
- */
-public class PacketParser {
-    
-    private static final String TAG = "PacketParser";
-    
-    private final List<ParsedReading> buffer;
-    private final int maxBufferSize;
-    
-    /**
-     * Create a new PacketParser with default max buffer size.
-     */
-    public PacketParser() {
-        this(Constants.MAX_READINGS_PER_PACKET);
-    }
-    
-    /**
-     * Create a new PacketParser with custom max buffer size.
-     * 
-     * @param maxBufferSize Maximum number of readings to buffer before auto-clearing
-     *                      to prevent memory exhaustion from missing END_PACKET
-     */
-    public PacketParser(int maxBufferSize) {
-        if (maxBufferSize <= 0) {
-            throw new IllegalArgumentException("maxBufferSize must be positive");
-        }
-        this.maxBufferSize = maxBufferSize;
-        this.buffer = new ArrayList<>();
-    }
-    
-    /**
-     * Feed a line to the parser.
-     * 
-     * @param line The raw line received from Bluetooth (without trailing newline)
-     * @return List of parsed readings if packet is complete (END_PACKET received),
-     *         null if packet is still in progress or line was invalid.
-     *         Returns empty list for empty packets (just END_PACKET).
-     */
-    @Nullable
-    public List<ParsedReading> feedLine(@Nullable String line) {
-        if (line == null) {
-            return null;
-        }
-        
-        String trimmedLine = line.trim();
-        
-        // Check for packet terminator
-        if (Constants.PACKET_TERMINATOR.equals(trimmedLine)) {
-            List<ParsedReading> result = new ArrayList<>(buffer);
-            buffer.clear();
-            Log.d(TAG, "Packet complete with " + result.size() + " readings");
-            return result;
-        }
-        
-        // Skip empty lines
-        if (trimmedLine.isEmpty()) {
-            Log.v(TAG, "Skipping empty line");
-            return null;
-        }
-        
-        // Check buffer overflow protection
-        if (buffer.size() >= maxBufferSize) {
-            Log.w(TAG, "Buffer overflow protection: clearing " + buffer.size() + 
-                    " readings (max: " + maxBufferSize + "). Possible missing END_PACKET.");
-            buffer.clear();
-        }
-        
-        // Parse the line
-        ParsedReading reading = parseLine(trimmedLine);
-        if (reading != null) {
-            buffer.add(reading);
-            Log.v(TAG, "Buffered reading: " + reading.getSensorId() + " -> " + reading.getHexCode());
-        }
-        
-        return null;
-    }
-    
-    /**
-     * Parse a single protocol line into a ParsedReading.
-     * 
-     * Expected format: "sensorId;hexCode"
-     * Example: "sensor001;0xAB3311"
-     * 
-     * @param line The trimmed line to parse
-     * @return ParsedReading if valid, null if malformed
-     */
-    @Nullable
-    private ParsedReading parseLine(@NonNull String line) {
-        // Find the delimiter
-        int delimiterIndex = line.indexOf(Constants.SENSOR_ID_DELIMITER);
-        
-        if (delimiterIndex == -1) {
-            // No delimiter found - might be legacy single-line format or malformed
-            Log.w(TAG, "Malformed line (no delimiter '" + Constants.SENSOR_ID_DELIMITER + 
-                    "'): \"" + truncateForLog(line) + "\"");
-            return null;
-        }
-        
-        // Extract parts
-        String sensorId = line.substring(0, delimiterIndex).trim();
-        String hexCode = line.substring(delimiterIndex + 1).trim();
-        
-        // Validate sensorId
-        if (sensorId.isEmpty()) {
-            Log.w(TAG, "Malformed line (empty sensorId): \"" + truncateForLog(line) + "\"");
-            return null;
-        }
-        
-        // Validate hexCode
-        if (hexCode.isEmpty()) {
-            Log.w(TAG, "Malformed line (empty hexCode): \"" + truncateForLog(line) + "\"");
-            return null;
-        }
-        
-        // Check for multiple delimiters (take only first two parts)
-        if (hexCode.contains(Constants.SENSOR_ID_DELIMITER)) {
-            Log.w(TAG, "Line contains multiple delimiters, using first segment only: \"" + 
-                    truncateForLog(line) + "\"");
-            hexCode = hexCode.substring(0, hexCode.indexOf(Constants.SENSOR_ID_DELIMITER)).trim();
-            if (hexCode.isEmpty()) {
-                Log.w(TAG, "Malformed line (empty hexCode after delimiter handling): \"" + 
-                        truncateForLog(line) + "\"");
-                return null;
-            }
-        }
-        
-        try {
-            return new ParsedReading(sensorId, hexCode);
-        } catch (IllegalArgumentException e) {
-            Log.w(TAG, "Failed to create ParsedReading: " + e.getMessage());
-            return null;
-        }
-    }
-    
-    /**
-     * Truncate a string for safe logging (prevents log pollution from very long lines).
-     */
-    private String truncateForLog(String s) {
-        final int maxLength = Constants.LOG_TRUNCATE_LENGTH;
-        if (s.length() <= maxLength) {
-            return s;
-        }
-        return s.substring(0, maxLength) + "... (" + s.length() + " chars)";
-    }
-    
-    /**
-     * Reset the parser, clearing any buffered readings.
-     * Call this when reconnecting or to discard partial packets.
-     */
-    public void reset() {
-        int clearedCount = buffer.size();
-        buffer.clear();
-        if (clearedCount > 0) {
-            Log.d(TAG, "Parser reset, cleared " + clearedCount + " buffered readings");
-        }
-    }
-    
-    /**
-     * @return The current number of readings buffered (waiting for END_PACKET)
-     */
-    public int getBufferSize() {
-        return buffer.size();
-    }
-    
-    /**
-     * @return The maximum buffer size before auto-clear
-     */
-    public int getMaxBufferSize() {
-        return maxBufferSize;
-    }
-    
-    /**
-     * @return True if the buffer is empty (no partial packet in progress)
-     */
-    public boolean isBufferEmpty() {
-        return buffer.isEmpty();
-    }
-    
-    /**
-     * Get an unmodifiable view of the current buffer contents.
-     * Useful for debugging/diagnostics.
-     * 
-     * @return Unmodifiable list of currently buffered readings
-     */
-    @NonNull
-    public List<ParsedReading> getBufferContents() {
-        return Collections.unmodifiableList(new ArrayList<>(buffer));
-    }
-}
+package com.melisa.innovamotionapp.bluetooth;
+
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.melisa.innovamotionapp.utils.Constants;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Parser for the multi-user Bluetooth protocol.
+ * 
+ * Buffers incoming lines until END_PACKET is received, then returns all parsed readings as a batch.
+ * 
+ * Protocol format:
+ * <pre>
+ * sensor001;0xAB3311\n
+ * sensor002;0xEF0112\n
+ * sensor003;0xBA3311\n
+ * END_PACKET\n
+ * </pre>
+ * 
+ * Usage:
+ * <pre>
+ * PacketParser parser = new PacketParser();
+ * for (String line : incomingLines) {
+ *     List<ParsedReading> readings = parser.feedLine(line);
+ *     if (readings != null) {
+ *         // Complete packet received, process readings
+ *         processPacket(readings);
+ *     }
+ * }
+ * </pre>
+ * 
+ * Thread Safety: This class is NOT thread-safe. Use external synchronization if accessed from multiple threads.
+ */
+public class PacketParser {
+    
+    private static final String TAG = "PacketParser";
+    
+    private final List<ParsedReading> buffer;
+    private final int maxBufferSize;
+    
+    /**
+     * Create a new PacketParser with default max buffer size.
+     */
+    public PacketParser() {
+        this(Constants.MAX_READINGS_PER_PACKET);
+    }
+    
+    /**
+     * Create a new PacketParser with custom max buffer size.
+     * 
+     * @param maxBufferSize Maximum number of readings to buffer before auto-clearing
+     *                      to prevent memory exhaustion from missing END_PACKET
+     */
+    public PacketParser(int maxBufferSize) {
+        if (maxBufferSize <= 0) {
+            throw new IllegalArgumentException("maxBufferSize must be positive");
+        }
+        this.maxBufferSize = maxBufferSize;
+        this.buffer = new ArrayList<>();
+    }
+    
+    /**
+     * Feed a line to the parser.
+     * 
+     * @param line The raw line received from Bluetooth (without trailing newline)
+     * @return List of parsed readings if packet is complete (END_PACKET received),
+     *         null if packet is still in progress or line was invalid.
+     *         Returns empty list for empty packets (just END_PACKET).
+     */
+    @Nullable
+    public List<ParsedReading> feedLine(@Nullable String line) {
+        if (line == null) {
+            return null;
+        }
+        
+        String trimmedLine = line.trim();
+        
+        // Check for packet terminator
+        if (Constants.PACKET_TERMINATOR.equals(trimmedLine)) {
+            List<ParsedReading> result = new ArrayList<>(buffer);
+            buffer.clear();
+            Log.d(TAG, "Packet complete with " + result.size() + " readings");
+            return result;
+        }
+        
+        // Skip empty lines
+        if (trimmedLine.isEmpty()) {
+            Log.v(TAG, "Skipping empty line");
+            return null;
+        }
+        
+        // Check buffer overflow protection
+        if (buffer.size() >= maxBufferSize) {
+            Log.w(TAG, "Buffer overflow protection: clearing " + buffer.size() + 
+                    " readings (max: " + maxBufferSize + "). Possible missing END_PACKET.");
+            buffer.clear();
+        }
+        
+        // Parse the line
+        ParsedReading reading = parseLine(trimmedLine);
+        if (reading != null) {
+            buffer.add(reading);
+            Log.v(TAG, "Buffered reading: " + reading.getSensorId() + " -> " + reading.getHexCode());
+        }
+        
+        return null;
+    }
+    
+    /**
+     * Parse a single protocol line into a ParsedReading.
+     * 
+     * Expected format: "sensorId;hexCode"
+     * Example: "sensor001;0xAB3311"
+     * 
+     * @param line The trimmed line to parse
+     * @return ParsedReading if valid, null if malformed
+     */
+    @Nullable
+    private ParsedReading parseLine(@NonNull String line) {
+        // Find the delimiter
+        int delimiterIndex = line.indexOf(Constants.SENSOR_ID_DELIMITER);
+        
+        if (delimiterIndex == -1) {
+            // No delimiter found - might be legacy single-line format or malformed
+            Log.w(TAG, "Malformed line (no delimiter '" + Constants.SENSOR_ID_DELIMITER + 
+                    "'): \"" + truncateForLog(line) + "\"");
+            return null;
+        }
+        
+        // Extract parts
+        String sensorId = line.substring(0, delimiterIndex).trim();
+        String hexCode = line.substring(delimiterIndex + 1).trim();
+        
+        // Validate sensorId
+        if (sensorId.isEmpty()) {
+            Log.w(TAG, "Malformed line (empty sensorId): \"" + truncateForLog(line) + "\"");
+            return null;
+        }
+        
+        // Validate hexCode
+        if (hexCode.isEmpty()) {
+            Log.w(TAG, "Malformed line (empty hexCode): \"" + truncateForLog(line) + "\"");
+            return null;
+        }
+        
+        // Check for multiple delimiters (take only first two parts)
+        if (hexCode.contains(Constants.SENSOR_ID_DELIMITER)) {
+            Log.w(TAG, "Line contains multiple delimiters, using first segment only: \"" + 
+                    truncateForLog(line) + "\"");
+            hexCode = hexCode.substring(0, hexCode.indexOf(Constants.SENSOR_ID_DELIMITER)).trim();
+            if (hexCode.isEmpty()) {
+                Log.w(TAG, "Malformed line (empty hexCode after delimiter handling): \"" + 
+                        truncateForLog(line) + "\"");
+                return null;
+            }
+        }
+        
+        try {
+            return new ParsedReading(sensorId, hexCode);
+        } catch (IllegalArgumentException e) {
+            Log.w(TAG, "Failed to create ParsedReading: " + e.getMessage());
+            return null;
+        }
+    }
+    
+    /**
+     * Truncate a string for safe logging (prevents log pollution from very long lines).
+     */
+    private String truncateForLog(String s) {
+        final int maxLength = Constants.LOG_TRUNCATE_LENGTH;
+        if (s.length() <= maxLength) {
+            return s;
+        }
+        return s.substring(0, maxLength) + "... (" + s.length() + " chars)";
+    }
+    
+    /**
+     * Reset the parser, clearing any buffered readings.
+     * Call this when reconnecting or to discard partial packets.
+     */
+    public void reset() {
+        int clearedCount = buffer.size();
+        buffer.clear();
+        if (clearedCount > 0) {
+            Log.d(TAG, "Parser reset, cleared " + clearedCount + " buffered readings");
+        }
+    }
+    
+    /**
+     * @return The current number of readings buffered (waiting for END_PACKET)
+     */
+    public int getBufferSize() {
+        return buffer.size();
+    }
+    
+    /**
+     * @return The maximum buffer size before auto-clear
+     */
+    public int getMaxBufferSize() {
+        return maxBufferSize;
+    }
+    
+    /**
+     * @return True if the buffer is empty (no partial packet in progress)
+     */
+    public boolean isBufferEmpty() {
+        return buffer.isEmpty();
+    }
+    
+    /**
+     * Get an unmodifiable view of the current buffer contents.
+     * Useful for debugging/diagnostics.
+     * 
+     * @return Unmodifiable list of currently buffered readings
+     */
+    @NonNull
+    public List<ParsedReading> getBufferContents() {
+        return Collections.unmodifiableList(new ArrayList<>(buffer));
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/ParsedReading.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/ParsedReading.java
index a05b23c..1a73688 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/ParsedReading.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/bluetooth/ParsedReading.java
@@ -1,106 +1,106 @@
-package com.melisa.innovamotionapp.bluetooth;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import java.util.Objects;
-
-/**
- * Immutable data class representing a single parsed reading from the multi-user Bluetooth protocol.
- * 
- * Each reading contains:
- * - sensorId: The unique identifier for the monitored person/sensor (e.g., "sensor001", UUID)
- * - hexCode: The posture hex code (e.g., "0xAB3311")
- * - receivedTimestamp: When this reading was received by the app
- * 
- * Example protocol line: "sensor001;0xAB3311\n"
- */
-public final class ParsedReading {
-    
-    @NonNull
-    private final String sensorId;
-    
-    @NonNull
-    private final String hexCode;
-    
-    private final long receivedTimestamp;
-    
-    /**
-     * Create a new ParsedReading.
-     * 
-     * @param sensorId The sensor/person identifier from hardware (must not be null or empty)
-     * @param hexCode The posture hex code (must not be null or empty)
-     * @param receivedTimestamp When this reading was received (epoch milliseconds)
-     * @throws IllegalArgumentException if sensorId or hexCode is null or empty
-     */
-    public ParsedReading(@NonNull String sensorId, @NonNull String hexCode, long receivedTimestamp) {
-        if (sensorId == null || sensorId.trim().isEmpty()) {
-            throw new IllegalArgumentException("sensorId cannot be null or empty");
-        }
-        if (hexCode == null || hexCode.trim().isEmpty()) {
-            throw new IllegalArgumentException("hexCode cannot be null or empty");
-        }
-        
-        this.sensorId = sensorId.trim();
-        this.hexCode = hexCode.trim();
-        this.receivedTimestamp = receivedTimestamp;
-    }
-    
-    /**
-     * Create a new ParsedReading with current timestamp.
-     * 
-     * @param sensorId The sensor/person identifier from hardware
-     * @param hexCode The posture hex code
-     */
-    public ParsedReading(@NonNull String sensorId, @NonNull String hexCode) {
-        this(sensorId, hexCode, System.currentTimeMillis());
-    }
-    
-    /**
-     * @return The sensor/person identifier (never null or empty)
-     */
-    @NonNull
-    public String getSensorId() {
-        return sensorId;
-    }
-    
-    /**
-     * @return The posture hex code (never null or empty)
-     */
-    @NonNull
-    public String getHexCode() {
-        return hexCode;
-    }
-    
-    /**
-     * @return The timestamp when this reading was received (epoch milliseconds)
-     */
-    public long getReceivedTimestamp() {
-        return receivedTimestamp;
-    }
-    
-    @Override
-    public boolean equals(@Nullable Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        ParsedReading that = (ParsedReading) o;
-        return receivedTimestamp == that.receivedTimestamp &&
-                sensorId.equals(that.sensorId) &&
-                hexCode.equals(that.hexCode);
-    }
-    
-    @Override
-    public int hashCode() {
-        return Objects.hash(sensorId, hexCode, receivedTimestamp);
-    }
-    
-    @NonNull
-    @Override
-    public String toString() {
-        return "ParsedReading{" +
-                "sensorId='" + sensorId + '\'' +
-                ", hexCode='" + hexCode + '\'' +
-                ", receivedTimestamp=" + receivedTimestamp +
-                '}';
-    }
-}
+package com.melisa.innovamotionapp.bluetooth;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.Objects;
+
+/**
+ * Immutable data class representing a single parsed reading from the multi-user Bluetooth protocol.
+ * 
+ * Each reading contains:
+ * - sensorId: The unique identifier for the monitored person/sensor (e.g., "sensor001", UUID)
+ * - hexCode: The posture hex code (e.g., "0xAB3311")
+ * - receivedTimestamp: When this reading was received by the app
+ * 
+ * Example protocol line: "sensor001;0xAB3311\n"
+ */
+public final class ParsedReading {
+    
+    @NonNull
+    private final String sensorId;
+    
+    @NonNull
+    private final String hexCode;
+    
+    private final long receivedTimestamp;
+    
+    /**
+     * Create a new ParsedReading.
+     * 
+     * @param sensorId The sensor/person identifier from hardware (must not be null or empty)
+     * @param hexCode The posture hex code (must not be null or empty)
+     * @param receivedTimestamp When this reading was received (epoch milliseconds)
+     * @throws IllegalArgumentException if sensorId or hexCode is null or empty
+     */
+    public ParsedReading(@NonNull String sensorId, @NonNull String hexCode, long receivedTimestamp) {
+        if (sensorId == null || sensorId.trim().isEmpty()) {
+            throw new IllegalArgumentException("sensorId cannot be null or empty");
+        }
+        if (hexCode == null || hexCode.trim().isEmpty()) {
+            throw new IllegalArgumentException("hexCode cannot be null or empty");
+        }
+        
+        this.sensorId = sensorId.trim();
+        this.hexCode = hexCode.trim();
+        this.receivedTimestamp = receivedTimestamp;
+    }
+    
+    /**
+     * Create a new ParsedReading with current timestamp.
+     * 
+     * @param sensorId The sensor/person identifier from hardware
+     * @param hexCode The posture hex code
+     */
+    public ParsedReading(@NonNull String sensorId, @NonNull String hexCode) {
+        this(sensorId, hexCode, System.currentTimeMillis());
+    }
+    
+    /**
+     * @return The sensor/person identifier (never null or empty)
+     */
+    @NonNull
+    public String getSensorId() {
+        return sensorId;
+    }
+    
+    /**
+     * @return The posture hex code (never null or empty)
+     */
+    @NonNull
+    public String getHexCode() {
+        return hexCode;
+    }
+    
+    /**
+     * @return The timestamp when this reading was received (epoch milliseconds)
+     */
+    public long getReceivedTimestamp() {
+        return receivedTimestamp;
+    }
+    
+    @Override
+    public boolean equals(@Nullable Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        ParsedReading that = (ParsedReading) o;
+        return receivedTimestamp == that.receivedTimestamp &&
+                sensorId.equals(that.sensorId) &&
+                hexCode.equals(that.hexCode);
+    }
+    
+    @Override
+    public int hashCode() {
+        return Objects.hash(sensorId, hexCode, receivedTimestamp);
+    }
+    
+    @NonNull
+    @Override
+    public String toString() {
+        return "ParsedReading{" +
+                "sensorId='" + sensorId + '\'' +
+                ", hexCode='" + hexCode + '\'' +
+                ", receivedTimestamp=" + receivedTimestamp +
+                '}';
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java
index 2d14c53..bfae434 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java
@@ -1,42 +1,42 @@
-package com.melisa.innovamotionapp.data.database;
-
-import android.content.Context;
-
-import androidx.room.Database;
-import androidx.room.Room;
-import androidx.room.RoomDatabase;
-import androidx.room.migration.Migration;
-import androidx.sqlite.db.SupportSQLiteDatabase;
-
-@Database(entities = {ReceivedBtDataEntity.class, MonitoredPerson.class}, version = 4)
-public abstract class InnovaDatabase extends RoomDatabase {
-    private static InnovaDatabase instance;
-    
-    // Migration from version 1 to 2 - adds unique index
-    static final Migration MIGRATION_1_2 = new Migration(1, 2) {
-        @Override
-        public void migrate(SupportSQLiteDatabase database) {
-            // Create unique index on (device_address, timestamp, received_msg)
-            database.execSQL("CREATE UNIQUE INDEX index_received_bt_data_device_address_timestamp_received_msg " +
-                    "ON received_bt_data (device_address, timestamp, received_msg)");
-        }
-    };
-
-    public abstract ReceivedBtDataDao receivedBtDataDao();
-    
-    public abstract MonitoredPersonDao monitoredPersonDao();
-
-    public static synchronized InnovaDatabase getInstance(Context context) {
-        if (instance == null) {
-            instance = Room.databaseBuilder(context.getApplicationContext(),
-                    InnovaDatabase.class, "my_database")
-                    .addMigrations(MIGRATION_1_2)
-                    .fallbackToDestructiveMigration() // Fallback for development
-                    .build();
-            
-            // One-liner DB path log (once)
-            android.util.Log.i("DB", "Path=" + context.getDatabasePath("my_database").getAbsolutePath());
-        }
-        return instance;
-    }
-}
+package com.melisa.innovamotionapp.data.database;
+
+import android.content.Context;
+
+import androidx.room.Database;
+import androidx.room.Room;
+import androidx.room.RoomDatabase;
+import androidx.room.migration.Migration;
+import androidx.sqlite.db.SupportSQLiteDatabase;
+
+@Database(entities = {ReceivedBtDataEntity.class, MonitoredPerson.class}, version = 4)
+public abstract class InnovaDatabase extends RoomDatabase {
+    private static InnovaDatabase instance;
+    
+    // Migration from version 1 to 2 - adds unique index
+    static final Migration MIGRATION_1_2 = new Migration(1, 2) {
+        @Override
+        public void migrate(SupportSQLiteDatabase database) {
+            // Create unique index on (device_address, timestamp, received_msg)
+            database.execSQL("CREATE UNIQUE INDEX index_received_bt_data_device_address_timestamp_received_msg " +
+                    "ON received_bt_data (device_address, timestamp, received_msg)");
+        }
+    };
+
+    public abstract ReceivedBtDataDao receivedBtDataDao();
+    
+    public abstract MonitoredPersonDao monitoredPersonDao();
+
+    public static synchronized InnovaDatabase getInstance(Context context) {
+        if (instance == null) {
+            instance = Room.databaseBuilder(context.getApplicationContext(),
+                    InnovaDatabase.class, "my_database")
+                    .addMigrations(MIGRATION_1_2)
+                    .fallbackToDestructiveMigration() // Fallback for development
+                    .build();
+            
+            // One-liner DB path log (once)
+            android.util.Log.i("DB", "Path=" + context.getDatabasePath("my_database").getAbsolutePath());
+        }
+        return instance;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java
index 904742a..086deff 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java
@@ -1,269 +1,269 @@
-package com.melisa.innovamotionapp.data.database;
-
-import androidx.lifecycle.LiveData;
-import androidx.room.Dao;
-import androidx.room.Insert;
-import androidx.room.OnConflictStrategy;
-import androidx.room.Query;
-
-import java.util.List;
-
-/**
- * DAO for local persistence of received Bluetooth messages.
- * Inserts are idempotent thanks to IGNORE + unique composite index.
- */
-@Dao
-public interface ReceivedBtDataDao {
-
-    @Insert(onConflict = OnConflictStrategy.IGNORE)
-    long insert(ReceivedBtDataEntity entity);
-
-    @Insert(onConflict = OnConflictStrategy.IGNORE)
-    void insertAll(List<ReceivedBtDataEntity> entities);
-
-    // Fetch all data for a specific device address, ordered by timestamp
-    @Query("SELECT * FROM received_bt_data WHERE device_address = :deviceAddress ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getDataForDevice(String deviceAddress);
-
-    // Fetch data for a specific device within a timestamp range
-    @Query("SELECT * FROM received_bt_data WHERE device_address = :deviceAddress AND timestamp BETWEEN :startTime AND :endTime ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getDataForDeviceInRange(String deviceAddress, long startTime, long endTime);
-
-    // Fetch all data from all devices (if needed)
-    @Query("SELECT * FROM received_bt_data ORDER BY timestamp DESC")
-    LiveData<List<ReceivedBtDataEntity>> getAllData();
-
-    // Synchronous version for background sync operations
-    @Query("SELECT * FROM received_bt_data ORDER BY timestamp ASC")
-    List<ReceivedBtDataEntity> getAllDataSync();
-
-    // Check if a specific message exists (for conflict resolution)
-    @Query("SELECT COUNT(*) FROM received_bt_data WHERE device_address = :deviceAddress AND timestamp = :timestamp AND received_msg = :receivedMsg")
-    int messageExists(String deviceAddress, long timestamp, String receivedMsg);
-
-    // Owner-aware existence check matching the unique index
-    @Query("SELECT COUNT(*) FROM received_bt_data WHERE owner_user_id = :owner AND device_address = :deviceAddress AND timestamp = :timestamp AND received_msg = :receivedMsg")
-    int messageExistsOwned(String owner, String deviceAddress, long timestamp, String receivedMsg);
-
-    // Get the maximum timestamp from local database for incremental backfill
-    // Returns 0 if database is empty (for initial backfill)
-    @Query("SELECT COALESCE(MAX(timestamp), 0) FROM received_bt_data")
-    long getMaxTimestampSync();
-
-    // Get the latest message from any device (for supervisor feed)
-    // Observes the most recent message regardless of device address
-    @Query("SELECT * FROM received_bt_data ORDER BY timestamp DESC LIMIT 1")
-    LiveData<ReceivedBtDataEntity> getLatestMessage();
-
-    // Get the latest message for a specific device (extended feature for supervisors)
-    // Useful when supervisors want to monitor a specific supervised user
-    @Query("SELECT * FROM received_bt_data WHERE device_address = :deviceAddress ORDER BY timestamp DESC LIMIT 1")
-    LiveData<ReceivedBtDataEntity> getLatestForDevice(String deviceAddress);
-
-    // Supervisor-specific queries with owner filtering
-    
-    // Delete data that doesn't belong to current supervised users (for data cleanup)
-    @Query("DELETE FROM received_bt_data WHERE owner_user_id NOT IN (:uids)")
-    int deleteWhereOwnerNotIn(List<String> uids);
-    
-    // Get max timestamp for a specific owner (for backfill)
-    @Query("SELECT COALESCE(MAX(timestamp), 0) FROM received_bt_data WHERE owner_user_id = :uid")
-    long getMaxTimestampForOwner(String uid);
-    
-    // Get latest message for a specific owner (supervisor feed)
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp DESC LIMIT 1")
-    LiveData<ReceivedBtDataEntity> getLatestForOwner(String ownerUserId);
-    
-    // Get latest message from any of the supervised users (supervisor feed)
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id IN (:ownerUserIds) ORDER BY timestamp DESC LIMIT 1")
-    LiveData<ReceivedBtDataEntity> getLatestForOwners(List<String> ownerUserIds);
-    
-    // Get all data for a specific owner (for supervisor monitoring)
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getDataForOwner(String ownerUserId);
-    
-    // Get all data for multiple owners (for supervisor monitoring)
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id IN (:ownerUserIds) ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getDataForOwners(List<String> ownerUserIds);
-    
-    // Clear all data (for sign-out cleanup)
-    @Query("DELETE FROM received_bt_data")
-    int clearAllData();
-
-    // One-time repair: set owner for legacy NULL rows
-    @Query("UPDATE received_bt_data SET owner_user_id = :owner WHERE owner_user_id IS NULL")
-    int migrateSetOwnerForNull(String owner);
-    
-    // Debug helpers for sync verification
-    @Query("SELECT COUNT(*) FROM received_bt_data")
-    int countAll();
-    
-    @Query("SELECT COUNT(*) FROM received_bt_data WHERE owner_user_id = :ownerUserId")
-    int countForOwner(String ownerUserId);
-    
-    @Query("SELECT owner_user_id, COUNT(*) as c FROM received_bt_data GROUP BY owner_user_id")
-    List<OwnerCount> countByOwner();
-    
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp DESC LIMIT :limit")
-    List<ReceivedBtDataEntity> latestForOwner(String ownerUserId, int limit);
-    
-    // Helper class for countByOwner query
-    class OwnerCount {
-        @androidx.room.ColumnInfo(name = "owner_user_id") 
-        public String owner;
-        @androidx.room.ColumnInfo(name = "c") 
-        public int count;
-    }
-    
-    // -------- Owner-filtered readers used by Activities --------
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getAllForOwnerLive(String ownerUid);
-    
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND timestamp BETWEEN :start AND :end ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getRangeForOwnerLive(String ownerUid, long start, long end);
-    
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid ORDER BY timestamp DESC LIMIT 1")
-    LiveData<ReceivedBtDataEntity> getLatestForOwnerLive(String ownerUid);
-    
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND device_address = :device ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getAllForOwnerAndDeviceLive(String ownerUid, String device);
-
-    // -------- User-centric aliases (unified naming: user == owner) --------
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :userId ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getAllForUserLive(String userId);
-
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :userId AND timestamp BETWEEN :start AND :end ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getRangeForUserLive(String userId, long start, long end);
-
-    // ======== SENSOR-SPECIFIC QUERIES (Multi-User Protocol) ========
-    
-    /**
-     * Get the latest reading for a specific sensor/person.
-     * Used to show current posture of a monitored person.
-     */
-    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
-    LiveData<ReceivedBtDataEntity> getLatestForSensor(String sensorId);
-
-    /**
-     * Get all readings for a specific sensor/person, ordered by timestamp.
-     * Used for history/timeline view of a single person.
-     */
-    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getAllForSensor(String sensorId);
-
-    /**
-     * Get readings for a specific sensor within a timestamp range.
-     * Used for date-filtered statistics/energy view of a single person.
-     */
-    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId AND timestamp BETWEEN :startTime AND :endTime ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getRangeForSensor(String sensorId, long startTime, long endTime);
-
-    /**
-     * Get all distinct sensor IDs in the database.
-     * Used to populate dropdown lists of monitored persons.
-     */
-    @Query("SELECT DISTINCT sensor_id FROM received_bt_data")
-    LiveData<List<String>> getDistinctSensorIds();
-
-    /**
-     * Get the latest reading for each sensor (one row per person).
-     * Used for dashboard view showing all monitored persons with their current posture.
-     * 
-     * QUERY OPTIMIZATION NOTE:
-     * This query is efficient because it:
-     * 1. Uses a subquery to find max timestamp per sensor (single pass)
-     * 2. Joins back to get full row data
-     * 3. Avoids N+1 queries (one query for all sensors, not one per sensor)
-     * 
-     * Performance: O(n) where n = total rows, regardless of sensor count.
-     * Much better than N separate queries where N = sensor count.
-     */
-    @Query("SELECT r.* FROM received_bt_data r " +
-           "INNER JOIN (SELECT sensor_id, MAX(timestamp) as max_ts FROM received_bt_data GROUP BY sensor_id) latest " +
-           "ON r.sensor_id = latest.sensor_id AND r.timestamp = latest.max_ts")
-    LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensor();
-
-    /**
-     * Get the latest reading for a specific owner and sensor combination.
-     * Used when supervisor wants to see a specific person from a specific aggregator.
-     */
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
-    LiveData<ReceivedBtDataEntity> getLatestForOwnerAndSensor(String ownerUid, String sensorId);
-
-    /**
-     * Get all distinct sensor IDs for a specific owner/aggregator.
-     * Used to list all monitored persons belonging to a specific aggregator.
-     */
-    @Query("SELECT DISTINCT sensor_id FROM received_bt_data WHERE owner_user_id = :ownerUid")
-    LiveData<List<String>> getDistinctSensorIdsForOwner(String ownerUid);
-
-    /**
-     * Get the latest reading for each sensor belonging to a specific owner.
-     * Dashboard view for supervisor showing all persons from one aggregator.
-     */
-    @Query("SELECT r.* FROM received_bt_data r " +
-           "INNER JOIN (SELECT sensor_id, MAX(timestamp) as max_ts FROM received_bt_data WHERE owner_user_id = :ownerUid GROUP BY sensor_id) latest " +
-           "ON r.sensor_id = latest.sensor_id AND r.timestamp = latest.max_ts " +
-           "WHERE r.owner_user_id = :ownerUid")
-    LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensorByOwner(String ownerUid);
-
-    /**
-     * Get all readings for a specific owner and sensor, ordered by timestamp.
-     * Used for detailed history of one person from one aggregator.
-     */
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id = :sensorId ORDER BY timestamp ASC")
-    LiveData<List<ReceivedBtDataEntity>> getAllForOwnerAndSensor(String ownerUid, String sensorId);
-
-    /**
-     * Count readings per sensor (for debugging/stats).
-     */
-    @Query("SELECT sensor_id, COUNT(*) as c FROM received_bt_data GROUP BY sensor_id")
-    List<SensorCount> countBySensor();
-
-    /**
-     * Helper class for countBySensor query.
-     */
-    class SensorCount {
-        @androidx.room.ColumnInfo(name = "sensor_id")
-        public String sensorId;
-        @androidx.room.ColumnInfo(name = "c")
-        public int count;
-    }
-
-    // ======== MESSAGE LOG UI QUERIES ========
-    
-    /**
-     * Get recent messages across all sensors, ordered by timestamp descending.
-     * Used for the message log UI.
-     */
-    @Query("SELECT * FROM received_bt_data ORDER BY timestamp DESC LIMIT :limit")
-    LiveData<List<ReceivedBtDataEntity>> getRecentMessages(int limit);
-
-    /**
-     * Get recent messages for a specific sensor, ordered by timestamp descending.
-     * Used for filtered message log UI.
-     */
-    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp DESC LIMIT :limit")
-    LiveData<List<ReceivedBtDataEntity>> getMessagesForSensor(String sensorId, int limit);
-
-    // TEMPORARY DEBUG HELPERS (remove later)
-    @Query("SELECT COUNT(*) FROM received_bt_data")
-    int dbgCountAll();
-    
-    @Query("SELECT COUNT(*) FROM received_bt_data WHERE owner_user_id = :ownerUserId")
-    int dbgCountForOwner(String ownerUserId);
-    
-    @Query("SELECT owner_user_id AS owner, COUNT(*) AS c FROM received_bt_data GROUP BY owner_user_id")
-    List<DbgOwnerCount> dbgCountByOwner();
-    
-    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp DESC LIMIT :limit")
-    List<ReceivedBtDataEntity> dbgLatestForOwner(String ownerUserId, int limit);
-    
-    // Helper class for dbgCountByOwner query
-    class DbgOwnerCount {
-        @androidx.room.ColumnInfo(name = "owner") 
-        public String owner;
-        @androidx.room.ColumnInfo(name = "c") 
-        public int count;
-    }
+package com.melisa.innovamotionapp.data.database;
+
+import androidx.lifecycle.LiveData;
+import androidx.room.Dao;
+import androidx.room.Insert;
+import androidx.room.OnConflictStrategy;
+import androidx.room.Query;
+
+import java.util.List;
+
+/**
+ * DAO for local persistence of received Bluetooth messages.
+ * Inserts are idempotent thanks to IGNORE + unique composite index.
+ */
+@Dao
+public interface ReceivedBtDataDao {
+
+    @Insert(onConflict = OnConflictStrategy.IGNORE)
+    long insert(ReceivedBtDataEntity entity);
+
+    @Insert(onConflict = OnConflictStrategy.IGNORE)
+    void insertAll(List<ReceivedBtDataEntity> entities);
+
+    // Fetch all data for a specific device address, ordered by timestamp
+    @Query("SELECT * FROM received_bt_data WHERE device_address = :deviceAddress ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getDataForDevice(String deviceAddress);
+
+    // Fetch data for a specific device within a timestamp range
+    @Query("SELECT * FROM received_bt_data WHERE device_address = :deviceAddress AND timestamp BETWEEN :startTime AND :endTime ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getDataForDeviceInRange(String deviceAddress, long startTime, long endTime);
+
+    // Fetch all data from all devices (if needed)
+    @Query("SELECT * FROM received_bt_data ORDER BY timestamp DESC")
+    LiveData<List<ReceivedBtDataEntity>> getAllData();
+
+    // Synchronous version for background sync operations
+    @Query("SELECT * FROM received_bt_data ORDER BY timestamp ASC")
+    List<ReceivedBtDataEntity> getAllDataSync();
+
+    // Check if a specific message exists (for conflict resolution)
+    @Query("SELECT COUNT(*) FROM received_bt_data WHERE device_address = :deviceAddress AND timestamp = :timestamp AND received_msg = :receivedMsg")
+    int messageExists(String deviceAddress, long timestamp, String receivedMsg);
+
+    // Owner-aware existence check matching the unique index
+    @Query("SELECT COUNT(*) FROM received_bt_data WHERE owner_user_id = :owner AND device_address = :deviceAddress AND timestamp = :timestamp AND received_msg = :receivedMsg")
+    int messageExistsOwned(String owner, String deviceAddress, long timestamp, String receivedMsg);
+
+    // Get the maximum timestamp from local database for incremental backfill
+    // Returns 0 if database is empty (for initial backfill)
+    @Query("SELECT COALESCE(MAX(timestamp), 0) FROM received_bt_data")
+    long getMaxTimestampSync();
+
+    // Get the latest message from any device (for supervisor feed)
+    // Observes the most recent message regardless of device address
+    @Query("SELECT * FROM received_bt_data ORDER BY timestamp DESC LIMIT 1")
+    LiveData<ReceivedBtDataEntity> getLatestMessage();
+
+    // Get the latest message for a specific device (extended feature for supervisors)
+    // Useful when supervisors want to monitor a specific supervised user
+    @Query("SELECT * FROM received_bt_data WHERE device_address = :deviceAddress ORDER BY timestamp DESC LIMIT 1")
+    LiveData<ReceivedBtDataEntity> getLatestForDevice(String deviceAddress);
+
+    // Supervisor-specific queries with owner filtering
+    
+    // Delete data that doesn't belong to current supervised users (for data cleanup)
+    @Query("DELETE FROM received_bt_data WHERE owner_user_id NOT IN (:uids)")
+    int deleteWhereOwnerNotIn(List<String> uids);
+    
+    // Get max timestamp for a specific owner (for backfill)
+    @Query("SELECT COALESCE(MAX(timestamp), 0) FROM received_bt_data WHERE owner_user_id = :uid")
+    long getMaxTimestampForOwner(String uid);
+    
+    // Get latest message for a specific owner (supervisor feed)
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp DESC LIMIT 1")
+    LiveData<ReceivedBtDataEntity> getLatestForOwner(String ownerUserId);
+    
+    // Get latest message from any of the supervised users (supervisor feed)
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id IN (:ownerUserIds) ORDER BY timestamp DESC LIMIT 1")
+    LiveData<ReceivedBtDataEntity> getLatestForOwners(List<String> ownerUserIds);
+    
+    // Get all data for a specific owner (for supervisor monitoring)
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getDataForOwner(String ownerUserId);
+    
+    // Get all data for multiple owners (for supervisor monitoring)
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id IN (:ownerUserIds) ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getDataForOwners(List<String> ownerUserIds);
+    
+    // Clear all data (for sign-out cleanup)
+    @Query("DELETE FROM received_bt_data")
+    int clearAllData();
+
+    // One-time repair: set owner for legacy NULL rows
+    @Query("UPDATE received_bt_data SET owner_user_id = :owner WHERE owner_user_id IS NULL")
+    int migrateSetOwnerForNull(String owner);
+    
+    // Debug helpers for sync verification
+    @Query("SELECT COUNT(*) FROM received_bt_data")
+    int countAll();
+    
+    @Query("SELECT COUNT(*) FROM received_bt_data WHERE owner_user_id = :ownerUserId")
+    int countForOwner(String ownerUserId);
+    
+    @Query("SELECT owner_user_id, COUNT(*) as c FROM received_bt_data GROUP BY owner_user_id")
+    List<OwnerCount> countByOwner();
+    
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp DESC LIMIT :limit")
+    List<ReceivedBtDataEntity> latestForOwner(String ownerUserId, int limit);
+    
+    // Helper class for countByOwner query
+    class OwnerCount {
+        @androidx.room.ColumnInfo(name = "owner_user_id") 
+        public String owner;
+        @androidx.room.ColumnInfo(name = "c") 
+        public int count;
+    }
+    
+    // -------- Owner-filtered readers used by Activities --------
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getAllForOwnerLive(String ownerUid);
+    
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND timestamp BETWEEN :start AND :end ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getRangeForOwnerLive(String ownerUid, long start, long end);
+    
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid ORDER BY timestamp DESC LIMIT 1")
+    LiveData<ReceivedBtDataEntity> getLatestForOwnerLive(String ownerUid);
+    
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND device_address = :device ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getAllForOwnerAndDeviceLive(String ownerUid, String device);
+
+    // -------- User-centric aliases (unified naming: user == owner) --------
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :userId ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getAllForUserLive(String userId);
+
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :userId AND timestamp BETWEEN :start AND :end ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getRangeForUserLive(String userId, long start, long end);
+
+    // ======== SENSOR-SPECIFIC QUERIES (Multi-User Protocol) ========
+    
+    /**
+     * Get the latest reading for a specific sensor/person.
+     * Used to show current posture of a monitored person.
+     */
+    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
+    LiveData<ReceivedBtDataEntity> getLatestForSensor(String sensorId);
+
+    /**
+     * Get all readings for a specific sensor/person, ordered by timestamp.
+     * Used for history/timeline view of a single person.
+     */
+    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getAllForSensor(String sensorId);
+
+    /**
+     * Get readings for a specific sensor within a timestamp range.
+     * Used for date-filtered statistics/energy view of a single person.
+     */
+    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId AND timestamp BETWEEN :startTime AND :endTime ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getRangeForSensor(String sensorId, long startTime, long endTime);
+
+    /**
+     * Get all distinct sensor IDs in the database.
+     * Used to populate dropdown lists of monitored persons.
+     */
+    @Query("SELECT DISTINCT sensor_id FROM received_bt_data")
+    LiveData<List<String>> getDistinctSensorIds();
+
+    /**
+     * Get the latest reading for each sensor (one row per person).
+     * Used for dashboard view showing all monitored persons with their current posture.
+     * 
+     * QUERY OPTIMIZATION NOTE:
+     * This query is efficient because it:
+     * 1. Uses a subquery to find max timestamp per sensor (single pass)
+     * 2. Joins back to get full row data
+     * 3. Avoids N+1 queries (one query for all sensors, not one per sensor)
+     * 
+     * Performance: O(n) where n = total rows, regardless of sensor count.
+     * Much better than N separate queries where N = sensor count.
+     */
+    @Query("SELECT r.* FROM received_bt_data r " +
+           "INNER JOIN (SELECT sensor_id, MAX(timestamp) as max_ts FROM received_bt_data GROUP BY sensor_id) latest " +
+           "ON r.sensor_id = latest.sensor_id AND r.timestamp = latest.max_ts")
+    LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensor();
+
+    /**
+     * Get the latest reading for a specific owner and sensor combination.
+     * Used when supervisor wants to see a specific person from a specific aggregator.
+     */
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
+    LiveData<ReceivedBtDataEntity> getLatestForOwnerAndSensor(String ownerUid, String sensorId);
+
+    /**
+     * Get all distinct sensor IDs for a specific owner/aggregator.
+     * Used to list all monitored persons belonging to a specific aggregator.
+     */
+    @Query("SELECT DISTINCT sensor_id FROM received_bt_data WHERE owner_user_id = :ownerUid")
+    LiveData<List<String>> getDistinctSensorIdsForOwner(String ownerUid);
+
+    /**
+     * Get the latest reading for each sensor belonging to a specific owner.
+     * Dashboard view for supervisor showing all persons from one aggregator.
+     */
+    @Query("SELECT r.* FROM received_bt_data r " +
+           "INNER JOIN (SELECT sensor_id, MAX(timestamp) as max_ts FROM received_bt_data WHERE owner_user_id = :ownerUid GROUP BY sensor_id) latest " +
+           "ON r.sensor_id = latest.sensor_id AND r.timestamp = latest.max_ts " +
+           "WHERE r.owner_user_id = :ownerUid")
+    LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensorByOwner(String ownerUid);
+
+    /**
+     * Get all readings for a specific owner and sensor, ordered by timestamp.
+     * Used for detailed history of one person from one aggregator.
+     */
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id = :sensorId ORDER BY timestamp ASC")
+    LiveData<List<ReceivedBtDataEntity>> getAllForOwnerAndSensor(String ownerUid, String sensorId);
+
+    /**
+     * Count readings per sensor (for debugging/stats).
+     */
+    @Query("SELECT sensor_id, COUNT(*) as c FROM received_bt_data GROUP BY sensor_id")
+    List<SensorCount> countBySensor();
+
+    /**
+     * Helper class for countBySensor query.
+     */
+    class SensorCount {
+        @androidx.room.ColumnInfo(name = "sensor_id")
+        public String sensorId;
+        @androidx.room.ColumnInfo(name = "c")
+        public int count;
+    }
+
+    // ======== MESSAGE LOG UI QUERIES ========
+    
+    /**
+     * Get recent messages across all sensors, ordered by timestamp descending.
+     * Used for the message log UI.
+     */
+    @Query("SELECT * FROM received_bt_data ORDER BY timestamp DESC LIMIT :limit")
+    LiveData<List<ReceivedBtDataEntity>> getRecentMessages(int limit);
+
+    /**
+     * Get recent messages for a specific sensor, ordered by timestamp descending.
+     * Used for filtered message log UI.
+     */
+    @Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp DESC LIMIT :limit")
+    LiveData<List<ReceivedBtDataEntity>> getMessagesForSensor(String sensorId, int limit);
+
+    // TEMPORARY DEBUG HELPERS (remove later)
+    @Query("SELECT COUNT(*) FROM received_bt_data")
+    int dbgCountAll();
+    
+    @Query("SELECT COUNT(*) FROM received_bt_data WHERE owner_user_id = :ownerUserId")
+    int dbgCountForOwner(String ownerUserId);
+    
+    @Query("SELECT owner_user_id AS owner, COUNT(*) AS c FROM received_bt_data GROUP BY owner_user_id")
+    List<DbgOwnerCount> dbgCountByOwner();
+    
+    @Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUserId ORDER BY timestamp DESC LIMIT :limit")
+    List<ReceivedBtDataEntity> dbgLatestForOwner(String ownerUserId, int limit);
+    
+    // Helper class for dbgCountByOwner query
+    class DbgOwnerCount {
+        @androidx.room.ColumnInfo(name = "owner") 
+        public String owner;
+        @androidx.room.ColumnInfo(name = "c") 
+        public int count;
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataEntity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataEntity.java
index 8fc6130..886849b 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataEntity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataEntity.java
@@ -1,113 +1,113 @@
-package com.melisa.innovamotionapp.data.database;
-
-import androidx.annotation.NonNull;
-import androidx.room.ColumnInfo;
-import androidx.room.Entity;
-import androidx.room.Index;
-import androidx.room.PrimaryKey;
-
-/**
- * Entity representing a received Bluetooth message from the multi-user protocol.
- * 
- * Each reading includes a sensorId identifying the monitored person (e.g., "sensor001", UUID, etc.)
- * per the protocol format: "sensorId;hexCode\n"
- * 
- * The unique composite index ensures idempotent inserts across users and sensors.
- */
-@Entity(
-    tableName = "received_bt_data",
-    indices = {
-        // Prevent duplicates: same owner, device, sensor, timestamp, and message
-        @Index(value = {"owner_user_id", "device_address", "sensor_id", "timestamp", "received_msg"}, unique = true),
-        // Query optimization indexes
-        @Index(value = {"owner_user_id", "timestamp"}),
-        @Index(value = {"sensor_id"}),
-        @Index(value = {"owner_user_id", "sensor_id"})
-    }
-)
-public class ReceivedBtDataEntity {
-    @PrimaryKey(autoGenerate = true)
-    @ColumnInfo(name = "id")
-    public long id;
-
-    @NonNull
-    @ColumnInfo(name = "device_address")
-    private String deviceAddress;
-
-    @ColumnInfo(name = "timestamp")
-    private long timestamp;
-
-    @NonNull
-    @ColumnInfo(name = "received_msg")
-    private String receivedMsg;
-
-    @NonNull
-    @ColumnInfo(name = "owner_user_id")
-    private String ownerUserId;
-
-    /**
-     * The sensor/person ID from the hardware protocol (e.g., "sensor001", UUID).
-     * Mandatory field - every reading must identify the monitored person.
-     */
-    @NonNull
-    @ColumnInfo(name = "sensor_id")
-    private String sensorId;
-
-    /**
-     * Primary constructor for multi-user protocol data.
-     *
-     * @param deviceAddress Bluetooth MAC address of the hardware device
-     * @param timestamp     When the reading was received (epoch millis)
-     * @param receivedMsg   The hex code payload (e.g., "0xAB3311")
-     * @param ownerUserId   The aggregator user ID who owns this data
-     * @param sensorId      The monitored person's ID from hardware (e.g., "sensor001")
-     */
-    public ReceivedBtDataEntity(
-            @NonNull String deviceAddress,
-            long timestamp,
-            @NonNull String receivedMsg,
-            @NonNull String ownerUserId,
-            @NonNull String sensorId) {
-        this.deviceAddress = deviceAddress;
-        this.timestamp = timestamp;
-        this.receivedMsg = receivedMsg;
-        this.ownerUserId = ownerUserId;
-        this.sensorId = sensorId;
-    }
-
-    // ========== Getters ==========
-
-    public long getId() {
-        return id;
-    }
-
-    public void setId(long id) {
-        this.id = id;
-    }
-
-    @NonNull
-    public String getDeviceAddress() {
-        return deviceAddress;
-    }
-
-    public long getTimestamp() {
-        return timestamp;
-    }
-
-    @NonNull
-    public String getReceivedMsg() {
-        return receivedMsg;
-    }
-
-    @NonNull
-    public String getOwnerUserId() {
-        return ownerUserId;
-    }
-
-    @NonNull
-    public String getSensorId() {
-        return sensorId;
-    }
-}
-
-
+package com.melisa.innovamotionapp.data.database;
+
+import androidx.annotation.NonNull;
+import androidx.room.ColumnInfo;
+import androidx.room.Entity;
+import androidx.room.Index;
+import androidx.room.PrimaryKey;
+
+/**
+ * Entity representing a received Bluetooth message from the multi-user protocol.
+ * 
+ * Each reading includes a sensorId identifying the monitored person (e.g., "sensor001", UUID, etc.)
+ * per the protocol format: "sensorId;hexCode\n"
+ * 
+ * The unique composite index ensures idempotent inserts across users and sensors.
+ */
+@Entity(
+    tableName = "received_bt_data",
+    indices = {
+        // Prevent duplicates: same owner, device, sensor, timestamp, and message
+        @Index(value = {"owner_user_id", "device_address", "sensor_id", "timestamp", "received_msg"}, unique = true),
+        // Query optimization indexes
+        @Index(value = {"owner_user_id", "timestamp"}),
+        @Index(value = {"sensor_id"}),
+        @Index(value = {"owner_user_id", "sensor_id"})
+    }
+)
+public class ReceivedBtDataEntity {
+    @PrimaryKey(autoGenerate = true)
+    @ColumnInfo(name = "id")
+    public long id;
+
+    @NonNull
+    @ColumnInfo(name = "device_address")
+    private String deviceAddress;
+
+    @ColumnInfo(name = "timestamp")
+    private long timestamp;
+
+    @NonNull
+    @ColumnInfo(name = "received_msg")
+    private String receivedMsg;
+
+    @NonNull
+    @ColumnInfo(name = "owner_user_id")
+    private String ownerUserId;
+
+    /**
+     * The sensor/person ID from the hardware protocol (e.g., "sensor001", UUID).
+     * Mandatory field - every reading must identify the monitored person.
+     */
+    @NonNull
+    @ColumnInfo(name = "sensor_id")
+    private String sensorId;
+
+    /**
+     * Primary constructor for multi-user protocol data.
+     *
+     * @param deviceAddress Bluetooth MAC address of the hardware device
+     * @param timestamp     When the reading was received (epoch millis)
+     * @param receivedMsg   The hex code payload (e.g., "0xAB3311")
+     * @param ownerUserId   The aggregator user ID who owns this data
+     * @param sensorId      The monitored person's ID from hardware (e.g., "sensor001")
+     */
+    public ReceivedBtDataEntity(
+            @NonNull String deviceAddress,
+            long timestamp,
+            @NonNull String receivedMsg,
+            @NonNull String ownerUserId,
+            @NonNull String sensorId) {
+        this.deviceAddress = deviceAddress;
+        this.timestamp = timestamp;
+        this.receivedMsg = receivedMsg;
+        this.ownerUserId = ownerUserId;
+        this.sensorId = sensorId;
+    }
+
+    // ========== Getters ==========
+
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+
+    @NonNull
+    public String getDeviceAddress() {
+        return deviceAddress;
+    }
+
+    public long getTimestamp() {
+        return timestamp;
+    }
+
+    @NonNull
+    public String getReceivedMsg() {
+        return receivedMsg;
+    }
+
+    @NonNull
+    public String getOwnerUserId() {
+        return ownerUserId;
+    }
+
+    @NonNull
+    public String getSensorId() {
+        return sensorId;
+    }
+}
+
+
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/Posture.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/Posture.java
index 94317d0..728afa7 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/Posture.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/Posture.java
@@ -1,11 +1,11 @@
-package com.melisa.innovamotionapp.data.posture;
-
-public abstract class Posture {
-    public abstract int getRisc();
-    public abstract int getTextCode();
-    public abstract int getVideoCode();
-    public abstract int getPictureCode();
-    public abstract int getCalories();
-}
-
-
+package com.melisa.innovamotionapp.data.posture;
+
+public abstract class Posture {
+    public abstract int getRisc();
+    public abstract int getTextCode();
+    public abstract int getVideoCode();
+    public abstract int getPictureCode();
+    public abstract int getCalories();
+}
+
+
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureDataLoader.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureDataLoader.java
index 724c975..ed9c08d 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureDataLoader.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureDataLoader.java
@@ -1,25 +1,25 @@
-package com.melisa.innovamotionapp.data.posture;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-public class PostureDataLoader {
-    public static List<Posture> loadPostures(File file) throws IOException {
-        List<Posture> postures = new ArrayList<>();
-
-        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
-            String line;
-            while ((line = reader.readLine()) != null) {
-                Posture posture = PostureFactory.createPosture(line); // Use the factory to create the posture
-                postures.add(posture);
-            }
-        }
-
-        return postures;
-    }
-}
-
+package com.melisa.innovamotionapp.data.posture;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PostureDataLoader {
+    public static List<Posture> loadPostures(File file) throws IOException {
+        List<Posture> postures = new ArrayList<>();
+
+        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
+            String line;
+            while ((line = reader.readLine()) != null) {
+                Posture posture = PostureFactory.createPosture(line); // Use the factory to create the posture
+                postures.add(posture);
+            }
+        }
+
+        return postures;
+    }
+}
+
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureFactory.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureFactory.java
index 461ce14..c437e89 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureFactory.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureFactory.java
@@ -1,59 +1,59 @@
-package com.melisa.innovamotionapp.data.posture;
-
-import android.util.Log;
-
-import com.melisa.innovamotionapp.data.posture.types.FallingPosture;
-import com.melisa.innovamotionapp.data.posture.types.SittingPosture;
-import com.melisa.innovamotionapp.data.posture.types.StandingPosture;
-import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
-import com.melisa.innovamotionapp.data.posture.types.UnusedFootwearPosture;
-import com.melisa.innovamotionapp.data.posture.types.WalkingPosture;
-
-public class PostureFactory {
-
-    private static final String TAG = "PostureFactory"; // Tag for logging
-
-    /**
-     * Creates a Posture object based on a received data string.
-     * The input string is expected to be a hexadecimal representation (e.g., "0xAB3311").
-     * Comparisons are case-insensitive for the input string.
-     *
-     * @param receivedData The input string representing the posture code.
-     * @return A concrete Posture object corresponding to the received data,
-     * or an UnknownPosture if the data is null, empty, or doesn't match any known posture.
-     */
-    public static Posture createPosture(String receivedData) {
-        // Basic input validation: Check for null or empty string
-        if (receivedData == null || receivedData.isEmpty()) {
-            Log.w(TAG, "Received data is null or empty. Returning UnknownPosture.");
-            return new UnknownPosture();
-        }
-
-        // Convert the received data to lowercase for case-insensitive comparison.
-        // This handles "0xAB3311", "0XAB3311", "0xab3311", etc.
-        String normalizedData = receivedData.toLowerCase();
-
-        // Use a switch statement for string comparison.
-        switch (normalizedData) {
-            case "0x793248":
-                Log.d(TAG, "Matched " + normalizedData + ": Returning UnusedFootwearPosture.");
-                return new UnusedFootwearPosture();
-            case "0xab3311": // Note: case is lowercase due to normalization
-                Log.d(TAG, "Matched " + normalizedData + ": Returning StandingPosture.");
-                return new StandingPosture();
-            case "0xac4312": // Note: case is lowercase due to normalization
-                Log.d(TAG, "Matched " + normalizedData + ": Returning SittingPosture.");
-                return new SittingPosture();
-            case "0xba3311": // Note: case is lowercase due to normalization
-                Log.d(TAG, "Matched " + normalizedData + ": Returning WalkingPosture.");
-                return new WalkingPosture();
-            case "0xef0112": // Note: case is lowercase due to normalization
-                Log.d(TAG, "Matched " + normalizedData + ": Returning FallingPosture.");
-                return new FallingPosture();
-            default:
-                // Log when no match is found
-                Log.i(TAG, "No matching posture found for received data: \"" + receivedData + "\". Returning UnknownPosture.");
-                return new UnknownPosture();
-        }
-    }
+package com.melisa.innovamotionapp.data.posture;
+
+import android.util.Log;
+
+import com.melisa.innovamotionapp.data.posture.types.FallingPosture;
+import com.melisa.innovamotionapp.data.posture.types.SittingPosture;
+import com.melisa.innovamotionapp.data.posture.types.StandingPosture;
+import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
+import com.melisa.innovamotionapp.data.posture.types.UnusedFootwearPosture;
+import com.melisa.innovamotionapp.data.posture.types.WalkingPosture;
+
+public class PostureFactory {
+
+    private static final String TAG = "PostureFactory"; // Tag for logging
+
+    /**
+     * Creates a Posture object based on a received data string.
+     * The input string is expected to be a hexadecimal representation (e.g., "0xAB3311").
+     * Comparisons are case-insensitive for the input string.
+     *
+     * @param receivedData The input string representing the posture code.
+     * @return A concrete Posture object corresponding to the received data,
+     * or an UnknownPosture if the data is null, empty, or doesn't match any known posture.
+     */
+    public static Posture createPosture(String receivedData) {
+        // Basic input validation: Check for null or empty string
+        if (receivedData == null || receivedData.isEmpty()) {
+            Log.w(TAG, "Received data is null or empty. Returning UnknownPosture.");
+            return new UnknownPosture();
+        }
+
+        // Convert the received data to lowercase for case-insensitive comparison.
+        // This handles "0xAB3311", "0XAB3311", "0xab3311", etc.
+        String normalizedData = receivedData.toLowerCase();
+
+        // Use a switch statement for string comparison.
+        switch (normalizedData) {
+            case "0x793248":
+                Log.d(TAG, "Matched " + normalizedData + ": Returning UnusedFootwearPosture.");
+                return new UnusedFootwearPosture();
+            case "0xab3311": // Note: case is lowercase due to normalization
+                Log.d(TAG, "Matched " + normalizedData + ": Returning StandingPosture.");
+                return new StandingPosture();
+            case "0xac4312": // Note: case is lowercase due to normalization
+                Log.d(TAG, "Matched " + normalizedData + ": Returning SittingPosture.");
+                return new SittingPosture();
+            case "0xba3311": // Note: case is lowercase due to normalization
+                Log.d(TAG, "Matched " + normalizedData + ": Returning WalkingPosture.");
+                return new WalkingPosture();
+            case "0xef0112": // Note: case is lowercase due to normalization
+                Log.d(TAG, "Matched " + normalizedData + ": Returning FallingPosture.");
+                return new FallingPosture();
+            default:
+                // Log when no match is found
+                Log.i(TAG, "No matching posture found for received data: \"" + receivedData + "\". Returning UnknownPosture.");
+                return new UnknownPosture();
+        }
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/FallingPosture.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/FallingPosture.java
index 41509bf..7918c85 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/FallingPosture.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/FallingPosture.java
@@ -1,31 +1,31 @@
-package com.melisa.innovamotionapp.data.posture.types;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.data.posture.Posture;
-
-public class FallingPosture extends Posture {
-    @Override
-    public int getRisc() {
-        return R.string.posture_falling_risk;
-    }
-
-    @Override
-    public int getTextCode() {
-        return R.string.posture_falling_msg;
-    }
-
-    @Override
-    public int getVideoCode() {
-        return R.raw.cadere_video;
-    }
-
-    @Override
-    public int getPictureCode() {
-        return R.raw.cadere;
-    }
-
-    @Override
-    public int getCalories() {
-        return 10;
-    }
-}
+package com.melisa.innovamotionapp.data.posture.types;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.data.posture.Posture;
+
+public class FallingPosture extends Posture {
+    @Override
+    public int getRisc() {
+        return R.string.posture_falling_risk;
+    }
+
+    @Override
+    public int getTextCode() {
+        return R.string.posture_falling_msg;
+    }
+
+    @Override
+    public int getVideoCode() {
+        return R.raw.cadere_video;
+    }
+
+    @Override
+    public int getPictureCode() {
+        return R.raw.cadere;
+    }
+
+    @Override
+    public int getCalories() {
+        return 10;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/SittingPosture.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/SittingPosture.java
index 054f116..168a145 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/SittingPosture.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/SittingPosture.java
@@ -1,30 +1,30 @@
-package com.melisa.innovamotionapp.data.posture.types;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.data.posture.Posture;
-
-public class SittingPosture extends Posture {
-    @Override
-    public int getRisc() {
-        return R.string.posture_sitting_risk;
-    }
-
-    @Override
-    public int getTextCode() {
-        return R.string.posture_sitting_msg;
-    }
-
-    @Override
-    public int getVideoCode() {
-        return R.raw.pe_scaun_movie;
-    }
-
-    @Override
-    public int getPictureCode() {
-        return R.raw.pe_scaun;
-    }
-    @Override
-    public int getCalories() {
-        return 2;
-    }
-}
+package com.melisa.innovamotionapp.data.posture.types;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.data.posture.Posture;
+
+public class SittingPosture extends Posture {
+    @Override
+    public int getRisc() {
+        return R.string.posture_sitting_risk;
+    }
+
+    @Override
+    public int getTextCode() {
+        return R.string.posture_sitting_msg;
+    }
+
+    @Override
+    public int getVideoCode() {
+        return R.raw.pe_scaun_movie;
+    }
+
+    @Override
+    public int getPictureCode() {
+        return R.raw.pe_scaun;
+    }
+    @Override
+    public int getCalories() {
+        return 2;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/StandingPosture.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/StandingPosture.java
index 5270a18..54ac355 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/StandingPosture.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/StandingPosture.java
@@ -1,30 +1,30 @@
-package com.melisa.innovamotionapp.data.posture.types;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.data.posture.Posture;
-
-public class StandingPosture extends Posture {
-    @Override
-    public int getRisc() {
-        return R.string.posture_standing_risk;
-    }
-
-    @Override
-    public int getTextCode() {
-        return R.string.posture_standing_msg;
-    }
-
-    @Override
-    public int getVideoCode() {
-        return R.raw.in_picioare_movie;
-    }
-
-    @Override
-    public int getPictureCode() {
-        return R.raw.in_picioare;
-    }
-    @Override
-    public int getCalories() {
-        return 7;
-    }
-}
+package com.melisa.innovamotionapp.data.posture.types;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.data.posture.Posture;
+
+public class StandingPosture extends Posture {
+    @Override
+    public int getRisc() {
+        return R.string.posture_standing_risk;
+    }
+
+    @Override
+    public int getTextCode() {
+        return R.string.posture_standing_msg;
+    }
+
+    @Override
+    public int getVideoCode() {
+        return R.raw.in_picioare_movie;
+    }
+
+    @Override
+    public int getPictureCode() {
+        return R.raw.in_picioare;
+    }
+    @Override
+    public int getCalories() {
+        return 7;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnknownPosture.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnknownPosture.java
index 5a0a4cd..e329166 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnknownPosture.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnknownPosture.java
@@ -1,30 +1,30 @@
-package com.melisa.innovamotionapp.data.posture.types;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.data.posture.Posture;
-
-public class UnknownPosture extends Posture {
-    @Override
-    public int getRisc() {
-        return R.string.posture_unknown_risk;
-    }
-
-    @Override
-    public int getTextCode() {
-        return R.string.posture_unknown_msg;
-    }
-
-    @Override
-    public int getVideoCode() {
-        return -1;
-    }
-
-    @Override
-    public int getPictureCode() {
-        return R.raw.unknown;
-    }
-    @Override
-    public int getCalories() {
-        return 0;
-    }
-}
+package com.melisa.innovamotionapp.data.posture.types;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.data.posture.Posture;
+
+public class UnknownPosture extends Posture {
+    @Override
+    public int getRisc() {
+        return R.string.posture_unknown_risk;
+    }
+
+    @Override
+    public int getTextCode() {
+        return R.string.posture_unknown_msg;
+    }
+
+    @Override
+    public int getVideoCode() {
+        return -1;
+    }
+
+    @Override
+    public int getPictureCode() {
+        return R.raw.unknown;
+    }
+    @Override
+    public int getCalories() {
+        return 0;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnusedFootwearPosture.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnusedFootwearPosture.java
index 8627f08..4af33ae 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnusedFootwearPosture.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/UnusedFootwearPosture.java
@@ -1,30 +1,30 @@
-package com.melisa.innovamotionapp.data.posture.types;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.data.posture.Posture;
-
-public class UnusedFootwearPosture extends Posture {
-    @Override
-    public int getRisc() {
-        return R.string.posture_unused_footwear_risk;
-    }
-
-    @Override
-    public int getTextCode() {
-        return R.string.posture_unused_footwear_msg;
-    }
-
-    @Override
-    public int getVideoCode() {
-        return R.raw.neutilizat_video;
-    }
-
-    @Override
-    public int getPictureCode() {
-        return R.raw.neutilizat;
-    }
-    @Override
-    public int getCalories() {
-        return 0;
-    }
-}
+package com.melisa.innovamotionapp.data.posture.types;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.data.posture.Posture;
+
+public class UnusedFootwearPosture extends Posture {
+    @Override
+    public int getRisc() {
+        return R.string.posture_unused_footwear_risk;
+    }
+
+    @Override
+    public int getTextCode() {
+        return R.string.posture_unused_footwear_msg;
+    }
+
+    @Override
+    public int getVideoCode() {
+        return R.raw.neutilizat_video;
+    }
+
+    @Override
+    public int getPictureCode() {
+        return R.raw.neutilizat;
+    }
+    @Override
+    public int getCalories() {
+        return 0;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/WalkingPosture.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/WalkingPosture.java
index 4a6e36b..d2ed52c 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/WalkingPosture.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/data/posture/types/WalkingPosture.java
@@ -1,30 +1,30 @@
-package com.melisa.innovamotionapp.data.posture.types;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.data.posture.Posture;
-
-public class WalkingPosture extends Posture {
-    @Override
-    public int getRisc() {
-        return R.string.posture_walking_risk;
-    }
-
-    @Override
-    public int getTextCode() {
-        return R.string.posture_walking_msg;
-    }
-
-    @Override
-    public int getVideoCode() {
-        return R.raw.mers_movie;
-    }
-
-    @Override
-    public int getPictureCode() {
-        return R.raw.mers;
-    }
-    @Override
-    public int getCalories() {
-        return 10;
-    }
-}
+package com.melisa.innovamotionapp.data.posture.types;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.data.posture.Posture;
+
+public class WalkingPosture extends Posture {
+    @Override
+    public int getRisc() {
+        return R.string.posture_walking_risk;
+    }
+
+    @Override
+    public int getTextCode() {
+        return R.string.posture_walking_msg;
+    }
+
+    @Override
+    public int getVideoCode() {
+        return R.raw.mers_movie;
+    }
+
+    @Override
+    public int getPictureCode() {
+        return R.raw.mers;
+    }
+    @Override
+    public int getCalories() {
+        return 10;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/BluetoothStateReceiver.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/BluetoothStateReceiver.java
index 7ca2cfc..be43cdf 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/BluetoothStateReceiver.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/BluetoothStateReceiver.java
@@ -1,28 +1,28 @@
-package com.melisa.innovamotionapp.receivers;
-import android.bluetooth.BluetoothAdapter;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class BluetoothStateReceiver extends BroadcastReceiver {
-    private final BluetoothStateListener listener;
-
-    public interface BluetoothStateListener {
-        void onStateChanged(int state);
-    }
-
-    public BluetoothStateReceiver(BluetoothStateListener listener) {
-        this.listener = listener;
-    }
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        final String action = intent.getAction();
-        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)) {
-            int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
-            if (listener != null) {
-                listener.onStateChanged(state);
-            }
-        }
-    }
-}
+package com.melisa.innovamotionapp.receivers;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class BluetoothStateReceiver extends BroadcastReceiver {
+    private final BluetoothStateListener listener;
+
+    public interface BluetoothStateListener {
+        void onStateChanged(int state);
+    }
+
+    public BluetoothStateReceiver(BluetoothStateListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+        if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)) {
+            int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+            if (listener != null) {
+                listener.onStateChanged(state);
+            }
+        }
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/DiscoveryFinishedReceiver.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/DiscoveryFinishedReceiver.java
index 6fd0dd5..f6c2f40 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/DiscoveryFinishedReceiver.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/DiscoveryFinishedReceiver.java
@@ -1,26 +1,26 @@
-package com.melisa.innovamotionapp.receivers;
-import android.bluetooth.BluetoothAdapter;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class DiscoveryFinishedReceiver extends BroadcastReceiver {
-    private final DiscoveryFinishedListener listener;
-
-    public interface DiscoveryFinishedListener {
-        void onDiscoveryFinished();
-    }
-
-    public DiscoveryFinishedReceiver(DiscoveryFinishedListener listener) {
-        this.listener = listener;
-    }
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(intent.getAction())) {
-            if (listener != null) {
-                listener.onDiscoveryFinished();
-            }
-        }
-    }
-}
+package com.melisa.innovamotionapp.receivers;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class DiscoveryFinishedReceiver extends BroadcastReceiver {
+    private final DiscoveryFinishedListener listener;
+
+    public interface DiscoveryFinishedListener {
+        void onDiscoveryFinished();
+    }
+
+    public DiscoveryFinishedReceiver(DiscoveryFinishedListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(intent.getAction())) {
+            if (listener != null) {
+                listener.onDiscoveryFinished();
+            }
+        }
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/NearbyDeviceDiscoveryReceiver.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/NearbyDeviceDiscoveryReceiver.java
index 5a66bba..02db166 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/NearbyDeviceDiscoveryReceiver.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/receivers/NearbyDeviceDiscoveryReceiver.java
@@ -1,32 +1,32 @@
-package com.melisa.innovamotionapp.receivers;
-
-
-import android.bluetooth.BluetoothDevice;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-
-public class NearbyDeviceDiscoveryReceiver extends BroadcastReceiver {
-    private final NearbyDeviceDiscoveryListener listener;
-
-    public interface NearbyDeviceDiscoveryListener {
-        void onDeviceFound(BluetoothDevice bluetoothDevice);
-    }
-
-    // Constructor accepts a callback
-    public NearbyDeviceDiscoveryReceiver(NearbyDeviceDiscoveryListener listener) {
-        this.listener = listener;
-    }
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        final String action = intent.getAction();
-
-        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
-            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-            listener.onDeviceFound(device);
-        }
-    }
-
-
-}
+package com.melisa.innovamotionapp.receivers;
+
+
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public class NearbyDeviceDiscoveryReceiver extends BroadcastReceiver {
+    private final NearbyDeviceDiscoveryListener listener;
+
+    public interface NearbyDeviceDiscoveryListener {
+        void onDeviceFound(BluetoothDevice bluetoothDevice);
+    }
+
+    // Constructor accepts a callback
+    public NearbyDeviceDiscoveryReceiver(NearbyDeviceDiscoveryListener listener) {
+        this.listener = listener;
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+
+        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
+            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
+            listener.onDeviceFound(device);
+        }
+    }
+
+
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreDataModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreDataModel.java
index d0a2b41..287f1ba 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreDataModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreDataModel.java
@@ -1,151 +1,151 @@
-package com.melisa.innovamotionapp.sync;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * Firestore data model for synchronized Bluetooth messages.
- * This class represents the structure of documents stored in Firestore.
- * 
- * Supports the multi-user protocol where each reading includes a sensorId
- * identifying the monitored person (e.g., "sensor001", UUID).
- */
-public class FirestoreDataModel {
-    private String deviceAddress;
-    private long timestamp;
-    private String receivedMsg;
-    private String userId; // The aggregator user ID
-    private String sensorId; // The monitored person's ID from hardware
-    private long syncTimestamp; // When this was synced to Firestore
-    private String documentId; // Unique document ID: userId_deviceAddress_sensorId_timestamp
-
-    // Default constructor required for Firestore
-    public FirestoreDataModel() {}
-
-    /**
-     * Full constructor for multi-user protocol data.
-     *
-     * @param deviceAddress Bluetooth MAC address of the hardware device
-     * @param timestamp     When the reading was received (epoch millis)
-     * @param receivedMsg   The hex code payload (e.g., "0xAB3311")
-     * @param userId        The aggregator user ID who owns this data
-     * @param sensorId      The monitored person's ID from hardware (e.g., "sensor001")
-     */
-    public FirestoreDataModel(String deviceAddress, long timestamp, String receivedMsg, String userId, String sensorId) {
-        this.deviceAddress = deviceAddress;
-        this.timestamp = timestamp;
-        this.receivedMsg = receivedMsg;
-        this.userId = userId;
-        this.sensorId = sensorId;
-        this.syncTimestamp = System.currentTimeMillis();
-        this.documentId = generateDocumentId(userId, deviceAddress, sensorId, timestamp);
-    }
-
-    /**
-     * Generate a unique document ID using userId, deviceAddress, sensorId, and timestamp.
-     * Format: userId_deviceAddress_sensorId_timestamp
-     * 
-     * Including sensorId ensures uniqueness even when multiple sensors report at the same timestamp.
-     */
-    public static String generateDocumentId(String userId, String deviceAddress, String sensorId, long timestamp) {
-        String cleanDeviceAddress = deviceAddress != null ? deviceAddress.replace(":", "") : "unknown";
-        String cleanSensorId = sensorId != null ? sensorId : "unknown";
-        return userId + "_" + cleanDeviceAddress + "_" + cleanSensorId + "_" + timestamp;
-    }
-
-    /**
-     * Convert to Firestore document format
-     */
-    public Map<String, Object> toFirestoreDocument() {
-        Map<String, Object> doc = new HashMap<>();
-        doc.put("deviceAddress", deviceAddress);
-        doc.put("timestamp", timestamp);
-        doc.put("receivedMsg", receivedMsg);
-        doc.put("userId", userId);
-        doc.put("sensorId", sensorId);
-        doc.put("syncTimestamp", syncTimestamp);
-        doc.put("documentId", documentId);
-        return doc;
-    }
-
-    /**
-     * Create from Firestore document
-     */
-    public static FirestoreDataModel fromFirestoreDocument(Map<String, Object> doc) {
-        FirestoreDataModel model = new FirestoreDataModel();
-        model.deviceAddress = (String) doc.get("deviceAddress");
-        
-        // Handle timestamp - could be Long or null
-        Object tsObj = doc.get("timestamp");
-        model.timestamp = tsObj instanceof Long ? (Long) tsObj : 0L;
-        
-        model.receivedMsg = (String) doc.get("receivedMsg");
-        model.userId = (String) doc.get("userId");
-        model.sensorId = (String) doc.get("sensorId");
-        
-        // Handle syncTimestamp - could be Long or null
-        Object syncTsObj = doc.get("syncTimestamp");
-        model.syncTimestamp = syncTsObj instanceof Long ? (Long) syncTsObj : 0L;
-        
-        model.documentId = (String) doc.get("documentId");
-        return model;
-    }
-
-    // ========== Getters and Setters ==========
-
-    public String getDeviceAddress() {
-        return deviceAddress;
-    }
-
-    public void setDeviceAddress(String deviceAddress) {
-        this.deviceAddress = deviceAddress;
-    }
-
-    public long getTimestamp() {
-        return timestamp;
-    }
-
-    public void setTimestamp(long timestamp) {
-        this.timestamp = timestamp;
-    }
-
-    public String getReceivedMsg() {
-        return receivedMsg;
-    }
-
-    public void setReceivedMsg(String receivedMsg) {
-        this.receivedMsg = receivedMsg;
-    }
-
-    public String getUserId() {
-        return userId;
-    }
-
-    public void setUserId(String userId) {
-        this.userId = userId;
-    }
-
-    public String getSensorId() {
-        return sensorId;
-    }
-
-    public void setSensorId(String sensorId) {
-        this.sensorId = sensorId;
-    }
-
-    public long getSyncTimestamp() {
-        return syncTimestamp;
-    }
-
-    public void setSyncTimestamp(long syncTimestamp) {
-        this.syncTimestamp = syncTimestamp;
-    }
-
-    public String getDocumentId() {
-        return documentId;
-    }
-
-    public void setDocumentId(String documentId) {
-        this.documentId = documentId;
-    }
-}
+package com.melisa.innovamotionapp.sync;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Firestore data model for synchronized Bluetooth messages.
+ * This class represents the structure of documents stored in Firestore.
+ * 
+ * Supports the multi-user protocol where each reading includes a sensorId
+ * identifying the monitored person (e.g., "sensor001", UUID).
+ */
+public class FirestoreDataModel {
+    private String deviceAddress;
+    private long timestamp;
+    private String receivedMsg;
+    private String userId; // The aggregator user ID
+    private String sensorId; // The monitored person's ID from hardware
+    private long syncTimestamp; // When this was synced to Firestore
+    private String documentId; // Unique document ID: userId_deviceAddress_sensorId_timestamp
+
+    // Default constructor required for Firestore
+    public FirestoreDataModel() {}
+
+    /**
+     * Full constructor for multi-user protocol data.
+     *
+     * @param deviceAddress Bluetooth MAC address of the hardware device
+     * @param timestamp     When the reading was received (epoch millis)
+     * @param receivedMsg   The hex code payload (e.g., "0xAB3311")
+     * @param userId        The aggregator user ID who owns this data
+     * @param sensorId      The monitored person's ID from hardware (e.g., "sensor001")
+     */
+    public FirestoreDataModel(String deviceAddress, long timestamp, String receivedMsg, String userId, String sensorId) {
+        this.deviceAddress = deviceAddress;
+        this.timestamp = timestamp;
+        this.receivedMsg = receivedMsg;
+        this.userId = userId;
+        this.sensorId = sensorId;
+        this.syncTimestamp = System.currentTimeMillis();
+        this.documentId = generateDocumentId(userId, deviceAddress, sensorId, timestamp);
+    }
+
+    /**
+     * Generate a unique document ID using userId, deviceAddress, sensorId, and timestamp.
+     * Format: userId_deviceAddress_sensorId_timestamp
+     * 
+     * Including sensorId ensures uniqueness even when multiple sensors report at the same timestamp.
+     */
+    public static String generateDocumentId(String userId, String deviceAddress, String sensorId, long timestamp) {
+        String cleanDeviceAddress = deviceAddress != null ? deviceAddress.replace(":", "") : "unknown";
+        String cleanSensorId = sensorId != null ? sensorId : "unknown";
+        return userId + "_" + cleanDeviceAddress + "_" + cleanSensorId + "_" + timestamp;
+    }
+
+    /**
+     * Convert to Firestore document format
+     */
+    public Map<String, Object> toFirestoreDocument() {
+        Map<String, Object> doc = new HashMap<>();
+        doc.put("deviceAddress", deviceAddress);
+        doc.put("timestamp", timestamp);
+        doc.put("receivedMsg", receivedMsg);
+        doc.put("userId", userId);
+        doc.put("sensorId", sensorId);
+        doc.put("syncTimestamp", syncTimestamp);
+        doc.put("documentId", documentId);
+        return doc;
+    }
+
+    /**
+     * Create from Firestore document
+     */
+    public static FirestoreDataModel fromFirestoreDocument(Map<String, Object> doc) {
+        FirestoreDataModel model = new FirestoreDataModel();
+        model.deviceAddress = (String) doc.get("deviceAddress");
+        
+        // Handle timestamp - could be Long or null
+        Object tsObj = doc.get("timestamp");
+        model.timestamp = tsObj instanceof Long ? (Long) tsObj : 0L;
+        
+        model.receivedMsg = (String) doc.get("receivedMsg");
+        model.userId = (String) doc.get("userId");
+        model.sensorId = (String) doc.get("sensorId");
+        
+        // Handle syncTimestamp - could be Long or null
+        Object syncTsObj = doc.get("syncTimestamp");
+        model.syncTimestamp = syncTsObj instanceof Long ? (Long) syncTsObj : 0L;
+        
+        model.documentId = (String) doc.get("documentId");
+        return model;
+    }
+
+    // ========== Getters and Setters ==========
+
+    public String getDeviceAddress() {
+        return deviceAddress;
+    }
+
+    public void setDeviceAddress(String deviceAddress) {
+        this.deviceAddress = deviceAddress;
+    }
+
+    public long getTimestamp() {
+        return timestamp;
+    }
+
+    public void setTimestamp(long timestamp) {
+        this.timestamp = timestamp;
+    }
+
+    public String getReceivedMsg() {
+        return receivedMsg;
+    }
+
+    public void setReceivedMsg(String receivedMsg) {
+        this.receivedMsg = receivedMsg;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public void setUserId(String userId) {
+        this.userId = userId;
+    }
+
+    public String getSensorId() {
+        return sensorId;
+    }
+
+    public void setSensorId(String sensorId) {
+        this.sensorId = sensorId;
+    }
+
+    public long getSyncTimestamp() {
+        return syncTimestamp;
+    }
+
+    public void setSyncTimestamp(long syncTimestamp) {
+        this.syncTimestamp = syncTimestamp;
+    }
+
+    public String getDocumentId() {
+        return documentId;
+    }
+
+    public void setDocumentId(String documentId) {
+        this.documentId = documentId;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java
index fa65e2f..a7c5001 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java
@@ -4,6 +4,7 @@ import android.content.Context;
 import android.util.Log;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import com.google.android.gms.tasks.OnCompleteListener;
 import com.google.android.gms.tasks.OnFailureListener;
@@ -177,6 +178,10 @@ public class FirestoreSyncService {
         } else if (userSession.isSupervisor()) {
             Log.i(TAG, "Supervisor user: starting download sync");
             List<String> supervisedSensorIds = userSession.getSupervisedSensorIds();
+            // #region agent log
+            // H2: Log supervisor sync initiation
+            android.util.Log.w("DBG_H2", "Supervisor sync check: supervisedSensorIds=" + supervisedSensorIds + ", isEmpty=" + supervisedSensorIds.isEmpty());
+            // #endregion
             if (!supervisedSensorIds.isEmpty()) {
                 startSupervisorMirrors(supervisedSensorIds);
             }
@@ -695,8 +700,15 @@ public class FirestoreSyncService {
      * @param sensorIds List of sensor IDs to sync
      * @param callback Callback for sync result
      */
-    private void syncFromSupervisedSensors(List<String> sensorIds, SyncCallback callback) {
+    public void syncFromSupervisedSensors(List<String> sensorIds, SyncCallback callback) {
+        // #region agent log
+        android.util.Log.w("DBG_SUP", "syncFromSupervisedSensors: ENTRY, sensorIds=" + sensorIds);
+        // #endregion
+        
         if (sensorIds.isEmpty()) {
+            // #region agent log
+            android.util.Log.w("DBG_SUP", "syncFromSupervisedSensors: EMPTY sensorIds, returning early");
+            // #endregion
             callback.onSuccess("No sensors to sync");
             return;
         }
@@ -711,6 +723,10 @@ public class FirestoreSyncService {
         List<Task<QuerySnapshot>> tasks = new ArrayList<>();
 
         for (List<String> batch : batches) {
+            // #region agent log
+            // H3: Log the sensorIds being queried
+            android.util.Log.w("DBG_H3", "Querying Firestore whereIn: batchSensorIds=" + batch + ", collection=" + COLLECTION_BT_DATA);
+            // #endregion
             Task<QuerySnapshot> task = firestore.collection(COLLECTION_BT_DATA)
                     .whereIn("sensorId", batch)
                     .orderBy("timestamp", Query.Direction.ASCENDING)
@@ -769,15 +785,29 @@ public class FirestoreSyncService {
 
             long duration = System.currentTimeMillis() - startTime;
             Log.i(TAG, "Sensor sync completed in " + duration + "ms, " + batches.size() + " queries, " + allEntities.size() + " new entities");
+            
+            // #region agent log
+            // H3: Log Firestore query results
+            android.util.Log.w("DBG_H3", "Firestore query results: newEntitiesCount=" + allEntities.size() + ", batchCount=" + batches.size() + ", durationMs=" + duration);
+            // #endregion
 
             if (allEntities.isEmpty()) {
+                // #region agent log
+                android.util.Log.w("DBG_SUP", "syncFromSupervisedSensors: SUCCESS, no new entities (already up to date)");
+                // #endregion
                 callback.onSuccess("Local database is up to date");
             } else {
                 dao.insertAll(allEntities);
+                // #region agent log
+                android.util.Log.w("DBG_SUP", "syncFromSupervisedSensors: SUCCESS, inserted " + allEntities.size() + " entities");
+                // #endregion
                 callback.onSuccess("Added " + allEntities.size() + " missing messages to local database");
             }
         }).addOnFailureListener(e -> {
             Log.e(TAG, "Failed to sync from supervised sensors", e);
+            // #region agent log
+            android.util.Log.e("DBG_SUP", "syncFromSupervisedSensors: FAILURE - " + e.getMessage());
+            // #endregion
             callback.onError("Failed to sync from supervised sensors: " + e.getMessage());
         });
     }
@@ -850,6 +880,11 @@ public class FirestoreSyncService {
                 long localMaxTimestamp = dao.getMaxTimestampSync();
                 Log.d(TAG, "Local max timestamp: " + localMaxTimestamp);
                 
+                // #region agent log
+                // H3: Log backfill start parameters
+                android.util.Log.w("DBG_H3", "Backfill start: userId=" + userId + ", localMaxTimestamp=" + localMaxTimestamp);
+                // #endregion
+                
                 // Query Firestore for messages newer than local max timestamp
                 firestore.collection(COLLECTION_BT_DATA)
                         .whereEqualTo("userId", userId)
@@ -857,6 +892,11 @@ public class FirestoreSyncService {
                         .whereGreaterThan("timestamp", localMaxTimestamp)
                         .get()
                         .addOnSuccessListener(queryDocumentSnapshots -> {
+                            // #region agent log
+                            // H3: Log backfill query result
+                            android.util.Log.w("DBG_H3", "Backfill query result: count=" + queryDocumentSnapshots.size());
+                            // #endregion
+                            
                             List<ReceivedBtDataEntity> entitiesToInsert = new ArrayList<>();
                             
                             for (QueryDocumentSnapshot document : queryDocumentSnapshots) {
@@ -1339,15 +1379,24 @@ public class FirestoreSyncService {
      * 
      * @param sensorIds List of sensor IDs to monitor
      */
-    private void startSupervisorMirrors(List<String> sensorIds) {
+    public void startSupervisorMirrors(List<String> sensorIds) {
         Log.i(TAG, "Starting sensor mirrors for " + sensorIds.size() + " sensors");
+        // #region agent log
+        android.util.Log.w("DBG_SUP", "startSupervisorMirrors: ENTRY, sensorIds=" + sensorIds + ", count=" + sensorIds.size());
+        // #endregion
         
         if (sensorIds.size() <= WHEREIN_LIMIT) {
             // Use single compound listener for efficiency
+            // #region agent log
+            android.util.Log.w("DBG_SUP", "startSupervisorMirrors: using COMPOUND listener (<=10 sensors)");
+            // #endregion
             startCompoundSensorMirror(sensorIds);
         } else {
             // Fall back to per-sensor listeners (Firestore whereIn limit)
             Log.i(TAG, "Using per-sensor listeners (>10 sensors)");
+            // #region agent log
+            android.util.Log.w("DBG_SUP", "startSupervisorMirrors: using PER-SENSOR listeners (>10 sensors)");
+            // #endregion
             for (String sensorId : sensorIds) {
                 startSensorMirror(sensorId);
             }
@@ -1504,13 +1553,32 @@ public class FirestoreSyncService {
     }
     
     /**
-     * Clear all local data (for sign-out)
+     * Clear all local data (for sign-out).
+     * Fire-and-forget version - use clearLocalData(Runnable) if you need to wait for completion.
      */
     public void clearLocalData() {
-        Log.i(TAG, "Clearing all local data");
+        clearLocalData(null);
+    }
+    
+    /**
+     * Clear all local data with callback notification.
+     * Use this version when you need to wait for the clear operation to complete
+     * before proceeding (e.g., user switch scenarios).
+     * 
+     * @param onComplete Callback invoked on main thread after data is cleared (nullable)
+     */
+    public void clearLocalData(@Nullable Runnable onComplete) {
+        Log.i(TAG, "Clearing all local data" + (onComplete != null ? " (with callback)" : ""));
         executorService.execute(() -> {
             int deletedRows = dao.clearAllData();
-            Log.i(TAG, "Cleared " + deletedRows + " rows from local database");
+            // Also clear monitored persons to prevent stale names on user switch
+            int deletedPersons = localDatabase.monitoredPersonDao().clearAll();
+            Log.i(TAG, "Cleared " + deletedRows + " data rows and " + deletedPersons + " monitored persons");
+            
+            // Notify caller on main thread
+            if (onComplete != null) {
+                new android.os.Handler(android.os.Looper.getMainLooper()).post(onComplete);
+            }
         });
     }
     
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/NetworkConnectivityMonitor.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/NetworkConnectivityMonitor.java
index 0cd5ea4..360bf1b 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/NetworkConnectivityMonitor.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/NetworkConnectivityMonitor.java
@@ -1,173 +1,173 @@
-package com.melisa.innovamotionapp.sync;
-
-import android.content.Context;
-import android.net.ConnectivityManager;
-import android.net.Network;
-import android.net.NetworkCapabilities;
-import android.net.NetworkRequest;
-import android.os.Handler;
-import android.os.Looper;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-
-import java.util.concurrent.CopyOnWriteArrayList;
-
-/**
- * Monitors network connectivity changes and notifies listeners.
- * Uses modern Android ConnectivityManager API for reliable connectivity detection.
- */
-public class NetworkConnectivityMonitor {
-    private static final String TAG = "NetworkConnectivityMonitor";
-    
-    private final Context context;
-    private final ConnectivityManager connectivityManager;
-    private final CopyOnWriteArrayList<ConnectivityListener> listeners;
-    private final Handler mainHandler;
-    private ConnectivityManager.NetworkCallback networkCallback;
-    private boolean isConnected = false;
-
-    public interface ConnectivityListener {
-        void onConnectivityChanged(boolean isConnected);
-    }
-
-    public NetworkConnectivityMonitor(Context context) {
-        this.context = context.getApplicationContext();
-        this.connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
-        this.listeners = new CopyOnWriteArrayList<>();
-        this.mainHandler = new Handler(Looper.getMainLooper());
-        
-        // Initialize current connectivity state
-        this.isConnected = isCurrentlyConnected();
-    }
-
-    /**
-     * Start monitoring network connectivity changes
-     */
-    public void startMonitoring() {
-        if (networkCallback != null) {
-            Log.w(TAG, "Already monitoring network connectivity");
-            return;
-        }
-
-        NetworkRequest.Builder builder = new NetworkRequest.Builder()
-                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
-                .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
-
-        networkCallback = new ConnectivityManager.NetworkCallback() {
-            @Override
-            public void onAvailable(@NonNull Network network) {
-                Log.d(TAG, "Network available: " + network);
-                updateConnectivityState(true);
-            }
-
-            @Override
-            public void onLost(@NonNull Network network) {
-                Log.d(TAG, "Network lost: " + network);
-                updateConnectivityState(false);
-            }
-
-            @Override
-            public void onCapabilitiesChanged(@NonNull Network network, @NonNull NetworkCapabilities networkCapabilities) {
-                boolean hasInternet = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
-                                    networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
-                Log.d(TAG, "Network capabilities changed. Has internet: " + hasInternet);
-                updateConnectivityState(hasInternet);
-            }
-        };
-
-        try {
-            connectivityManager.registerNetworkCallback(builder.build(), networkCallback);
-            Log.d(TAG, "Network monitoring started");
-        } catch (Exception e) {
-            Log.e(TAG, "Failed to register network callback", e);
-        }
-    }
-
-    /**
-     * Stop monitoring network connectivity changes
-     */
-    public void stopMonitoring() {
-        if (networkCallback != null) {
-            try {
-                connectivityManager.unregisterNetworkCallback(networkCallback);
-                Log.d(TAG, "Network monitoring stopped");
-            } catch (Exception e) {
-                Log.e(TAG, "Failed to unregister network callback", e);
-            }
-            networkCallback = null;
-        }
-    }
-
-    /**
-     * Check current connectivity state
-     */
-    public boolean isCurrentlyConnected() {
-        try {
-            Network activeNetwork = connectivityManager.getActiveNetwork();
-            if (activeNetwork == null) return false;
-
-            NetworkCapabilities capabilities = connectivityManager.getNetworkCapabilities(activeNetwork);
-            return capabilities != null &&
-                   capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
-                   capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
-        } catch (Exception e) {
-            Log.e(TAG, "Error checking connectivity", e);
-            return false;
-        }
-    }
-
-    /**
-     * Add a connectivity listener
-     */
-    public void addListener(ConnectivityListener listener) {
-        if (listener != null && !listeners.contains(listener)) {
-            listeners.add(listener);
-            // Immediately notify the new listener of current state
-            mainHandler.post(() -> listener.onConnectivityChanged(isConnected));
-        }
-    }
-
-    /**
-     * Remove a connectivity listener
-     */
-    public void removeListener(ConnectivityListener listener) {
-        listeners.remove(listener);
-    }
-
-    /**
-     * Get current connectivity state
-     */
-    public boolean isConnected() {
-        return isConnected;
-    }
-
-    /**
-     * Update connectivity state and notify listeners
-     */
-    private void updateConnectivityState(boolean connected) {
-        if (this.isConnected != connected) {
-            this.isConnected = connected;
-            Log.i(TAG, "Connectivity state changed: " + (connected ? "CONNECTED" : "DISCONNECTED"));
-            
-            // Notify all listeners on main thread
-            mainHandler.post(() -> {
-                for (ConnectivityListener listener : listeners) {
-                    try {
-                        listener.onConnectivityChanged(connected);
-                    } catch (Exception e) {
-                        Log.e(TAG, "Error notifying connectivity listener", e);
-                    }
-                }
-            });
-        }
-    }
-
-    /**
-     * Clean up resources
-     */
-    public void cleanup() {
-        stopMonitoring();
-        listeners.clear();
-    }
-}
+package com.melisa.innovamotionapp.sync;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkRequest;
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * Monitors network connectivity changes and notifies listeners.
+ * Uses modern Android ConnectivityManager API for reliable connectivity detection.
+ */
+public class NetworkConnectivityMonitor {
+    private static final String TAG = "NetworkConnectivityMonitor";
+    
+    private final Context context;
+    private final ConnectivityManager connectivityManager;
+    private final CopyOnWriteArrayList<ConnectivityListener> listeners;
+    private final Handler mainHandler;
+    private ConnectivityManager.NetworkCallback networkCallback;
+    private boolean isConnected = false;
+
+    public interface ConnectivityListener {
+        void onConnectivityChanged(boolean isConnected);
+    }
+
+    public NetworkConnectivityMonitor(Context context) {
+        this.context = context.getApplicationContext();
+        this.connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        this.listeners = new CopyOnWriteArrayList<>();
+        this.mainHandler = new Handler(Looper.getMainLooper());
+        
+        // Initialize current connectivity state
+        this.isConnected = isCurrentlyConnected();
+    }
+
+    /**
+     * Start monitoring network connectivity changes
+     */
+    public void startMonitoring() {
+        if (networkCallback != null) {
+            Log.w(TAG, "Already monitoring network connectivity");
+            return;
+        }
+
+        NetworkRequest.Builder builder = new NetworkRequest.Builder()
+                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
+                .addCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
+
+        networkCallback = new ConnectivityManager.NetworkCallback() {
+            @Override
+            public void onAvailable(@NonNull Network network) {
+                Log.d(TAG, "Network available: " + network);
+                updateConnectivityState(true);
+            }
+
+            @Override
+            public void onLost(@NonNull Network network) {
+                Log.d(TAG, "Network lost: " + network);
+                updateConnectivityState(false);
+            }
+
+            @Override
+            public void onCapabilitiesChanged(@NonNull Network network, @NonNull NetworkCapabilities networkCapabilities) {
+                boolean hasInternet = networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
+                                    networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
+                Log.d(TAG, "Network capabilities changed. Has internet: " + hasInternet);
+                updateConnectivityState(hasInternet);
+            }
+        };
+
+        try {
+            connectivityManager.registerNetworkCallback(builder.build(), networkCallback);
+            Log.d(TAG, "Network monitoring started");
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to register network callback", e);
+        }
+    }
+
+    /**
+     * Stop monitoring network connectivity changes
+     */
+    public void stopMonitoring() {
+        if (networkCallback != null) {
+            try {
+                connectivityManager.unregisterNetworkCallback(networkCallback);
+                Log.d(TAG, "Network monitoring stopped");
+            } catch (Exception e) {
+                Log.e(TAG, "Failed to unregister network callback", e);
+            }
+            networkCallback = null;
+        }
+    }
+
+    /**
+     * Check current connectivity state
+     */
+    public boolean isCurrentlyConnected() {
+        try {
+            Network activeNetwork = connectivityManager.getActiveNetwork();
+            if (activeNetwork == null) return false;
+
+            NetworkCapabilities capabilities = connectivityManager.getNetworkCapabilities(activeNetwork);
+            return capabilities != null &&
+                   capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) &&
+                   capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED);
+        } catch (Exception e) {
+            Log.e(TAG, "Error checking connectivity", e);
+            return false;
+        }
+    }
+
+    /**
+     * Add a connectivity listener
+     */
+    public void addListener(ConnectivityListener listener) {
+        if (listener != null && !listeners.contains(listener)) {
+            listeners.add(listener);
+            // Immediately notify the new listener of current state
+            mainHandler.post(() -> listener.onConnectivityChanged(isConnected));
+        }
+    }
+
+    /**
+     * Remove a connectivity listener
+     */
+    public void removeListener(ConnectivityListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Get current connectivity state
+     */
+    public boolean isConnected() {
+        return isConnected;
+    }
+
+    /**
+     * Update connectivity state and notify listeners
+     */
+    private void updateConnectivityState(boolean connected) {
+        if (this.isConnected != connected) {
+            this.isConnected = connected;
+            Log.i(TAG, "Connectivity state changed: " + (connected ? "CONNECTED" : "DISCONNECTED"));
+            
+            // Notify all listeners on main thread
+            mainHandler.post(() -> {
+                for (ConnectivityListener listener : listeners) {
+                    try {
+                        listener.onConnectivityChanged(connected);
+                    } catch (Exception e) {
+                        Log.e(TAG, "Error notifying connectivity listener", e);
+                    }
+                }
+            });
+        }
+    }
+
+    /**
+     * Clean up resources
+     */
+    public void cleanup() {
+        stopMonitoring();
+        listeners.clear();
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SessionGate.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SessionGate.java
index 9bb3c1f..08958c4 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SessionGate.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SessionGate.java
@@ -1,327 +1,357 @@
-package com.melisa.innovamotionapp.sync;
-
-import android.content.Context;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-
-import com.google.firebase.auth.FirebaseAuth;
-import com.google.firebase.auth.FirebaseUser;
-import com.melisa.innovamotionapp.utils.GlobalData;
-
-import java.util.List;
-
-/**
- * SessionGate manages the authentication and session loading flow.
- * Ensures all sync operations only start after user is authenticated and session is loaded.
- */
-public class SessionGate {
-    private static final String TAG = "SessionGate";
-    
-    private static SessionGate instance;
-    private final Context context;
-    private final FirebaseAuth auth;
-    private final UserSession userSession;
-    private final FirestoreSyncService syncService;
-    
-    // Session state
-    private boolean isSessionReady = false;
-    private boolean hasBootstrapped = false; // Track if bootstrap has run
-    private String currentUserUid;
-    private String currentUserRole;
-    private List<String> supervisedUserIds;
-    
-    // Callback interface for session ready
-    public interface SessionReadyCallback {
-        void onSessionReady(String userId, String role, List<String> supervisedUserIds);
-        void onSessionError(String error);
-    }
-    
-    private SessionGate(Context context) {
-        this.context = context.getApplicationContext();
-        this.auth = FirebaseAuth.getInstance();
-        this.userSession = UserSession.getInstance(context);
-        this.syncService = FirestoreSyncService.getInstance(context);
-        
-        // Set up auth state listener
-        setupAuthStateListener();
-    }
-    
-    public static synchronized SessionGate getInstance(Context context) {
-        if (instance == null) {
-            instance = new SessionGate(context);
-        }
-        return instance;
-    }
-    
-    /**
-     * Set up Firebase Auth state listener to detect sign-in/sign-out
-     */
-    private void setupAuthStateListener() {
-        auth.addAuthStateListener(firebaseAuth -> {
-            FirebaseUser user = firebaseAuth.getCurrentUser();
-            if (user != null) {
-                Log.d(TAG, "User authenticated: " + user.getUid());
-                // Only load session data, DO NOT run bootstrap automatically
-                loadSessionDataOnly(user);
-            } else {
-                Log.d(TAG, "User signed out");
-                handleUserSignedOut();
-            }
-        });
-    }
-    
-    /**
-     * Update cached session data and GlobalData instance
-     * @param userId User ID
-     * @param role User role (supervised or supervisor)
-     * @param supervisedUserIds List of supervised user IDs (empty for supervised users)
-     */
-    private void updateSessionCache(String userId, String role, List<String> supervisedUserIds) {
-        // Cache session data locally
-        this.currentUserUid = userId;
-        this.currentUserRole = role;
-        this.supervisedUserIds = supervisedUserIds;
-        this.isSessionReady = true;
-        
-        // Update GlobalData singleton with session info
-        GlobalData.getInstance().setCurrentUserUid(userId);
-        GlobalData.getInstance().setCurrentUserRole(role);
-        GlobalData.getInstance().setSupervisedSensorIds(supervisedUserIds);
-    }
-    
-    /**
-     * Load session data without triggering bootstrap
-     * This is called by the auth listener to cache user info
-     */
-    private void loadSessionDataOnly(FirebaseUser user) {
-        Log.d(TAG, "Loading session data (without bootstrap) for: " + user.getUid());
-        
-        userSession.loadUserSession(new UserSession.SessionLoadCallback() {
-            @Override
-            public void onSessionLoaded(String userId, String role, List<String> supervisedUserIds) {
-                Log.i(TAG, "Session data loaded - User: " + userId + ", Role: " + role + ", Supervised: " + supervisedUserIds);
-                Log.i(TAG, "âš ï¸ Bootstrap will NOT run automatically - waiting for explicit trigger");
-                
-                // Cache session data
-                updateSessionCache(userId, role, supervisedUserIds);
-                
-                // Log supervised users for supervisor role
-                if ("supervisor".equals(role)) {
-                    for (String child : supervisedUserIds) {
-                        Log.i("SESSION", "Supervisor's cached supervised user=" + child);
-                    }
-                }
-                
-                // DO NOT run bootstrap here - wait for explicit call
-            }
-            
-            @Override
-            public void onSessionLoadError(String error) {
-                Log.e(TAG, "Failed to load user session: " + error);
-                isSessionReady = false;
-                hasBootstrapped = false;
-            }
-        });
-    }
-    
-    /**
-     * Reload session from Firestore and run bootstrap with fresh data
-     * This should be called after the user confirms their role in LoginActivity
-     */
-    public void reloadSessionAndBootstrap(final SessionReadyCallback callback) {
-        Log.i(TAG, "ğŸ”„ Reloading session from Firestore and running bootstrap...");
-        
-        FirebaseUser user = auth.getCurrentUser();
-        if (user == null) {
-            Log.e(TAG, "Cannot reload session: user not authenticated");
-            if (callback != null) {
-                callback.onSessionError("User not authenticated");
-            }
-            return;
-        }
-        
-        // Force reload session to get latest data from Firestore
-        userSession.reloadSession(new UserSession.SessionLoadCallback() {
-            @Override
-            public void onSessionLoaded(String userId, String role, List<String> supervisedUserIds) {
-                Log.i("SESSION", "âœ… Session reloaded - user=" + userId + " role=" + role + " supervised=" + supervisedUserIds);
-                
-                // Update cached session data
-                updateSessionCache(userId, role, supervisedUserIds);
-                
-                // Now run bootstrap with correct data
-                Log.i(TAG, "ğŸš€ Running post-auth bootstrap with confirmed role: " + role);
-                runPostAuthBootstrap(role, supervisedUserIds);
-                hasBootstrapped = true;
-                
-                if (callback != null) {
-                    callback.onSessionReady(userId, role, supervisedUserIds);
-                }
-            }
-            
-            @Override
-            public void onSessionLoadError(String error) {
-                Log.e(TAG, "Failed to reload session: " + error);
-                if (callback != null) {
-                    callback.onSessionError(error);
-                }
-            }
-        });
-    }
-    
-    /**
-     * Handle user sign-out - cleanup and reset state
-     */
-    private void handleUserSignedOut() {
-        Log.d(TAG, "User signed out, cleaning up session");
-        
-        // Stop all mirrors and clear data
-        syncService.stopAllMirrors();
-        syncService.clearLocalData();
-        
-        // Reset GlobalData
-        GlobalData.getInstance().resetSessionData();
-        
-        // Reset session state
-        isSessionReady = false;
-        hasBootstrapped = false;
-        currentUserUid = null;
-        currentUserRole = null;
-        supervisedUserIds = null;
-    }
-    
-    /**
-     * Run post-authentication bootstrap based on user role
-     */
-    private void runPostAuthBootstrap(String role, List<String> supervisedUserIds) {
-        Log.i(TAG, "Running post-auth bootstrap for role: " + role);
-        
-        if ("supervised".equals(role)) {
-            runSupervisedPipeline();
-        } else if ("supervisor".equals(role)) {
-            runSupervisorPipeline(supervisedUserIds);
-        } else {
-            Log.w(TAG, "Unknown role: " + role);
-        }
-    }
-    
-    /**
-     * Run supervised user pipeline
-     */
-    private void runSupervisedPipeline() {
-        Log.i(TAG, "Starting supervised user pipeline");
-        
-        // Backfill current user's data from cloud
-        syncService.backfillLocalFromCloudForCurrentUser(new FirestoreSyncService.SyncCallback() {
-            @Override
-            public void onSuccess(String message) {
-                Log.i(TAG, "Supervised backfill completed: " + message);
-            }
-            
-            @Override
-            public void onError(String error) {
-                Log.w(TAG, "Supervised backfill failed: " + error);
-            }
-            
-            @Override
-            public void onProgress(int current, int total) {
-                Log.d(TAG, "Supervised backfill progress: " + current + "/" + total);
-            }
-        });
-    }
-    
-    /**
-     * Run supervisor pipeline
-     */
-    private void runSupervisorPipeline(List<String> supervisedUserIds) {
-        Log.i(TAG, "Starting supervisor pipeline for " + supervisedUserIds.size() + " supervised users");
-        
-        if (supervisedUserIds.isEmpty()) {
-            Log.w(TAG, "No supervised users found for supervisor");
-            return;
-        }
-        
-        // Purge old data and backfill for each supervised user
-        syncService.purgeAndBackfillForSupervisor(supervisedUserIds, new FirestoreSyncService.SyncCallback() {
-            @Override
-            public void onSuccess(String message) {
-                Log.i(TAG, "Supervisor pipeline completed: " + message);
-            }
-            
-            @Override
-            public void onError(String error) {
-                Log.w(TAG, "Supervisor pipeline failed: " + error);
-            }
-            
-            @Override
-            public void onProgress(int current, int total) {
-                Log.d(TAG, "Supervisor pipeline progress: " + current + "/" + total);
-            }
-        });
-    }
-    
-    /**
-     * Check if session is ready
-     */
-    public boolean isSessionReady() {
-        return isSessionReady;
-    }
-    
-    /**
-     * Check if bootstrap has already run
-     */
-    public boolean hasBootstrapped() {
-        return hasBootstrapped;
-    }
-    
-    /**
-     * Get current user UID
-     */
-    public String getCurrentUserUid() {
-        return currentUserUid;
-    }
-    
-    /**
-     * Get current user role
-     */
-    public String getCurrentUserRole() {
-        return currentUserRole;
-    }
-    
-    /**
-     * Get supervised sensor IDs (for supervisor role).
-     * These are the sensor IDs that this supervisor is allowed to monitor.
-     */
-    public List<String> getSupervisedSensorIds() {
-        return supervisedUserIds; // Field is named for backward compat, but contains sensor IDs
-    }
-    
-    /**
-     * @deprecated Use {@link #getSupervisedSensorIds()} instead.
-     */
-    @Deprecated
-    public List<String> getSupervisedUserIds() {
-        return getSupervisedSensorIds();
-    }
-    
-    /**
-     * Wait for session to be ready and execute callback
-     */
-    public void waitForSessionReady(SessionReadyCallback callback) {
-        if (isSessionReady) {
-            callback.onSessionReady(currentUserUid, currentUserRole, supervisedUserIds);
-        } else {
-            // For now, just return error - in a real implementation you might want to queue callbacks
-            callback.onSessionError("Session not ready");
-        }
-    }
-    
-    /**
-     * Clean up resources
-     */
-    public void cleanup() {
-        Log.i(TAG, "Cleaning up SessionGate");
-        // Auth state listener is automatically cleaned up when FirebaseAuth is destroyed
-    }
-}
+package com.melisa.innovamotionapp.sync;
+
+import android.content.Context;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import com.google.firebase.auth.FirebaseAuth;
+import com.google.firebase.auth.FirebaseUser;
+import com.melisa.innovamotionapp.utils.GlobalData;
+
+import java.util.List;
+
+/**
+ * SessionGate manages the authentication and session loading flow.
+ * Ensures all sync operations only start after user is authenticated and session is loaded.
+ */
+public class SessionGate {
+    private static final String TAG = "SessionGate";
+    
+    private static SessionGate instance;
+    private final Context context;
+    private final FirebaseAuth auth;
+    private final UserSession userSession;
+    private final FirestoreSyncService syncService;
+    
+    // Session state
+    private boolean isSessionReady = false;
+    private boolean hasBootstrapped = false; // Track if bootstrap has run
+    private String currentUserUid;
+    private String currentUserRole;
+    private List<String> supervisedUserIds;
+    
+    // Callback interface for session ready
+    public interface SessionReadyCallback {
+        void onSessionReady(String userId, String role, List<String> supervisedUserIds);
+        void onSessionError(String error);
+    }
+    
+    private SessionGate(Context context) {
+        this.context = context.getApplicationContext();
+        this.auth = FirebaseAuth.getInstance();
+        this.userSession = UserSession.getInstance(context);
+        this.syncService = FirestoreSyncService.getInstance(context);
+        
+        // Set up auth state listener
+        setupAuthStateListener();
+    }
+    
+    public static synchronized SessionGate getInstance(Context context) {
+        if (instance == null) {
+            instance = new SessionGate(context);
+        }
+        return instance;
+    }
+    
+    /**
+     * Set up Firebase Auth state listener to detect sign-in/sign-out
+     */
+    private void setupAuthStateListener() {
+        auth.addAuthStateListener(firebaseAuth -> {
+            FirebaseUser user = firebaseAuth.getCurrentUser();
+            if (user != null) {
+                Log.d(TAG, "User authenticated: " + user.getUid());
+                // Only load session data, DO NOT run bootstrap automatically
+                loadSessionDataOnly(user);
+            } else {
+                Log.d(TAG, "User signed out");
+                handleUserSignedOut();
+            }
+        });
+    }
+    
+    /**
+     * Update cached session data and GlobalData instance
+     * @param userId User ID
+     * @param role User role (supervised or supervisor)
+     * @param supervisedUserIds List of supervised user IDs (empty for supervised users)
+     */
+    private void updateSessionCache(String userId, String role, List<String> supervisedUserIds) {
+        // Cache session data locally
+        this.currentUserUid = userId;
+        this.currentUserRole = role;
+        this.supervisedUserIds = supervisedUserIds;
+        this.isSessionReady = true;
+        
+        // Update GlobalData singleton with session info
+        GlobalData.getInstance().setCurrentUserUid(userId);
+        GlobalData.getInstance().setCurrentUserRole(role);
+        GlobalData.getInstance().setSupervisedSensorIds(supervisedUserIds);
+    }
+    
+    /**
+     * Load session data without triggering bootstrap
+     * This is called by the auth listener to cache user info
+     */
+    private void loadSessionDataOnly(FirebaseUser user) {
+        Log.d(TAG, "Loading session data (without bootstrap) for: " + user.getUid());
+        
+        userSession.loadUserSession(new UserSession.SessionLoadCallback() {
+            @Override
+            public void onSessionLoaded(String userId, String role, List<String> supervisedUserIds) {
+                Log.i(TAG, "Session data loaded - User: " + userId + ", Role: " + role + ", Supervised: " + supervisedUserIds);
+                Log.i(TAG, "âš ï¸ Bootstrap will NOT run automatically - waiting for explicit trigger");
+                
+                // Cache session data
+                updateSessionCache(userId, role, supervisedUserIds);
+                
+                // Log supervised users for supervisor role
+                if ("supervisor".equals(role)) {
+                    for (String child : supervisedUserIds) {
+                        Log.i("SESSION", "Supervisor's cached supervised user=" + child);
+                    }
+                }
+                
+                // DO NOT run bootstrap here - wait for explicit call
+            }
+            
+            @Override
+            public void onSessionLoadError(String error) {
+                Log.e(TAG, "Failed to load user session: " + error);
+                isSessionReady = false;
+                hasBootstrapped = false;
+            }
+        });
+    }
+    
+    /**
+     * Reload session from Firestore and run bootstrap with fresh data
+     * This should be called after the user confirms their role in LoginActivity
+     */
+    public void reloadSessionAndBootstrap(final SessionReadyCallback callback) {
+        Log.i(TAG, "ğŸ”„ Reloading session from Firestore and running bootstrap...");
+        
+        FirebaseUser user = auth.getCurrentUser();
+        if (user == null) {
+            Log.e(TAG, "Cannot reload session: user not authenticated");
+            if (callback != null) {
+                callback.onSessionError("User not authenticated");
+            }
+            return;
+        }
+        
+        // Force reload session to get latest data from Firestore
+        userSession.reloadSession(new UserSession.SessionLoadCallback() {
+            @Override
+            public void onSessionLoaded(String userId, String role, List<String> supervisedUserIds) {
+                Log.i("SESSION", "âœ… Session reloaded - user=" + userId + " role=" + role + " supervised=" + supervisedUserIds);
+                
+                // Update cached session data
+                updateSessionCache(userId, role, supervisedUserIds);
+                
+                // Now run bootstrap with correct data
+                Log.i(TAG, "ğŸš€ Running post-auth bootstrap with confirmed role: " + role);
+                runPostAuthBootstrap(role, supervisedUserIds);
+                hasBootstrapped = true;
+                
+                if (callback != null) {
+                    callback.onSessionReady(userId, role, supervisedUserIds);
+                }
+            }
+            
+            @Override
+            public void onSessionLoadError(String error) {
+                Log.e(TAG, "Failed to reload session: " + error);
+                if (callback != null) {
+                    callback.onSessionError(error);
+                }
+            }
+        });
+    }
+    
+    /**
+     * Handle user sign-out - cleanup and reset state
+     */
+    private void handleUserSignedOut() {
+        Log.d(TAG, "User signed out, cleaning up session");
+        
+        // Stop all mirrors and clear data
+        syncService.stopAllMirrors();
+        syncService.clearLocalData();
+        
+        // Reset GlobalData
+        GlobalData.getInstance().resetSessionData();
+        
+        // Reset session state
+        isSessionReady = false;
+        hasBootstrapped = false;
+        currentUserUid = null;
+        currentUserRole = null;
+        supervisedUserIds = null;
+    }
+    
+    /**
+     * Run post-authentication bootstrap based on user role
+     */
+    private void runPostAuthBootstrap(String role, List<String> supervisedSensorIds) {
+        Log.i(TAG, "Running post-auth bootstrap for role: " + role);
+        // #region agent log
+        android.util.Log.w("DBG_SUP", "runPostAuthBootstrap: role=" + role + ", sensorIds=" + supervisedSensorIds);
+        // #endregion
+        
+        if ("aggregator".equals(role)) {
+            runAggregatorPipeline();
+        } else if ("supervisor".equals(role)) {
+            runSupervisorPipeline(supervisedSensorIds);
+        } else {
+            Log.w(TAG, "Unknown role: " + role);
+        }
+    }
+    
+    /**
+     * Run aggregator user pipeline (backfill their own data from cloud)
+     */
+    private void runAggregatorPipeline() {
+        Log.i(TAG, "Starting aggregator pipeline");
+        // #region agent log
+        android.util.Log.w("DBG_SUP", "runAggregatorPipeline: starting backfill for current user");
+        // #endregion
+        
+        // Backfill current user's data from cloud
+        syncService.backfillLocalFromCloudForCurrentUser(new FirestoreSyncService.SyncCallback() {
+            @Override
+            public void onSuccess(String message) {
+                Log.i(TAG, "Aggregator backfill completed: " + message);
+                // #region agent log
+                android.util.Log.w("DBG_SUP", "runAggregatorPipeline: backfill success - " + message);
+                // #endregion
+            }
+            
+            @Override
+            public void onError(String error) {
+                Log.w(TAG, "Aggregator backfill failed: " + error);
+                // #region agent log
+                android.util.Log.w("DBG_SUP", "runAggregatorPipeline: backfill error - " + error);
+                // #endregion
+            }
+            
+            @Override
+            public void onProgress(int current, int total) {
+                Log.d(TAG, "Aggregator backfill progress: " + current + "/" + total);
+            }
+        });
+    }
+    
+    /**
+     * Run supervisor pipeline - sync data for supervised sensors
+     */
+    private void runSupervisorPipeline(List<String> supervisedSensorIds) {
+        Log.i(TAG, "Starting supervisor pipeline for " + supervisedSensorIds.size() + " sensors");
+        // #region agent log
+        android.util.Log.w("DBG_SUP", "runSupervisorPipeline: sensorIds=" + supervisedSensorIds);
+        // #endregion
+        
+        if (supervisedSensorIds.isEmpty()) {
+            Log.w(TAG, "No supervised sensors found for supervisor - check Firestore supervisedSensorIds field");
+            // #region agent log
+            android.util.Log.e("DBG_SUP", "runSupervisorPipeline: EMPTY sensorIds! Supervisor needs supervisedSensorIds in Firestore");
+            // #endregion
+            return;
+        }
+        
+        // First, sync existing data from Firestore for these sensors
+        syncService.syncFromSupervisedSensors(supervisedSensorIds, new FirestoreSyncService.SyncCallback() {
+            @Override
+            public void onSuccess(String message) {
+                Log.i(TAG, "Supervisor initial sync completed: " + message);
+                // #region agent log
+                android.util.Log.w("DBG_SUP", "runSupervisorPipeline: initial sync success - " + message);
+                // #endregion
+                
+                // Now start real-time mirrors for ongoing updates
+                syncService.startSupervisorMirrors(supervisedSensorIds);
+            }
+            
+            @Override
+            public void onError(String error) {
+                Log.w(TAG, "Supervisor initial sync failed: " + error);
+                // #region agent log
+                android.util.Log.e("DBG_SUP", "runSupervisorPipeline: initial sync error - " + error);
+                // #endregion
+                
+                // Still try to start mirrors even if initial sync failed
+                syncService.startSupervisorMirrors(supervisedSensorIds);
+            }
+            
+            @Override
+            public void onProgress(int current, int total) {
+                Log.d(TAG, "Supervisor sync progress: " + current + "/" + total);
+            }
+        });
+    }
+    
+    /**
+     * Check if session is ready
+     */
+    public boolean isSessionReady() {
+        return isSessionReady;
+    }
+    
+    /**
+     * Check if bootstrap has already run
+     */
+    public boolean hasBootstrapped() {
+        return hasBootstrapped;
+    }
+    
+    /**
+     * Get current user UID
+     */
+    public String getCurrentUserUid() {
+        return currentUserUid;
+    }
+    
+    /**
+     * Get current user role
+     */
+    public String getCurrentUserRole() {
+        return currentUserRole;
+    }
+    
+    /**
+     * Get supervised sensor IDs (for supervisor role).
+     * These are the sensor IDs that this supervisor is allowed to monitor.
+     */
+    public List<String> getSupervisedSensorIds() {
+        return supervisedUserIds; // Field is named for backward compat, but contains sensor IDs
+    }
+    
+    /**
+     * @deprecated Use {@link #getSupervisedSensorIds()} instead.
+     */
+    @Deprecated
+    public List<String> getSupervisedUserIds() {
+        return getSupervisedSensorIds();
+    }
+    
+    /**
+     * Wait for session to be ready and execute callback
+     */
+    public void waitForSessionReady(SessionReadyCallback callback) {
+        if (isSessionReady) {
+            callback.onSessionReady(currentUserUid, currentUserRole, supervisedUserIds);
+        } else {
+            // For now, just return error - in a real implementation you might want to queue callbacks
+            callback.onSessionError("Session not ready");
+        }
+    }
+    
+    /**
+     * Clean up resources
+     */
+    public void cleanup() {
+        Log.i(TAG, "Cleaning up SessionGate");
+        // Auth state listener is automatically cleaned up when FirebaseAuth is destroyed
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncActivity.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncActivity.java
index affc6d6..ccc03a1 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncActivity.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncActivity.java
@@ -1,352 +1,352 @@
-package com.melisa.innovamotionapp.sync;
-
-import android.os.Bundle;
-import android.util.Log;
-import android.view.View;
-import android.widget.Button;
-import android.widget.ProgressBar;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import androidx.appcompat.app.AppCompatActivity;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-
-import java.util.List;
-
-/**
- * Sample activity demonstrating how to use the sync functionality.
- * This can be integrated into your existing activities or used as a standalone sync screen.
- * 
- * MANUAL TEST CHECKLIST:
- * =====================
- * 
- * 1. AGGREGATOR USER TESTS:
- *    â–¡ Sign in as aggregator user
- *    â–¡ Connect Bluetooth device and receive messages
- *    â–¡ Verify messages appear in local Room database
- *    â–¡ Verify messages sync to Firestore when online
- *    â–¡ Test offline scenario: disconnect internet, receive messages, reconnect
- *    â–¡ Verify offline messages sync to Firestore after reconnection
- *    â–¡ Check no duplicate messages in Room after sync
- * 
- * 2. SUPERVISOR USER TESTS:
- *    â–¡ Sign in as supervisor with aggregator email
- *    â–¡ Verify supervisor can see aggregator's sensor messages in local Room
- *    â–¡ Test real-time sync: aggregator sends message, supervisor sees it
- *    â–¡ Test offline supervisor: disconnect internet, reconnect
- *    â–¡ Verify supervisor resumes downloading when back online
- *    â–¡ Check no duplicate messages in Room after sync
- * 
- * 3. SUPERVISOR BYPASS TESTS:
- *    â–¡ Sign in as supervisor and tap "Monitoring" button
- *    â–¡ Verify direct navigation to BtConnectedActivity (skips scanning)
- *    â–¡ Check that latest posture from Room is displayed immediately
- *    â–¡ Verify real-time updates as new sensor data arrives
- *    â–¡ Test that supervisors don't exit when Bluetooth disconnects
- *    â–¡ Verify BtSettingsActivity redirects supervisors automatically
- *    â–¡ Test supervisor can monitor specific sensors (extended feature)
- * 
- * 4. CONNECTIVITY TESTS:
- *    â–¡ Toggle airplane mode on/off
- *    â–¡ Switch between WiFi and mobile data
- *    â–¡ Test with poor network connection
- *    â–¡ Verify sync resumes automatically when connectivity restored
- * 
- * 5. ERROR HANDLING TESTS:
- *    â–¡ Test with invalid user role
- *    â–¡ Test with missing sensors
- *    â–¡ Test with Firestore permission errors
- *    â–¡ Verify graceful degradation (app doesn't crash)
- * 
- * 6. DATA INTEGRITY TESTS:
- *    â–¡ Verify deterministic document IDs in Firestore
- *    â–¡ Check unique constraints prevent duplicates
- *    â–¡ Verify messageExists() DAO method works correctly
- *    â–¡ Test with large batches of messages
- * 
- * 6. PERFORMANCE TESTS:
- *    â–¡ Test with 100+ messages
- *    â–¡ Verify batch operations work efficiently
- *    â–¡ Check memory usage during sync
- *    â–¡ Test concurrent Bluetooth and sync operations
- */
-public class SyncActivity extends AppCompatActivity implements SyncManager.SyncProgressListener {
-    private static final String TAG = "SyncActivity";
-    
-    private SyncManager syncManager;
-    private FirestoreSyncService firestoreSyncService;
-    private UserSession userSession;
-    private Button btnFullSync, btnSyncToFirestore, btnSyncToLocal, btnShowUserInfo, btnShowLocalData;
-    private TextView txtSyncStatus, txtSyncProgress, txtUserInfo;
-    private ProgressBar progressBar;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        // Note: You'll need to create this layout file
-        // setContentView(R.layout.activity_sync);
-        
-        syncManager = new SyncManager(this);
-        firestoreSyncService = FirestoreSyncService.getInstance(this);
-        userSession = UserSession.getInstance(this);
-        initializeViews();
-        updateSyncStatus();
-        showUserInfo();
-    }
-
-    private void initializeViews() {
-        // Initialize your UI components here
-        // Example implementation:
-        /*
-        btnFullSync = findViewById(R.id.btn_full_sync);
-        btnSyncToFirestore = findViewById(R.id.btn_sync_to_firestore);
-        btnSyncToLocal = findViewById(R.id.btn_sync_to_local);
-        btnShowUserInfo = findViewById(R.id.btn_show_user_info);
-        btnShowLocalData = findViewById(R.id.btn_show_local_data);
-        txtSyncStatus = findViewById(R.id.txt_sync_status);
-        txtSyncProgress = findViewById(R.id.txt_sync_progress);
-        txtUserInfo = findViewById(R.id.txt_user_info);
-        progressBar = findViewById(R.id.progress_bar);
-
-        btnFullSync.setOnClickListener(v -> performFullSync());
-        btnSyncToFirestore.setOnClickListener(v -> syncLocalToFirestore());
-        btnSyncToLocal.setOnClickListener(v -> syncFirestoreToLocal());
-        btnShowUserInfo.setOnClickListener(v -> showUserInfo());
-        btnShowLocalData.setOnClickListener(v -> showLocalData());
-        // Note: Add backfill buttons to layout for testing
-        // findViewById(R.id.btn_backfill).setOnClickListener(v -> performBackfill());
-        // findViewById(R.id.btn_backfill_paged).setOnClickListener(v -> performPagedBackfill());
-        */
-    }
-
-    private void updateSyncStatus() {
-        SyncManager.SyncStatus status = syncManager.getSyncStatus();
-        
-        String statusText = "Connection: " + (status.isConnected() ? "Online" : "Offline") + "\n" +
-                           "Authentication: " + (status.isAuthenticated() ? "Signed In" : "Not Signed In") + "\n" +
-                           "User Session Loaded: " + (firestoreSyncService.isUserSessionLoaded() ? "Yes" : "No") + "\n" +
-                           "User Role: " + (firestoreSyncService.getCurrentUserRole() != null ? firestoreSyncService.getCurrentUserRole() : "Unknown") + "\n" +
-                           "Can Sync: " + (status.canSync() ? "Yes" : "No");
-        
-        if (txtSyncStatus != null) {
-            txtSyncStatus.setText(statusText);
-        }
-        
-        // Enable/disable sync buttons based on status
-        boolean canSync = status.canSync();
-        if (btnFullSync != null) btnFullSync.setEnabled(canSync);
-        if (btnSyncToFirestore != null) btnSyncToFirestore.setEnabled(canSync);
-        if (btnSyncToLocal != null) btnSyncToLocal.setEnabled(canSync);
-    }
-    
-    /**
-     * Show detailed user session information for debugging
-     */
-    private void showUserInfo() {
-        if (userSession.isLoaded()) {
-            String userInfo = "User ID: " + userSession.getCurrentUserId() + "\n" +
-                             "Role: " + userSession.getRole() + "\n" +
-                             "Supervised Sensor IDs: " + userSession.getSupervisedSensorIds().toString();
-            
-            if (txtUserInfo != null) {
-                txtUserInfo.setText(userInfo);
-            }
-            
-            Log.d(TAG, "User Info: " + userInfo);
-        } else {
-            Log.d(TAG, "User session not loaded yet");
-            if (txtUserInfo != null) {
-                txtUserInfo.setText("Loading user session...");
-            }
-            
-            // Try to reload session
-            userSession.loadUserSession(new UserSession.SessionLoadCallback() {
-                @Override
-                public void onSessionLoaded(String userId, String role, List<String> supervisedUserIds) {
-                    runOnUiThread(() -> showUserInfo());
-                }
-
-                @Override
-                public void onSessionLoadError(String error) {
-                    runOnUiThread(() -> {
-                        if (txtUserInfo != null) {
-                            txtUserInfo.setText("Error loading session: " + error);
-                        }
-                    });
-                }
-            });
-        }
-    }
-    
-    /**
-     * Show local database data for debugging
-     */
-    private void showLocalData() {
-        new Thread(() -> {
-            try {
-                ReceivedBtDataDao dao = InnovaDatabase.getInstance(this).receivedBtDataDao();
-                List<ReceivedBtDataEntity> allData = dao.getAllDataSync();
-                
-                runOnUiThread(() -> {
-                    String dataInfo = "Local Database Messages: " + allData.size() + "\n";
-                    if (allData.size() > 0) {
-                        dataInfo += "Latest message: " + allData.get(allData.size() - 1).getReceivedMsg() + "\n";
-                        dataInfo += "Timestamp: " + allData.get(allData.size() - 1).getTimestamp();
-                    }
-                    
-                    Toast.makeText(this, dataInfo, Toast.LENGTH_LONG).show();
-                    Log.d(TAG, "Local Data Info: " + dataInfo);
-                });
-            } catch (Exception e) {
-                Log.e(TAG, "Error getting local data", e);
-                runOnUiThread(() -> {
-                    Toast.makeText(this, "Error getting local data: " + e.getMessage(), Toast.LENGTH_LONG).show();
-                });
-            }
-        }).start();
-    }
-
-    private void performFullSync() {
-        syncManager.performFullSync(this);
-    }
-
-    private void syncLocalToFirestore() {
-        syncManager.syncLocalToFirestore(this);
-    }
-
-    private void syncFirestoreToLocal() {
-        syncManager.syncFirestoreToLocal(this);
-    }
-    
-    /**
-     * Manual backfill trigger for testing (aggregator users only)
-     */
-    private void performBackfill() {
-        firestoreSyncService.backfillLocalFromCloudForCurrentUser(new FirestoreSyncService.SyncCallback() {
-            @Override
-            public void onSuccess(String message) {
-                runOnUiThread(() -> {
-                    Toast.makeText(SyncActivity.this, "Backfill completed: " + message, Toast.LENGTH_LONG).show();
-                    showLocalData(); // Show updated data count
-                });
-            }
-
-            @Override
-            public void onError(String error) {
-                runOnUiThread(() -> {
-                    Toast.makeText(SyncActivity.this, "Backfill failed: " + error, Toast.LENGTH_LONG).show();
-                });
-            }
-
-            @Override
-            public void onProgress(int current, int total) {
-                Log.d(TAG, "Backfill progress: " + current + "/" + total);
-            }
-        });
-    }
-    
-    /**
-     * Manual paged backfill trigger for testing (aggregator users only)
-     */
-    private void performPagedBackfill() {
-        firestoreSyncService.backfillLocalFromCloudForCurrentUserPaged(new FirestoreSyncService.SyncCallback() {
-            @Override
-            public void onSuccess(String message) {
-                runOnUiThread(() -> {
-                    Toast.makeText(SyncActivity.this, "Paged backfill completed: " + message, Toast.LENGTH_LONG).show();
-                    showLocalData(); // Show updated data count
-                });
-            }
-
-            @Override
-            public void onError(String error) {
-                runOnUiThread(() -> {
-                    Toast.makeText(SyncActivity.this, "Paged backfill failed: " + error, Toast.LENGTH_LONG).show();
-                });
-            }
-
-            @Override
-            public void onProgress(int current, int total) {
-                Log.d(TAG, "Paged backfill progress: " + current + "/" + (total == -1 ? "?" : total));
-            }
-        });
-    }
-
-    // SyncProgressListener implementation
-    @Override
-    public void onSyncStarted(String message) {
-        runOnUiThread(() -> {
-            if (txtSyncProgress != null) {
-                txtSyncProgress.setText(message);
-            }
-            if (progressBar != null) {
-                progressBar.setVisibility(View.VISIBLE);
-                progressBar.setIndeterminate(true);
-            }
-            setButtonsEnabled(false);
-        });
-    }
-
-    @Override
-    public void onSyncProgress(int current, int total) {
-        runOnUiThread(() -> {
-            if (progressBar != null) {
-                progressBar.setIndeterminate(false);
-                progressBar.setMax(total);
-                progressBar.setProgress(current);
-            }
-            if (txtSyncProgress != null) {
-                txtSyncProgress.setText("Syncing " + current + "/" + total + " messages...");
-            }
-        });
-    }
-
-    @Override
-    public void onSyncCompleted(String message) {
-        runOnUiThread(() -> {
-            if (txtSyncProgress != null) {
-                txtSyncProgress.setText("Sync completed: " + message);
-            }
-            if (progressBar != null) {
-                progressBar.setVisibility(View.GONE);
-            }
-            setButtonsEnabled(true);
-            updateSyncStatus();
-            Toast.makeText(this, "Sync completed successfully", Toast.LENGTH_SHORT).show();
-        });
-    }
-
-    @Override
-    public void onSyncError(String error) {
-        runOnUiThread(() -> {
-            if (txtSyncProgress != null) {
-                txtSyncProgress.setText("Sync error: " + error);
-            }
-            if (progressBar != null) {
-                progressBar.setVisibility(View.GONE);
-            }
-            setButtonsEnabled(true);
-            updateSyncStatus();
-            Toast.makeText(this, "Sync failed: " + error, Toast.LENGTH_LONG).show();
-        });
-    }
-
-    private void setButtonsEnabled(boolean enabled) {
-        SyncManager.SyncStatus status = syncManager.getSyncStatus();
-        boolean canSync = enabled && status.canSync();
-        
-        if (btnFullSync != null) btnFullSync.setEnabled(canSync);
-        if (btnSyncToFirestore != null) btnSyncToFirestore.setEnabled(canSync);
-        if (btnSyncToLocal != null) btnSyncToLocal.setEnabled(canSync);
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        updateSyncStatus();
-    }
-}
+package com.melisa.innovamotionapp.sync;
+
+import android.os.Bundle;
+import android.util.Log;
+import android.view.View;
+import android.widget.Button;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import androidx.appcompat.app.AppCompatActivity;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+
+import java.util.List;
+
+/**
+ * Sample activity demonstrating how to use the sync functionality.
+ * This can be integrated into your existing activities or used as a standalone sync screen.
+ * 
+ * MANUAL TEST CHECKLIST:
+ * =====================
+ * 
+ * 1. AGGREGATOR USER TESTS:
+ *    â–¡ Sign in as aggregator user
+ *    â–¡ Connect Bluetooth device and receive messages
+ *    â–¡ Verify messages appear in local Room database
+ *    â–¡ Verify messages sync to Firestore when online
+ *    â–¡ Test offline scenario: disconnect internet, receive messages, reconnect
+ *    â–¡ Verify offline messages sync to Firestore after reconnection
+ *    â–¡ Check no duplicate messages in Room after sync
+ * 
+ * 2. SUPERVISOR USER TESTS:
+ *    â–¡ Sign in as supervisor with aggregator email
+ *    â–¡ Verify supervisor can see aggregator's sensor messages in local Room
+ *    â–¡ Test real-time sync: aggregator sends message, supervisor sees it
+ *    â–¡ Test offline supervisor: disconnect internet, reconnect
+ *    â–¡ Verify supervisor resumes downloading when back online
+ *    â–¡ Check no duplicate messages in Room after sync
+ * 
+ * 3. SUPERVISOR BYPASS TESTS:
+ *    â–¡ Sign in as supervisor and tap "Monitoring" button
+ *    â–¡ Verify direct navigation to BtConnectedActivity (skips scanning)
+ *    â–¡ Check that latest posture from Room is displayed immediately
+ *    â–¡ Verify real-time updates as new sensor data arrives
+ *    â–¡ Test that supervisors don't exit when Bluetooth disconnects
+ *    â–¡ Verify BtSettingsActivity redirects supervisors automatically
+ *    â–¡ Test supervisor can monitor specific sensors (extended feature)
+ * 
+ * 4. CONNECTIVITY TESTS:
+ *    â–¡ Toggle airplane mode on/off
+ *    â–¡ Switch between WiFi and mobile data
+ *    â–¡ Test with poor network connection
+ *    â–¡ Verify sync resumes automatically when connectivity restored
+ * 
+ * 5. ERROR HANDLING TESTS:
+ *    â–¡ Test with invalid user role
+ *    â–¡ Test with missing sensors
+ *    â–¡ Test with Firestore permission errors
+ *    â–¡ Verify graceful degradation (app doesn't crash)
+ * 
+ * 6. DATA INTEGRITY TESTS:
+ *    â–¡ Verify deterministic document IDs in Firestore
+ *    â–¡ Check unique constraints prevent duplicates
+ *    â–¡ Verify messageExists() DAO method works correctly
+ *    â–¡ Test with large batches of messages
+ * 
+ * 6. PERFORMANCE TESTS:
+ *    â–¡ Test with 100+ messages
+ *    â–¡ Verify batch operations work efficiently
+ *    â–¡ Check memory usage during sync
+ *    â–¡ Test concurrent Bluetooth and sync operations
+ */
+public class SyncActivity extends AppCompatActivity implements SyncManager.SyncProgressListener {
+    private static final String TAG = "SyncActivity";
+    
+    private SyncManager syncManager;
+    private FirestoreSyncService firestoreSyncService;
+    private UserSession userSession;
+    private Button btnFullSync, btnSyncToFirestore, btnSyncToLocal, btnShowUserInfo, btnShowLocalData;
+    private TextView txtSyncStatus, txtSyncProgress, txtUserInfo;
+    private ProgressBar progressBar;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        // Note: You'll need to create this layout file
+        // setContentView(R.layout.activity_sync);
+        
+        syncManager = new SyncManager(this);
+        firestoreSyncService = FirestoreSyncService.getInstance(this);
+        userSession = UserSession.getInstance(this);
+        initializeViews();
+        updateSyncStatus();
+        showUserInfo();
+    }
+
+    private void initializeViews() {
+        // Initialize your UI components here
+        // Example implementation:
+        /*
+        btnFullSync = findViewById(R.id.btn_full_sync);
+        btnSyncToFirestore = findViewById(R.id.btn_sync_to_firestore);
+        btnSyncToLocal = findViewById(R.id.btn_sync_to_local);
+        btnShowUserInfo = findViewById(R.id.btn_show_user_info);
+        btnShowLocalData = findViewById(R.id.btn_show_local_data);
+        txtSyncStatus = findViewById(R.id.txt_sync_status);
+        txtSyncProgress = findViewById(R.id.txt_sync_progress);
+        txtUserInfo = findViewById(R.id.txt_user_info);
+        progressBar = findViewById(R.id.progress_bar);
+
+        btnFullSync.setOnClickListener(v -> performFullSync());
+        btnSyncToFirestore.setOnClickListener(v -> syncLocalToFirestore());
+        btnSyncToLocal.setOnClickListener(v -> syncFirestoreToLocal());
+        btnShowUserInfo.setOnClickListener(v -> showUserInfo());
+        btnShowLocalData.setOnClickListener(v -> showLocalData());
+        // Note: Add backfill buttons to layout for testing
+        // findViewById(R.id.btn_backfill).setOnClickListener(v -> performBackfill());
+        // findViewById(R.id.btn_backfill_paged).setOnClickListener(v -> performPagedBackfill());
+        */
+    }
+
+    private void updateSyncStatus() {
+        SyncManager.SyncStatus status = syncManager.getSyncStatus();
+        
+        String statusText = "Connection: " + (status.isConnected() ? "Online" : "Offline") + "\n" +
+                           "Authentication: " + (status.isAuthenticated() ? "Signed In" : "Not Signed In") + "\n" +
+                           "User Session Loaded: " + (firestoreSyncService.isUserSessionLoaded() ? "Yes" : "No") + "\n" +
+                           "User Role: " + (firestoreSyncService.getCurrentUserRole() != null ? firestoreSyncService.getCurrentUserRole() : "Unknown") + "\n" +
+                           "Can Sync: " + (status.canSync() ? "Yes" : "No");
+        
+        if (txtSyncStatus != null) {
+            txtSyncStatus.setText(statusText);
+        }
+        
+        // Enable/disable sync buttons based on status
+        boolean canSync = status.canSync();
+        if (btnFullSync != null) btnFullSync.setEnabled(canSync);
+        if (btnSyncToFirestore != null) btnSyncToFirestore.setEnabled(canSync);
+        if (btnSyncToLocal != null) btnSyncToLocal.setEnabled(canSync);
+    }
+    
+    /**
+     * Show detailed user session information for debugging
+     */
+    private void showUserInfo() {
+        if (userSession.isLoaded()) {
+            String userInfo = "User ID: " + userSession.getCurrentUserId() + "\n" +
+                             "Role: " + userSession.getRole() + "\n" +
+                             "Supervised Sensor IDs: " + userSession.getSupervisedSensorIds().toString();
+            
+            if (txtUserInfo != null) {
+                txtUserInfo.setText(userInfo);
+            }
+            
+            Log.d(TAG, "User Info: " + userInfo);
+        } else {
+            Log.d(TAG, "User session not loaded yet");
+            if (txtUserInfo != null) {
+                txtUserInfo.setText("Loading user session...");
+            }
+            
+            // Try to reload session
+            userSession.loadUserSession(new UserSession.SessionLoadCallback() {
+                @Override
+                public void onSessionLoaded(String userId, String role, List<String> supervisedUserIds) {
+                    runOnUiThread(() -> showUserInfo());
+                }
+
+                @Override
+                public void onSessionLoadError(String error) {
+                    runOnUiThread(() -> {
+                        if (txtUserInfo != null) {
+                            txtUserInfo.setText("Error loading session: " + error);
+                        }
+                    });
+                }
+            });
+        }
+    }
+    
+    /**
+     * Show local database data for debugging
+     */
+    private void showLocalData() {
+        new Thread(() -> {
+            try {
+                ReceivedBtDataDao dao = InnovaDatabase.getInstance(this).receivedBtDataDao();
+                List<ReceivedBtDataEntity> allData = dao.getAllDataSync();
+                
+                runOnUiThread(() -> {
+                    String dataInfo = "Local Database Messages: " + allData.size() + "\n";
+                    if (allData.size() > 0) {
+                        dataInfo += "Latest message: " + allData.get(allData.size() - 1).getReceivedMsg() + "\n";
+                        dataInfo += "Timestamp: " + allData.get(allData.size() - 1).getTimestamp();
+                    }
+                    
+                    Toast.makeText(this, dataInfo, Toast.LENGTH_LONG).show();
+                    Log.d(TAG, "Local Data Info: " + dataInfo);
+                });
+            } catch (Exception e) {
+                Log.e(TAG, "Error getting local data", e);
+                runOnUiThread(() -> {
+                    Toast.makeText(this, "Error getting local data: " + e.getMessage(), Toast.LENGTH_LONG).show();
+                });
+            }
+        }).start();
+    }
+
+    private void performFullSync() {
+        syncManager.performFullSync(this);
+    }
+
+    private void syncLocalToFirestore() {
+        syncManager.syncLocalToFirestore(this);
+    }
+
+    private void syncFirestoreToLocal() {
+        syncManager.syncFirestoreToLocal(this);
+    }
+    
+    /**
+     * Manual backfill trigger for testing (aggregator users only)
+     */
+    private void performBackfill() {
+        firestoreSyncService.backfillLocalFromCloudForCurrentUser(new FirestoreSyncService.SyncCallback() {
+            @Override
+            public void onSuccess(String message) {
+                runOnUiThread(() -> {
+                    Toast.makeText(SyncActivity.this, "Backfill completed: " + message, Toast.LENGTH_LONG).show();
+                    showLocalData(); // Show updated data count
+                });
+            }
+
+            @Override
+            public void onError(String error) {
+                runOnUiThread(() -> {
+                    Toast.makeText(SyncActivity.this, "Backfill failed: " + error, Toast.LENGTH_LONG).show();
+                });
+            }
+
+            @Override
+            public void onProgress(int current, int total) {
+                Log.d(TAG, "Backfill progress: " + current + "/" + total);
+            }
+        });
+    }
+    
+    /**
+     * Manual paged backfill trigger for testing (aggregator users only)
+     */
+    private void performPagedBackfill() {
+        firestoreSyncService.backfillLocalFromCloudForCurrentUserPaged(new FirestoreSyncService.SyncCallback() {
+            @Override
+            public void onSuccess(String message) {
+                runOnUiThread(() -> {
+                    Toast.makeText(SyncActivity.this, "Paged backfill completed: " + message, Toast.LENGTH_LONG).show();
+                    showLocalData(); // Show updated data count
+                });
+            }
+
+            @Override
+            public void onError(String error) {
+                runOnUiThread(() -> {
+                    Toast.makeText(SyncActivity.this, "Paged backfill failed: " + error, Toast.LENGTH_LONG).show();
+                });
+            }
+
+            @Override
+            public void onProgress(int current, int total) {
+                Log.d(TAG, "Paged backfill progress: " + current + "/" + (total == -1 ? "?" : total));
+            }
+        });
+    }
+
+    // SyncProgressListener implementation
+    @Override
+    public void onSyncStarted(String message) {
+        runOnUiThread(() -> {
+            if (txtSyncProgress != null) {
+                txtSyncProgress.setText(message);
+            }
+            if (progressBar != null) {
+                progressBar.setVisibility(View.VISIBLE);
+                progressBar.setIndeterminate(true);
+            }
+            setButtonsEnabled(false);
+        });
+    }
+
+    @Override
+    public void onSyncProgress(int current, int total) {
+        runOnUiThread(() -> {
+            if (progressBar != null) {
+                progressBar.setIndeterminate(false);
+                progressBar.setMax(total);
+                progressBar.setProgress(current);
+            }
+            if (txtSyncProgress != null) {
+                txtSyncProgress.setText("Syncing " + current + "/" + total + " messages...");
+            }
+        });
+    }
+
+    @Override
+    public void onSyncCompleted(String message) {
+        runOnUiThread(() -> {
+            if (txtSyncProgress != null) {
+                txtSyncProgress.setText("Sync completed: " + message);
+            }
+            if (progressBar != null) {
+                progressBar.setVisibility(View.GONE);
+            }
+            setButtonsEnabled(true);
+            updateSyncStatus();
+            Toast.makeText(this, "Sync completed successfully", Toast.LENGTH_SHORT).show();
+        });
+    }
+
+    @Override
+    public void onSyncError(String error) {
+        runOnUiThread(() -> {
+            if (txtSyncProgress != null) {
+                txtSyncProgress.setText("Sync error: " + error);
+            }
+            if (progressBar != null) {
+                progressBar.setVisibility(View.GONE);
+            }
+            setButtonsEnabled(true);
+            updateSyncStatus();
+            Toast.makeText(this, "Sync failed: " + error, Toast.LENGTH_LONG).show();
+        });
+    }
+
+    private void setButtonsEnabled(boolean enabled) {
+        SyncManager.SyncStatus status = syncManager.getSyncStatus();
+        boolean canSync = enabled && status.canSync();
+        
+        if (btnFullSync != null) btnFullSync.setEnabled(canSync);
+        if (btnSyncToFirestore != null) btnSyncToFirestore.setEnabled(canSync);
+        if (btnSyncToLocal != null) btnSyncToLocal.setEnabled(canSync);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        updateSyncStatus();
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncManager.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncManager.java
index 150e3af..f79fc92 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncManager.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/SyncManager.java
@@ -1,217 +1,217 @@
-package com.melisa.innovamotionapp.sync;
-
-import android.content.Context;
-import android.util.Log;
-
-/**
- * Manager class for handling sync operations from UI components.
- * Provides a simple interface for activities and fragments to trigger sync operations.
- */
-public class SyncManager {
-    private static final String TAG = "SyncManager";
-    
-    private final FirestoreSyncService syncService;
-    private final Context context;
-    
-    public SyncManager(Context context) {
-        this.context = context.getApplicationContext();
-        this.syncService = FirestoreSyncService.getInstance(context);
-    }
-
-    /**
-     * Perform a full bidirectional sync
-     */
-    public void performFullSync(SyncProgressListener listener) {
-        Log.i(TAG, "Starting full sync operation");
-        
-        if (!syncService.isConnected()) {
-            if (listener != null) {
-                listener.onSyncError("No internet connection available");
-            }
-            return;
-        }
-
-        if (syncService.getCurrentUserId() == null) {
-            if (listener != null) {
-                listener.onSyncError("User not authenticated");
-            }
-            return;
-        }
-
-        if (listener != null) {
-            listener.onSyncStarted("Starting full synchronization...");
-        }
-
-        syncService.performFullSync(new FirestoreSyncService.SyncCallback() {
-            @Override
-            public void onSuccess(String message) {
-                Log.i(TAG, "Full sync completed successfully: " + message);
-                if (listener != null) {
-                    listener.onSyncCompleted(message);
-                }
-            }
-
-            @Override
-            public void onError(String error) {
-                Log.e(TAG, "Full sync failed: " + error);
-                if (listener != null) {
-                    listener.onSyncError(error);
-                }
-            }
-
-            @Override
-            public void onProgress(int current, int total) {
-                if (listener != null) {
-                    listener.onSyncProgress(current, total);
-                }
-            }
-        });
-    }
-
-    /**
-     * Sync local data to Firestore only
-     */
-    public void syncLocalToFirestore(SyncProgressListener listener) {
-        Log.i(TAG, "Starting local to Firestore sync");
-        
-        if (!syncService.isConnected()) {
-            if (listener != null) {
-                listener.onSyncError("No internet connection available");
-            }
-            return;
-        }
-
-        if (listener != null) {
-            listener.onSyncStarted("Syncing local data to cloud...");
-        }
-
-        syncService.syncLocalDataToFirestore(new FirestoreSyncService.SyncCallback() {
-            @Override
-            public void onSuccess(String message) {
-                Log.i(TAG, "Local to Firestore sync completed: " + message);
-                if (listener != null) {
-                    listener.onSyncCompleted(message);
-                }
-            }
-
-            @Override
-            public void onError(String error) {
-                Log.e(TAG, "Local to Firestore sync failed: " + error);
-                if (listener != null) {
-                    listener.onSyncError(error);
-                }
-            }
-
-            @Override
-            public void onProgress(int current, int total) {
-                if (listener != null) {
-                    listener.onSyncProgress(current, total);
-                }
-            }
-        });
-    }
-
-    /**
-     * Sync Firestore data to local database only
-     */
-    public void syncFirestoreToLocal(SyncProgressListener listener) {
-        Log.i(TAG, "Starting Firestore to local sync");
-        
-        if (!syncService.isConnected()) {
-            if (listener != null) {
-                listener.onSyncError("No internet connection available");
-            }
-            return;
-        }
-
-        if (listener != null) {
-            listener.onSyncStarted("Downloading cloud data...");
-        }
-
-        syncService.syncFirestoreDataToLocal(new FirestoreSyncService.SyncCallback() {
-            @Override
-            public void onSuccess(String message) {
-                Log.i(TAG, "Firestore to local sync completed: " + message);
-                if (listener != null) {
-                    listener.onSyncCompleted(message);
-                }
-            }
-
-            @Override
-            public void onError(String error) {
-                Log.e(TAG, "Firestore to local sync failed: " + error);
-                if (listener != null) {
-                    listener.onSyncError(error);
-                }
-            }
-
-            @Override
-            public void onProgress(int current, int total) {
-                if (listener != null) {
-                    listener.onSyncProgress(current, total);
-                }
-            }
-        });
-    }
-
-    /**
-     * Check sync status and connectivity
-     */
-    public SyncStatus getSyncStatus() {
-        return new SyncStatus(
-            syncService.isConnected(),
-            syncService.getCurrentUserId() != null,
-            syncService.getCurrentUserId()
-        );
-    }
-
-    /**
-     * Interface for sync progress callbacks
-     */
-    public interface SyncProgressListener {
-        void onSyncStarted(String message);
-        void onSyncProgress(int current, int total);
-        void onSyncCompleted(String message);
-        void onSyncError(String error);
-    }
-
-    /**
-     * Sync status information
-     */
-    public static class SyncStatus {
-        private final boolean isConnected;
-        private final boolean isAuthenticated;
-        private final String userId;
-
-        public SyncStatus(boolean isConnected, boolean isAuthenticated, String userId) {
-            this.isConnected = isConnected;
-            this.isAuthenticated = isAuthenticated;
-            this.userId = userId;
-        }
-
-        public boolean isConnected() {
-            return isConnected;
-        }
-
-        public boolean isAuthenticated() {
-            return isAuthenticated;
-        }
-
-        public String getUserId() {
-            return userId;
-        }
-
-        public boolean canSync() {
-            return isConnected && isAuthenticated;
-        }
-
-        @Override
-        public String toString() {
-            return "SyncStatus{" +
-                    "connected=" + isConnected +
-                    ", authenticated=" + isAuthenticated +
-                    ", userId='" + userId + '\'' +
-                    '}';
-        }
-    }
-}
+package com.melisa.innovamotionapp.sync;
+
+import android.content.Context;
+import android.util.Log;
+
+/**
+ * Manager class for handling sync operations from UI components.
+ * Provides a simple interface for activities and fragments to trigger sync operations.
+ */
+public class SyncManager {
+    private static final String TAG = "SyncManager";
+    
+    private final FirestoreSyncService syncService;
+    private final Context context;
+    
+    public SyncManager(Context context) {
+        this.context = context.getApplicationContext();
+        this.syncService = FirestoreSyncService.getInstance(context);
+    }
+
+    /**
+     * Perform a full bidirectional sync
+     */
+    public void performFullSync(SyncProgressListener listener) {
+        Log.i(TAG, "Starting full sync operation");
+        
+        if (!syncService.isConnected()) {
+            if (listener != null) {
+                listener.onSyncError("No internet connection available");
+            }
+            return;
+        }
+
+        if (syncService.getCurrentUserId() == null) {
+            if (listener != null) {
+                listener.onSyncError("User not authenticated");
+            }
+            return;
+        }
+
+        if (listener != null) {
+            listener.onSyncStarted("Starting full synchronization...");
+        }
+
+        syncService.performFullSync(new FirestoreSyncService.SyncCallback() {
+            @Override
+            public void onSuccess(String message) {
+                Log.i(TAG, "Full sync completed successfully: " + message);
+                if (listener != null) {
+                    listener.onSyncCompleted(message);
+                }
+            }
+
+            @Override
+            public void onError(String error) {
+                Log.e(TAG, "Full sync failed: " + error);
+                if (listener != null) {
+                    listener.onSyncError(error);
+                }
+            }
+
+            @Override
+            public void onProgress(int current, int total) {
+                if (listener != null) {
+                    listener.onSyncProgress(current, total);
+                }
+            }
+        });
+    }
+
+    /**
+     * Sync local data to Firestore only
+     */
+    public void syncLocalToFirestore(SyncProgressListener listener) {
+        Log.i(TAG, "Starting local to Firestore sync");
+        
+        if (!syncService.isConnected()) {
+            if (listener != null) {
+                listener.onSyncError("No internet connection available");
+            }
+            return;
+        }
+
+        if (listener != null) {
+            listener.onSyncStarted("Syncing local data to cloud...");
+        }
+
+        syncService.syncLocalDataToFirestore(new FirestoreSyncService.SyncCallback() {
+            @Override
+            public void onSuccess(String message) {
+                Log.i(TAG, "Local to Firestore sync completed: " + message);
+                if (listener != null) {
+                    listener.onSyncCompleted(message);
+                }
+            }
+
+            @Override
+            public void onError(String error) {
+                Log.e(TAG, "Local to Firestore sync failed: " + error);
+                if (listener != null) {
+                    listener.onSyncError(error);
+                }
+            }
+
+            @Override
+            public void onProgress(int current, int total) {
+                if (listener != null) {
+                    listener.onSyncProgress(current, total);
+                }
+            }
+        });
+    }
+
+    /**
+     * Sync Firestore data to local database only
+     */
+    public void syncFirestoreToLocal(SyncProgressListener listener) {
+        Log.i(TAG, "Starting Firestore to local sync");
+        
+        if (!syncService.isConnected()) {
+            if (listener != null) {
+                listener.onSyncError("No internet connection available");
+            }
+            return;
+        }
+
+        if (listener != null) {
+            listener.onSyncStarted("Downloading cloud data...");
+        }
+
+        syncService.syncFirestoreDataToLocal(new FirestoreSyncService.SyncCallback() {
+            @Override
+            public void onSuccess(String message) {
+                Log.i(TAG, "Firestore to local sync completed: " + message);
+                if (listener != null) {
+                    listener.onSyncCompleted(message);
+                }
+            }
+
+            @Override
+            public void onError(String error) {
+                Log.e(TAG, "Firestore to local sync failed: " + error);
+                if (listener != null) {
+                    listener.onSyncError(error);
+                }
+            }
+
+            @Override
+            public void onProgress(int current, int total) {
+                if (listener != null) {
+                    listener.onSyncProgress(current, total);
+                }
+            }
+        });
+    }
+
+    /**
+     * Check sync status and connectivity
+     */
+    public SyncStatus getSyncStatus() {
+        return new SyncStatus(
+            syncService.isConnected(),
+            syncService.getCurrentUserId() != null,
+            syncService.getCurrentUserId()
+        );
+    }
+
+    /**
+     * Interface for sync progress callbacks
+     */
+    public interface SyncProgressListener {
+        void onSyncStarted(String message);
+        void onSyncProgress(int current, int total);
+        void onSyncCompleted(String message);
+        void onSyncError(String error);
+    }
+
+    /**
+     * Sync status information
+     */
+    public static class SyncStatus {
+        private final boolean isConnected;
+        private final boolean isAuthenticated;
+        private final String userId;
+
+        public SyncStatus(boolean isConnected, boolean isAuthenticated, String userId) {
+            this.isConnected = isConnected;
+            this.isAuthenticated = isAuthenticated;
+            this.userId = userId;
+        }
+
+        public boolean isConnected() {
+            return isConnected;
+        }
+
+        public boolean isAuthenticated() {
+            return isAuthenticated;
+        }
+
+        public String getUserId() {
+            return userId;
+        }
+
+        public boolean canSync() {
+            return isConnected && isAuthenticated;
+        }
+
+        @Override
+        public String toString() {
+            return "SyncStatus{" +
+                    "connected=" + isConnected +
+                    ", authenticated=" + isAuthenticated +
+                    ", userId='" + userId + '\'' +
+                    '}';
+        }
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/UserSession.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/UserSession.java
index 8c18676..45834d0 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/UserSession.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/sync/UserSession.java
@@ -152,6 +152,12 @@ public class UserSession {
         // Try to get supervisedSensorIds array first (new architecture)
         @SuppressWarnings("unchecked")
         List<String> sensorIds = (List<String>) document.get("supervisedSensorIds");
+        
+        // #region agent log
+        // H1: Log what supervisedSensorIds were found in Firestore
+        android.util.Log.w("DBG_H1", "loadSupervisedSensorIds: userId=" + currentUserId + ", role=" + role + ", sensorIdsFromFirestore=" + sensorIds + ", aggregatorUid=" + aggregatorUid);
+        // #endregion
+        
         if (sensorIds != null && !sensorIds.isEmpty()) {
             supervisedSensorIds.addAll(sensorIds);
             Log.d(TAG, "Found supervisedSensorIds: " + supervisedSensorIds);
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/NearbyDeviceDataAdapter.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/NearbyDeviceDataAdapter.java
index 659d3fb..e6212e1 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/NearbyDeviceDataAdapter.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/NearbyDeviceDataAdapter.java
@@ -1,63 +1,63 @@
-package com.melisa.innovamotionapp.ui.adapters;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.content.Context;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.uistuff.OnDeviceClickListener;
-
-import java.util.ArrayList;
-
-public class NearbyDeviceDataAdapter extends ArrayAdapter<BluetoothDevice> {
-    private LayoutInflater mLayoutInflater;
-    private ArrayList<BluetoothDevice> mDevices;
-    private int mViewResourceId;
-    private OnDeviceClickListener onDeviceClickListener;
-
-    public NearbyDeviceDataAdapter(Context context, int tvResourceId, ArrayList<BluetoothDevice> devices) {
-        super(context, tvResourceId, devices);
-        this.mDevices = devices;
-        mLayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        mViewResourceId = tvResourceId;
-    }
-
-    public void setOnDeviceClickListener(OnDeviceClickListener onDeviceClickListener) {
-        this.onDeviceClickListener = onDeviceClickListener;
-    }
-
-    @SuppressLint("MissingPermission")
-    public View getView(int position, View convertView, ViewGroup parent) {
-        convertView = mLayoutInflater.inflate(mViewResourceId, null);
-
-        BluetoothDevice device = mDevices.get(position);
-
-        if (device != null) {
-            TextView deviceName = (TextView) convertView.findViewById(R.id.tvDeviceName);
-            TextView deviceAddress = (TextView) convertView.findViewById(R.id.tvDeviceAddress);
-            LinearLayout scanDeviceContainer = (LinearLayout) convertView.findViewById(R.id.scanDeviceContainer);
-
-            if (deviceName != null) {
-                deviceName.setText(device.getName());
-            }
-            if (deviceAddress != null) {
-                deviceAddress.setText(device.getAddress());
-            }
-
-            scanDeviceContainer.setOnClickListener(v -> {
-                if (onDeviceClickListener != null) {
-                    onDeviceClickListener.onDeviceClick(device);
-                }
-            });
-        }
-
-        return convertView;
-    }
-
-}
+package com.melisa.innovamotionapp.ui.adapters;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.uistuff.OnDeviceClickListener;
+
+import java.util.ArrayList;
+
+public class NearbyDeviceDataAdapter extends ArrayAdapter<BluetoothDevice> {
+    private LayoutInflater mLayoutInflater;
+    private ArrayList<BluetoothDevice> mDevices;
+    private int mViewResourceId;
+    private OnDeviceClickListener onDeviceClickListener;
+
+    public NearbyDeviceDataAdapter(Context context, int tvResourceId, ArrayList<BluetoothDevice> devices) {
+        super(context, tvResourceId, devices);
+        this.mDevices = devices;
+        mLayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mViewResourceId = tvResourceId;
+    }
+
+    public void setOnDeviceClickListener(OnDeviceClickListener onDeviceClickListener) {
+        this.onDeviceClickListener = onDeviceClickListener;
+    }
+
+    @SuppressLint("MissingPermission")
+    public View getView(int position, View convertView, ViewGroup parent) {
+        convertView = mLayoutInflater.inflate(mViewResourceId, null);
+
+        BluetoothDevice device = mDevices.get(position);
+
+        if (device != null) {
+            TextView deviceName = (TextView) convertView.findViewById(R.id.tvDeviceName);
+            TextView deviceAddress = (TextView) convertView.findViewById(R.id.tvDeviceAddress);
+            LinearLayout scanDeviceContainer = (LinearLayout) convertView.findViewById(R.id.scanDeviceContainer);
+
+            if (deviceName != null) {
+                deviceName.setText(device.getName());
+            }
+            if (deviceAddress != null) {
+                deviceAddress.setText(device.getAddress());
+            }
+
+            scanDeviceContainer.setOnClickListener(v -> {
+                if (onDeviceClickListener != null) {
+                    onDeviceClickListener.onDeviceClick(device);
+                }
+            });
+        }
+
+        return convertView;
+    }
+
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonNamesAdapter.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonNamesAdapter.java
index 0066f5b..13e9b06 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonNamesAdapter.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonNamesAdapter.java
@@ -1,23 +1,31 @@
 package com.melisa.innovamotionapp.ui.adapters;
 
 import android.view.LayoutInflater;
+import android.view.View;
 import android.view.ViewGroup;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.recyclerview.widget.DiffUtil;
 import androidx.recyclerview.widget.ListAdapter;
 import androidx.recyclerview.widget.RecyclerView;
 
+import com.melisa.innovamotionapp.R;
 import com.melisa.innovamotionapp.data.database.MonitoredPerson;
 import com.melisa.innovamotionapp.databinding.ItemPersonNameBinding;
 
+import java.util.HashMap;
+import java.util.Map;
+
 /**
- * RecyclerView adapter for displaying monitored persons with their display names.
+ * RecyclerView adapter for displaying monitored persons with their display names
+ * and supervisor assignments.
  * Uses ListAdapter with DiffUtil for efficient updates.
  */
 public class PersonNamesAdapter extends ListAdapter<MonitoredPerson, PersonNamesAdapter.ViewHolder> {
 
     private final OnItemClickListener clickListener;
+    private Map<String, String> supervisorMap = new HashMap<>();
 
     /**
      * Callback interface for item click events.
@@ -31,6 +39,15 @@ public class PersonNamesAdapter extends ListAdapter<MonitoredPerson, PersonNames
         this.clickListener = listener;
     }
 
+    /**
+     * Set the supervisor map (sensorId -> supervisorEmail).
+     * This triggers a rebind of all items.
+     */
+    public void setSupervisorMap(@Nullable Map<String, String> map) {
+        this.supervisorMap = map != null ? map : new HashMap<>();
+        notifyDataSetChanged();
+    }
+
     @NonNull
     @Override
     public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
@@ -41,7 +58,9 @@ public class PersonNamesAdapter extends ListAdapter<MonitoredPerson, PersonNames
 
     @Override
     public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
-        holder.bind(getItem(position), clickListener);
+        MonitoredPerson person = getItem(position);
+        String supervisorEmail = supervisorMap.get(person.getSensorId());
+        holder.bind(person, supervisorEmail, clickListener);
     }
 
     static class ViewHolder extends RecyclerView.ViewHolder {
@@ -52,12 +71,22 @@ public class PersonNamesAdapter extends ListAdapter<MonitoredPerson, PersonNames
             this.binding = binding;
         }
 
-        void bind(MonitoredPerson person, OnItemClickListener listener) {
+        void bind(MonitoredPerson person, @Nullable String supervisorEmail, OnItemClickListener listener) {
             // Display name (bold, primary text)
             binding.displayNameText.setText(person.getDisplayName());
             
             // Sensor ID (smaller, gray text)
             binding.sensorIdText.setText(person.getSensorId());
+            
+            // Supervisor info
+            if (supervisorEmail != null && !supervisorEmail.isEmpty()) {
+                binding.supervisorText.setText(
+                        binding.getRoot().getContext().getString(R.string.supervisor_label) + " " + supervisorEmail
+                );
+                binding.supervisorText.setVisibility(View.VISIBLE);
+            } else {
+                binding.supervisorText.setVisibility(View.GONE);
+            }
 
             // Click handlers
             binding.editButton.setOnClickListener(v -> listener.onClick(person));
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/components/PhotoAdapter.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/components/PhotoAdapter.java
index 64f5e76..404cfcc 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/components/PhotoAdapter.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/components/PhotoAdapter.java
@@ -1,68 +1,68 @@
-package com.melisa.innovamotionapp.ui.components;
-
-
-import android.content.Context;
-import android.graphics.BitmapFactory;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ImageView;
-import androidx.annotation.NonNull;
-import androidx.recyclerview.widget.RecyclerView;
-
-import com.melisa.innovamotionapp.R;
-
-import java.util.List;
-
-public class PhotoAdapter extends RecyclerView.Adapter<PhotoAdapter.PhotoViewHolder> {
-
-    private final List<Integer> imagePaths; // Paths to images
-    private final List<String> imageTimestamps; // Timestamps
-    private final OnPhotoChangeListener listener; // Callback for timestamp updates
-    private final Context context;
-
-    public interface OnPhotoChangeListener {
-        void onPhotoChanged(String timestamp);
-    }
-
-    public PhotoAdapter(Context context, List<Integer> imagePaths, List<String> imageTimestamps, OnPhotoChangeListener listener) {
-        this.context = context;
-        this.imagePaths = imagePaths;
-        this.imageTimestamps = imageTimestamps;
-        this.listener = listener;
-    }
-
-    @NonNull
-    @Override
-    public PhotoViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
-        View view = LayoutInflater.from(parent.getContext())
-                .inflate(R.layout.photo_item, parent, false);
-        return new PhotoViewHolder(view);
-    }
-
-    @Override
-    public void onBindViewHolder(@NonNull PhotoViewHolder holder, int position) {
-        Integer imageId = imagePaths.get(position);
-        String timestamp = imageTimestamps.get(position);
-
-        // Load image into the ImageView (e.g., with Glide or BitmapFactory)
-        holder.imageView.setImageBitmap(BitmapFactory.decodeResource(context.getResources(), imageId));
-
-        // Notify the listener of the current timestamp
-        listener.onPhotoChanged(timestamp);
-    }
-
-    @Override
-    public int getItemCount() {
-        return imagePaths.size();
-    }
-
-    static class PhotoViewHolder extends RecyclerView.ViewHolder {
-        ImageView imageView;
-
-        public PhotoViewHolder(@NonNull View itemView) {
-            super(itemView);
-            imageView = itemView.findViewById(R.id.photoImageView);
-        }
-    }
-}
+package com.melisa.innovamotionapp.ui.components;
+
+
+import android.content.Context;
+import android.graphics.BitmapFactory;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.RecyclerView;
+
+import com.melisa.innovamotionapp.R;
+
+import java.util.List;
+
+public class PhotoAdapter extends RecyclerView.Adapter<PhotoAdapter.PhotoViewHolder> {
+
+    private final List<Integer> imagePaths; // Paths to images
+    private final List<String> imageTimestamps; // Timestamps
+    private final OnPhotoChangeListener listener; // Callback for timestamp updates
+    private final Context context;
+
+    public interface OnPhotoChangeListener {
+        void onPhotoChanged(String timestamp);
+    }
+
+    public PhotoAdapter(Context context, List<Integer> imagePaths, List<String> imageTimestamps, OnPhotoChangeListener listener) {
+        this.context = context;
+        this.imagePaths = imagePaths;
+        this.imageTimestamps = imageTimestamps;
+        this.listener = listener;
+    }
+
+    @NonNull
+    @Override
+    public PhotoViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        View view = LayoutInflater.from(parent.getContext())
+                .inflate(R.layout.photo_item, parent, false);
+        return new PhotoViewHolder(view);
+    }
+
+    @Override
+    public void onBindViewHolder(@NonNull PhotoViewHolder holder, int position) {
+        Integer imageId = imagePaths.get(position);
+        String timestamp = imageTimestamps.get(position);
+
+        // Load image into the ImageView (e.g., with Glide or BitmapFactory)
+        holder.imageView.setImageBitmap(BitmapFactory.decodeResource(context.getResources(), imageId));
+
+        // Notify the listener of the current timestamp
+        listener.onPhotoChanged(timestamp);
+    }
+
+    @Override
+    public int getItemCount() {
+        return imagePaths.size();
+    }
+
+    static class PhotoViewHolder extends RecyclerView.ViewHolder {
+        ImageView imageView;
+
+        public PhotoViewHolder(@NonNull View itemView) {
+            super(itemView);
+            imageView = itemView.findViewById(R.id.photoImageView);
+        }
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/fragments/MessageLogFragment.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/fragments/MessageLogFragment.java
index 72d6974..94f59db 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/fragments/MessageLogFragment.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/fragments/MessageLogFragment.java
@@ -141,6 +141,15 @@ public class MessageLogFragment extends Fragment {
         
         // Observe message counts for summary header
         viewModel.getMessageCountsPerSensor().observe(getViewLifecycleOwner(), this::updateSummaryHeader);
+        
+        // Observe person name changes to update spinner labels
+        personNameManager.getAllPersonsLive().observe(getViewLifecycleOwner(), persons -> {
+            // Re-trigger spinner update with current sensors
+            List<String> currentSensors = viewModel.getAvailableSensors().getValue();
+            if (currentSensors != null) {
+                updateFilterSpinner(currentSensors);
+            }
+        });
     }
 
     private void updateFilterSpinner(List<String> sensors) {
@@ -150,7 +159,7 @@ public class MessageLogFragment extends Fragment {
         if (sensors != null) {
             for (String sensorId : sensors) {
                 // Get display name for sensor
-                String displayName = personNameManager.getDisplayName(sensorId);
+                String displayName = viewModel.getDisplayName(sensorId);
                 if (displayName.equals(sensorId)) {
                     sensorFilterList.add(sensorId);
                 } else {
@@ -177,7 +186,7 @@ public class MessageLogFragment extends Fragment {
             int count = entry.getValue();
             
             // Get display name
-            String displayName = personNameManager.getDisplayName(sensorId);
+            String displayName = viewModel.getDisplayName(sensorId);
             
             // Create chip-like view for each sensor
             TextView chip = new TextView(requireContext());
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/BtSettingsViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/BtSettingsViewModel.java
index e811c0a..c2e986e 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/BtSettingsViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/BtSettingsViewModel.java
@@ -1,172 +1,172 @@
-package com.melisa.innovamotionapp.ui.viewmodels;
-
-import static android.content.ContentValues.TAG;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-import android.content.BroadcastReceiver;
-import android.util.Log;
-
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.ViewModel;
-
-import com.melisa.innovamotionapp.bluetooth.DeviceCommunicationManager;
-import com.melisa.innovamotionapp.receivers.BluetoothStateReceiver;
-import com.melisa.innovamotionapp.receivers.DiscoveryFinishedReceiver;
-import com.melisa.innovamotionapp.receivers.NearbyDeviceDiscoveryReceiver;
-import com.melisa.innovamotionapp.utils.GlobalData;
-
-import java.util.ArrayList;
-
-public class BtSettingsViewModel extends ViewModel {
-
-    private final GlobalData globalData = GlobalData.getInstance();
-    private final BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
-    ;
-    private final MutableLiveData<BtSettingsState> uiState = new MutableLiveData<>();
-    private final MutableLiveData<ArrayList<BluetoothDevice>> nearbyDevices = new MutableLiveData<>();
-    private final MutableLiveData<Boolean> needRequestBluetoothEnable = new MutableLiveData<>();
-    private final MutableLiveData<Boolean> isBluetoothEnabled = new MutableLiveData<>();
-
-
-    private final BluetoothStateReceiver bluetoothStateReceiver = new BluetoothStateReceiver(this::onBtStateChanged);
-    private final DiscoveryFinishedReceiver discoveryFinishedReceiver = new DiscoveryFinishedReceiver(this::onDiscoveryFinished);
-    private final BroadcastReceiver nearbyDeviceDiscoveryReceiver = new NearbyDeviceDiscoveryReceiver(this::onNearbyDeviceFound);
-    private boolean isConnecting = false;
-    private DeviceCommunicationManager deviceCommunicationManager;
-
-
-    // Exposed LiveData for UI binding
-    public LiveData<BtSettingsState> getUIState() {
-        return uiState;
-    }
-
-    public LiveData<ArrayList<BluetoothDevice>> getNearbyDevices() {
-        return nearbyDevices;
-    }
-
-    public MutableLiveData<Boolean> getNeedRequestBluetoothEnable() {
-        return needRequestBluetoothEnable;
-    }
-
-
-    public BroadcastReceiver getBluetoothStateReceiver() {
-        return bluetoothStateReceiver;
-    }
-
-    public BroadcastReceiver getNearbyDeviceDiscoveryReceiver() {
-        return nearbyDeviceDiscoveryReceiver;
-    }
-
-    public BroadcastReceiver getDiscoveryFinishedReceiver() {
-        return discoveryFinishedReceiver;
-    }
-
-    public MutableLiveData<Boolean> getIsBluetoothEnabled() {
-        return isBluetoothEnabled;
-    }
-
-    public void onBtStateChanged(int state) {
-        switch (state) {
-            case BluetoothAdapter.STATE_OFF:
-                Log.d(TAG, "onReceive: STATE OFF");
-                isBluetoothEnabled.setValue(false);
-                break;
-            case BluetoothAdapter.STATE_ON:
-                Log.d(TAG, "onReceive: STATE ON");
-                isBluetoothEnabled.setValue(true);
-                break;
-            case BluetoothAdapter.STATE_TURNING_OFF:
-                Log.d(TAG, "onReceive: STATE TURNING OFF");
-                // Handle turning off
-                break;
-            case BluetoothAdapter.STATE_TURNING_ON:
-                Log.d(TAG, "onReceive: STATE TURNING ON");
-                // Handle turning on
-                break;
-        }
-    }
-
-    public void checkBluetoothState() {
-        if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) {
-            uiState.setValue(BtSettingsState.BLUETOOTH_OFF);
-        } else {
-            uiState.setValue(BtSettingsState.READY_TO_CONNECT);
-        }
-    }
-
-    public void enableBluetooth() {
-        if (mBluetoothAdapter == null) {
-            Log.d(TAG, "Does not have BT capabilities.");
-        }
-        if (mBluetoothAdapter != null && !mBluetoothAdapter.isEnabled()) {
-            uiState.setValue(BtSettingsState.ENABLING_BLUETOOTH);
-        }
-    }
-
-    @SuppressLint("MissingPermission")
-    public void startBluetoothDiscovery() {
-        if (mBluetoothAdapter != null) {
-            if (mBluetoothAdapter.isEnabled()) {
-                globalData.nearbyBtDevices.clear();
-
-                if (mBluetoothAdapter.isDiscovering()) {
-                    mBluetoothAdapter.cancelDiscovery();
-                }
-                mBluetoothAdapter.startDiscovery();
-
-                uiState.setValue(BtSettingsState.SCANNING);
-            } else {
-                enableBluetooth();
-            }
-        }
-    }
-
-
-    public void onNearbyDeviceFound(BluetoothDevice device) {
-        String lastDeviceAddress = GlobalData.getInstance().userDeviceSettingsStorage.getLatestDeviceAddress();
-        // Try to reconnect to it, if is the same address as last one
-        if (device.getAddress().equals(lastDeviceAddress)) {
-            String userName = globalData.userDeviceSettingsStorage.getLatestUser();
-            connectToDevice(device, userName);
-        } else {
-            globalData.nearbyBtDevices.add(device);
-            nearbyDevices.setValue(new ArrayList<>(globalData.nearbyBtDevices));
-        }
-    }
-
-    private void onDiscoveryFinished() {
-        // Discovery has finished, update UI text
-        if (!isConnecting) {
-            uiState.setValue(BtSettingsState.SCAN_FINISHED);
-        }
-    }
-
-    @SuppressLint("MissingPermission")
-    public void connectToDevice(BluetoothDevice device, String userName) {
-        isConnecting = true;
-        globalData.userName = userName;
-        GlobalData.getInstance().userDeviceSettingsStorage.saveLatestUser(userName);
-
-        uiState.setValue(BtSettingsState.CONNECTING);
-        // Cancel discovery because it otherwise slows down the connection.
-        this.mBluetoothAdapter.cancelDiscovery();
-
-        deviceCommunicationManager = globalData.deviceCommunicationManager;
-        deviceCommunicationManager.connectDevice(device);
-    }
-
-
-    public enum BtSettingsState {
-        BEFORE_BTN_PRESSED,
-        AFTER_BTN_PRESSED,
-        BLUETOOTH_OFF,
-        ENABLING_BLUETOOTH,
-        READY_TO_CONNECT,
-        SCANNING,
-        SCAN_FINISHED,
-        CONNECTING
-    }
-}
+package com.melisa.innovamotionapp.ui.viewmodels;
+
+import static android.content.ContentValues.TAG;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.util.Log;
+
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.ViewModel;
+
+import com.melisa.innovamotionapp.bluetooth.DeviceCommunicationManager;
+import com.melisa.innovamotionapp.receivers.BluetoothStateReceiver;
+import com.melisa.innovamotionapp.receivers.DiscoveryFinishedReceiver;
+import com.melisa.innovamotionapp.receivers.NearbyDeviceDiscoveryReceiver;
+import com.melisa.innovamotionapp.utils.GlobalData;
+
+import java.util.ArrayList;
+
+public class BtSettingsViewModel extends ViewModel {
+
+    private final GlobalData globalData = GlobalData.getInstance();
+    private final BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+    ;
+    private final MutableLiveData<BtSettingsState> uiState = new MutableLiveData<>();
+    private final MutableLiveData<ArrayList<BluetoothDevice>> nearbyDevices = new MutableLiveData<>();
+    private final MutableLiveData<Boolean> needRequestBluetoothEnable = new MutableLiveData<>();
+    private final MutableLiveData<Boolean> isBluetoothEnabled = new MutableLiveData<>();
+
+
+    private final BluetoothStateReceiver bluetoothStateReceiver = new BluetoothStateReceiver(this::onBtStateChanged);
+    private final DiscoveryFinishedReceiver discoveryFinishedReceiver = new DiscoveryFinishedReceiver(this::onDiscoveryFinished);
+    private final BroadcastReceiver nearbyDeviceDiscoveryReceiver = new NearbyDeviceDiscoveryReceiver(this::onNearbyDeviceFound);
+    private boolean isConnecting = false;
+    private DeviceCommunicationManager deviceCommunicationManager;
+
+
+    // Exposed LiveData for UI binding
+    public LiveData<BtSettingsState> getUIState() {
+        return uiState;
+    }
+
+    public LiveData<ArrayList<BluetoothDevice>> getNearbyDevices() {
+        return nearbyDevices;
+    }
+
+    public MutableLiveData<Boolean> getNeedRequestBluetoothEnable() {
+        return needRequestBluetoothEnable;
+    }
+
+
+    public BroadcastReceiver getBluetoothStateReceiver() {
+        return bluetoothStateReceiver;
+    }
+
+    public BroadcastReceiver getNearbyDeviceDiscoveryReceiver() {
+        return nearbyDeviceDiscoveryReceiver;
+    }
+
+    public BroadcastReceiver getDiscoveryFinishedReceiver() {
+        return discoveryFinishedReceiver;
+    }
+
+    public MutableLiveData<Boolean> getIsBluetoothEnabled() {
+        return isBluetoothEnabled;
+    }
+
+    public void onBtStateChanged(int state) {
+        switch (state) {
+            case BluetoothAdapter.STATE_OFF:
+                Log.d(TAG, "onReceive: STATE OFF");
+                isBluetoothEnabled.setValue(false);
+                break;
+            case BluetoothAdapter.STATE_ON:
+                Log.d(TAG, "onReceive: STATE ON");
+                isBluetoothEnabled.setValue(true);
+                break;
+            case BluetoothAdapter.STATE_TURNING_OFF:
+                Log.d(TAG, "onReceive: STATE TURNING OFF");
+                // Handle turning off
+                break;
+            case BluetoothAdapter.STATE_TURNING_ON:
+                Log.d(TAG, "onReceive: STATE TURNING ON");
+                // Handle turning on
+                break;
+        }
+    }
+
+    public void checkBluetoothState() {
+        if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) {
+            uiState.setValue(BtSettingsState.BLUETOOTH_OFF);
+        } else {
+            uiState.setValue(BtSettingsState.READY_TO_CONNECT);
+        }
+    }
+
+    public void enableBluetooth() {
+        if (mBluetoothAdapter == null) {
+            Log.d(TAG, "Does not have BT capabilities.");
+        }
+        if (mBluetoothAdapter != null && !mBluetoothAdapter.isEnabled()) {
+            uiState.setValue(BtSettingsState.ENABLING_BLUETOOTH);
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    public void startBluetoothDiscovery() {
+        if (mBluetoothAdapter != null) {
+            if (mBluetoothAdapter.isEnabled()) {
+                globalData.nearbyBtDevices.clear();
+
+                if (mBluetoothAdapter.isDiscovering()) {
+                    mBluetoothAdapter.cancelDiscovery();
+                }
+                mBluetoothAdapter.startDiscovery();
+
+                uiState.setValue(BtSettingsState.SCANNING);
+            } else {
+                enableBluetooth();
+            }
+        }
+    }
+
+
+    public void onNearbyDeviceFound(BluetoothDevice device) {
+        String lastDeviceAddress = GlobalData.getInstance().userDeviceSettingsStorage.getLatestDeviceAddress();
+        // Try to reconnect to it, if is the same address as last one
+        if (device.getAddress().equals(lastDeviceAddress)) {
+            String userName = globalData.userDeviceSettingsStorage.getLatestUser();
+            connectToDevice(device, userName);
+        } else {
+            globalData.nearbyBtDevices.add(device);
+            nearbyDevices.setValue(new ArrayList<>(globalData.nearbyBtDevices));
+        }
+    }
+
+    private void onDiscoveryFinished() {
+        // Discovery has finished, update UI text
+        if (!isConnecting) {
+            uiState.setValue(BtSettingsState.SCAN_FINISHED);
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    public void connectToDevice(BluetoothDevice device, String userName) {
+        isConnecting = true;
+        globalData.userName = userName;
+        GlobalData.getInstance().userDeviceSettingsStorage.saveLatestUser(userName);
+
+        uiState.setValue(BtSettingsState.CONNECTING);
+        // Cancel discovery because it otherwise slows down the connection.
+        this.mBluetoothAdapter.cancelDiscovery();
+
+        deviceCommunicationManager = globalData.deviceCommunicationManager;
+        deviceCommunicationManager.connectDevice(device);
+    }
+
+
+    public enum BtSettingsState {
+        BEFORE_BTN_PRESSED,
+        AFTER_BTN_PRESSED,
+        BLUETOOTH_OFF,
+        ENABLING_BLUETOOTH,
+        READY_TO_CONNECT,
+        SCANNING,
+        SCAN_FINISHED,
+        CONNECTING
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/EnergyConsumptionViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/EnergyConsumptionViewModel.java
index ff344ae..24a0823 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/EnergyConsumptionViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/EnergyConsumptionViewModel.java
@@ -1,99 +1,99 @@
-package com.melisa.innovamotionapp.ui.viewmodels;
-
-import android.app.Application;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.lifecycle.AndroidViewModel;
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.Transformations;
-
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.OwnerSource;
-
-import java.util.Collections;
-import java.util.List;
-
-/**
- * ViewModel for Energy Consumption Activity.
- * 
- * Supports two modes:
- * 1. User-based filtering: Shows data for a specific user (targetUserId)
- * 2. Sensor-based filtering: Shows data for a specific sensor (sensorId)
- * 
- * Sensor-based filtering takes precedence when sensorId is set.
- */
-public class EnergyConsumptionViewModel extends AndroidViewModel {
-    private static final String TAG = "UI/EnergyVM";
-    
-    private final ReceivedBtDataDao dao;
-    private final GlobalData global = GlobalData.getInstance();
-    private final MutableLiveData<String> targetUserId = new MutableLiveData<>();
-    private final MutableLiveData<String> sensorId = new MutableLiveData<>();
-
-    public EnergyConsumptionViewModel(@NonNull Application app) {
-        super(app);
-        dao = InnovaDatabase.getInstance(app).receivedBtDataDao();
-        // Default: keep null until Activity sets it
-        targetUserId.setValue(null);
-        sensorId.setValue(null);
-    }
-
-    public void setTargetUserId(String userId) { 
-        targetUserId.setValue(userId); 
-    }
-
-    /**
-     * Set sensor ID for sensor-specific filtering.
-     * When set, data will be filtered to this specific sensor.
-     */
-    public void setSensorId(@Nullable String sensorId) {
-        this.sensorId.setValue(sensorId);
-    }
-
-    /**
-     * Check if sensor-based filtering is active.
-     */
-    public boolean isSensorMode() {
-        String id = sensorId.getValue();
-        return id != null && !id.isEmpty();
-    }
-
-    /**
-     * Get all data for user OR sensor, depending on which mode is active.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getAllForUser() {
-        // If sensorId is set, use sensor-based filtering
-        return Transformations.switchMap(sensorId, sid -> {
-            if (sid != null && !sid.isEmpty()) {
-                Log.i(TAG, "subscribe sensorId=" + sid);
-                return dao.getAllForSensor(sid);
-            }
-            // Otherwise, use user-based filtering
-            return Transformations.switchMap(targetUserId, uid -> {
-                Log.i(TAG, "subscribe targetUser=" + uid);
-                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
-                return dao.getAllForUserLive(uid);
-            });
-        });
-    }
-
-    /**
-     * Get all data for a specific sensor.
-     * Use this when you explicitly want sensor-based data.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getAllForSensor() {
-        return Transformations.switchMap(sensorId, sid -> {
-            Log.i(TAG, "getAllForSensor sensorId=" + sid);
-            if (sid == null || sid.isEmpty()) {
-                return new MutableLiveData<>(Collections.emptyList());
-            }
-            return dao.getAllForSensor(sid);
-        });
-    }
-}
+package com.melisa.innovamotionapp.ui.viewmodels;
+
+import android.app.Application;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.Transformations;
+
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.OwnerSource;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * ViewModel for Energy Consumption Activity.
+ * 
+ * Supports two modes:
+ * 1. User-based filtering: Shows data for a specific user (targetUserId)
+ * 2. Sensor-based filtering: Shows data for a specific sensor (sensorId)
+ * 
+ * Sensor-based filtering takes precedence when sensorId is set.
+ */
+public class EnergyConsumptionViewModel extends AndroidViewModel {
+    private static final String TAG = "UI/EnergyVM";
+    
+    private final ReceivedBtDataDao dao;
+    private final GlobalData global = GlobalData.getInstance();
+    private final MutableLiveData<String> targetUserId = new MutableLiveData<>();
+    private final MutableLiveData<String> sensorId = new MutableLiveData<>();
+
+    public EnergyConsumptionViewModel(@NonNull Application app) {
+        super(app);
+        dao = InnovaDatabase.getInstance(app).receivedBtDataDao();
+        // Default: keep null until Activity sets it
+        targetUserId.setValue(null);
+        sensorId.setValue(null);
+    }
+
+    public void setTargetUserId(String userId) { 
+        targetUserId.setValue(userId); 
+    }
+
+    /**
+     * Set sensor ID for sensor-specific filtering.
+     * When set, data will be filtered to this specific sensor.
+     */
+    public void setSensorId(@Nullable String sensorId) {
+        this.sensorId.setValue(sensorId);
+    }
+
+    /**
+     * Check if sensor-based filtering is active.
+     */
+    public boolean isSensorMode() {
+        String id = sensorId.getValue();
+        return id != null && !id.isEmpty();
+    }
+
+    /**
+     * Get all data for user OR sensor, depending on which mode is active.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getAllForUser() {
+        // If sensorId is set, use sensor-based filtering
+        return Transformations.switchMap(sensorId, sid -> {
+            if (sid != null && !sid.isEmpty()) {
+                Log.i(TAG, "subscribe sensorId=" + sid);
+                return dao.getAllForSensor(sid);
+            }
+            // Otherwise, use user-based filtering
+            return Transformations.switchMap(targetUserId, uid -> {
+                Log.i(TAG, "subscribe targetUser=" + uid);
+                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
+                return dao.getAllForUserLive(uid);
+            });
+        });
+    }
+
+    /**
+     * Get all data for a specific sensor.
+     * Use this when you explicitly want sensor-based data.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getAllForSensor() {
+        return Transformations.switchMap(sensorId, sid -> {
+            Log.i(TAG, "getAllForSensor sensorId=" + sid);
+            if (sid == null || sid.isEmpty()) {
+                return new MutableLiveData<>(Collections.emptyList());
+            }
+            return dao.getAllForSensor(sid);
+        });
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/LivePostureViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/LivePostureViewModel.java
index 033903d..0ad42bf 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/LivePostureViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/LivePostureViewModel.java
@@ -51,6 +51,14 @@ public class LivePostureViewModel extends AndroidViewModel {
 
         // Available persons for dropdown
         availablePersons = personDao.getAllMonitoredPersons();
+        
+        // #region agent log
+        // H4: Log available persons count
+        availablePersons.observeForever(persons -> {
+            int count = persons != null ? persons.size() : 0;
+            android.util.Log.w("DBG_H4", "availablePersons LiveData update: personsCount=" + count);
+        });
+        // #endregion
 
         // Latest reading for selected sensor (reactive)
         latestReading = Transformations.switchMap(selectedSensorId, sensorId -> {
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/MessageLogViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/MessageLogViewModel.java
index f297d47..680c80d 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/MessageLogViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/MessageLogViewModel.java
@@ -5,11 +5,13 @@ import android.app.Application;
 import androidx.annotation.NonNull;
 import androidx.lifecycle.AndroidViewModel;
 import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MediatorLiveData;
 import androidx.lifecycle.MutableLiveData;
 import androidx.lifecycle.Transformations;
 
 import com.melisa.innovamotionapp.R;
 import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.MonitoredPerson;
 import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
 import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
 import com.melisa.innovamotionapp.ui.models.MessageLogItem;
@@ -17,6 +19,7 @@ import com.melisa.innovamotionapp.utils.Constants;
 import com.melisa.innovamotionapp.utils.PersonNameManager;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -44,6 +47,9 @@ public class MessageLogViewModel extends AndroidViewModel {
     // Filter state
     private final MutableLiveData<String> filterSensor = new MutableLiveData<>(null);
     
+    // In-memory name cache, updated reactively from LiveData to avoid main-thread DB access
+    private volatile Map<String, String> nameCache = Collections.emptyMap();
+    
     // Transformed data
     private final LiveData<List<MessageLogItem>> messages;
     private final LiveData<List<String>> availableSensors;
@@ -54,21 +60,61 @@ public class MessageLogViewModel extends AndroidViewModel {
         dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
         personNameManager = PersonNameManager.getInstance(application);
         
+        // Observe all persons to keep nameCache updated (async, off main thread)
+        LiveData<List<MonitoredPerson>> allPersons = personNameManager.getAllPersonsLive();
+        
         // Get recent messages (limit to last 500)
         LiveData<List<ReceivedBtDataEntity>> rawMessages = dao.getRecentMessages(DEFAULT_MESSAGE_LIMIT);
         
-        // Transform to UI model with person names based on filter
-        messages = Transformations.switchMap(filterSensor, sensor -> {
-            LiveData<List<ReceivedBtDataEntity>> filtered;
+        // #region agent log
+        // H5: Log ViewModel initialization and observe message count
+        rawMessages.observeForever(entities -> {
+            int count = entities != null ? entities.size() : 0;
+            android.util.Log.w("DBG_H5", "rawMessages LiveData update: messageCount=" + count);
+        });
+        // #endregion
+
+        // Use MediatorLiveData to combine rawMessages + allPersons
+        // so that transformation only runs when we have data, and uses cached names safely
+        MediatorLiveData<List<MessageLogItem>> combinedMessages = new MediatorLiveData<>();
+        
+        // Track latest data
+        final List<ReceivedBtDataEntity>[] latestEntities = new List[]{null};
+        
+        combinedMessages.addSource(allPersons, persons -> {
+            // Update name cache from persons list (this runs on main thread but no DB access)
+            Map<String, String> newCache = new HashMap<>();
+            if (persons != null) {
+                for (MonitoredPerson p : persons) {
+                    String name = p.getDisplayName();
+                    newCache.put(p.getSensorId(), (name != null && !name.isEmpty()) ? name : p.getSensorId());
+                }
+            }
+            nameCache = newCache;
+            
+            // Re-transform if we have entities
+            if (latestEntities[0] != null) {
+                combinedMessages.setValue(transformToMessageLogItems(latestEntities[0]));
+            }
+        });
+        
+        // Wrap messages transformation with filter support
+        LiveData<List<ReceivedBtDataEntity>> filteredMessages = Transformations.switchMap(filterSensor, sensor -> {
             if (sensor == null || sensor.isEmpty()) {
-                filtered = rawMessages;
+                return rawMessages;
             } else {
-                filtered = dao.getMessagesForSensor(sensor, DEFAULT_MESSAGE_LIMIT);
+                return dao.getMessagesForSensor(sensor, DEFAULT_MESSAGE_LIMIT);
             }
-            
-            return Transformations.map(filtered, this::transformToMessageLogItems);
         });
         
+        combinedMessages.addSource(filteredMessages, entities -> {
+            latestEntities[0] = entities;
+            // Only transform if we have attempted to load persons (cache may be empty but that's ok)
+            combinedMessages.setValue(transformToMessageLogItems(entities));
+        });
+        
+        messages = combinedMessages;
+        
         // Available sensors for filter dropdown
         availableSensors = dao.getDistinctSensorIds();
         
@@ -87,20 +133,24 @@ public class MessageLogViewModel extends AndroidViewModel {
 
     /**
      * Transform database entities to UI items.
+     * Uses the in-memory nameCache instead of DB lookups.
      */
     private List<MessageLogItem> transformToMessageLogItems(List<ReceivedBtDataEntity> entities) {
         List<MessageLogItem> items = new ArrayList<>();
         if (entities == null) return items;
         
         for (ReceivedBtDataEntity entity : entities) {
-            String displayName = personNameManager.getDisplayName(entity.getSensorId());
+            String sensorId = entity.getSensorId();
+            // Use cached name instead of blocking DB lookup
+            String displayName = nameCache.getOrDefault(sensorId, sensorId);
+            
             int iconRes = getPostureIcon(entity.getReceivedMsg());
             boolean isFall = isFallPosture(entity.getReceivedMsg());
             
             items.add(new MessageLogItem(
                     entity.getId(),
                     entity.getTimestamp(),
-                    entity.getSensorId(),
+                    sensorId,
                     displayName,
                     entity.getReceivedMsg(),
                     iconRes,
@@ -141,6 +191,14 @@ public class MessageLogViewModel extends AndroidViewModel {
         return hexCode.toLowerCase().equals(HEX_FALLING);
     }
 
+    /**
+     * Get display name for a sensor ID from the local cache.
+     * Safe to call from main thread.
+     */
+    public String getDisplayName(String sensorId) {
+        return nameCache.getOrDefault(sensorId, sensorId);
+    }
+
     // ========== Public API ==========
 
     /**
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModel.java
index c1eb097..6341948 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModel.java
@@ -3,29 +3,53 @@ package com.melisa.innovamotionapp.ui.viewmodels;
 import android.app.Application;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.lifecycle.AndroidViewModel;
 import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
 
 import com.melisa.innovamotionapp.data.database.MonitoredPerson;
+import com.melisa.innovamotionapp.sync.SensorAssignmentService;
 import com.melisa.innovamotionapp.utils.PersonNameManager;
 
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * ViewModel for the Person Names management UI.
  * 
  * Provides access to all monitored persons and methods to update their display names.
- * Uses PersonNameManager for data operations.
+ * Also handles supervisor assignment operations.
+ * Uses PersonNameManager for name data operations.
+ * Uses SensorAssignmentService for supervisor assignment operations.
  */
 public class PersonNamesViewModel extends AndroidViewModel {
 
     private final PersonNameManager personNameManager;
+    private final SensorAssignmentService assignmentService;
     private final LiveData<List<MonitoredPerson>> allPersons;
+    
+    // Map of sensorId -> supervisorEmail for UI binding
+    private final MutableLiveData<Map<String, String>> sensorSupervisorMap;
+
+    /**
+     * Callback interface for assignment operations.
+     */
+    public interface AssignmentResultCallback {
+        void onSuccess();
+        void onError(String error);
+    }
 
     public PersonNamesViewModel(@NonNull Application application) {
         super(application);
         personNameManager = PersonNameManager.getInstance(application);
+        assignmentService = SensorAssignmentService.getInstance(application);
         allPersons = personNameManager.getAllPersonsLive();
+        sensorSupervisorMap = new MutableLiveData<>(new HashMap<>());
+        
+        // Load initial assignment map
+        loadAssignmentMap();
     }
 
     /**
@@ -36,6 +60,14 @@ public class PersonNamesViewModel extends AndroidViewModel {
         return allPersons;
     }
 
+    /**
+     * Get the supervisor assignment map.
+     * Maps sensorId -> supervisorEmail.
+     */
+    public LiveData<Map<String, String>> getSensorSupervisorMap() {
+        return sensorSupervisorMap;
+    }
+
     /**
      * Update the display name for a sensor ID.
      * 
@@ -46,6 +78,118 @@ public class PersonNamesViewModel extends AndroidViewModel {
         personNameManager.setDisplayName(sensorId, newName);
     }
 
+    /**
+     * Assign a supervisor to a sensor.
+     * 
+     * @param sensorId The sensor ID to assign
+     * @param supervisorEmail The supervisor's email
+     * @param callback Result callback
+     */
+    public void assignSupervisor(@NonNull String sensorId, @NonNull String supervisorEmail,
+                                  @NonNull AssignmentResultCallback callback) {
+        assignmentService.assignSupervisor(sensorId, supervisorEmail, 
+                new SensorAssignmentService.AssignmentCallback() {
+            @Override
+            public void onSuccess() {
+                // Update local map
+                updateMapEntry(sensorId, supervisorEmail);
+                callback.onSuccess();
+            }
+
+            @Override
+            public void onError(String error) {
+                callback.onError(error);
+            }
+        });
+    }
+
+    /**
+     * Unassign a supervisor from a sensor.
+     * 
+     * @param sensorId The sensor ID to unassign
+     * @param callback Result callback
+     */
+    public void unassignSupervisor(@NonNull String sensorId, @NonNull AssignmentResultCallback callback) {
+        assignmentService.unassignSupervisor(sensorId, new SensorAssignmentService.AssignmentCallback() {
+            @Override
+            public void onSuccess() {
+                // Remove from local map
+                removeMapEntry(sensorId);
+                callback.onSuccess();
+            }
+
+            @Override
+            public void onError(String error) {
+                callback.onError(error);
+            }
+        });
+    }
+
+    /**
+     * Get the supervisor email for a specific sensor.
+     * 
+     * @param sensorId The sensor ID to look up
+     * @return The supervisor email, or null if not assigned
+     */
+    @Nullable
+    public String getSupervisorForSensor(@NonNull String sensorId) {
+        Map<String, String> map = sensorSupervisorMap.getValue();
+        if (map != null) {
+            return map.get(sensorId);
+        }
+        return null;
+    }
+
+    /**
+     * Refresh the assignment map from Firestore.
+     */
+    public void refreshAssignments() {
+        loadAssignmentMap();
+    }
+
+    /**
+     * Load all assignments for the current aggregator.
+     */
+    private void loadAssignmentMap() {
+        assignmentService.getAssignmentMap(new SensorAssignmentService.AssignmentMapCallback() {
+            @Override
+            public void onResult(Map<String, String> map) {
+                sensorSupervisorMap.postValue(map);
+            }
+
+            @Override
+            public void onError(String error) {
+                // Keep existing map on error
+            }
+        });
+    }
+
+    /**
+     * Update a single entry in the map.
+     */
+    private void updateMapEntry(String sensorId, String supervisorEmail) {
+        Map<String, String> currentMap = sensorSupervisorMap.getValue();
+        if (currentMap == null) {
+            currentMap = new HashMap<>();
+        } else {
+            currentMap = new HashMap<>(currentMap); // Create mutable copy
+        }
+        currentMap.put(sensorId, supervisorEmail);
+        sensorSupervisorMap.postValue(currentMap);
+    }
+
+    /**
+     * Remove a single entry from the map.
+     */
+    private void removeMapEntry(String sensorId) {
+        Map<String, String> currentMap = sensorSupervisorMap.getValue();
+        if (currentMap != null && currentMap.containsKey(sensorId)) {
+            currentMap = new HashMap<>(currentMap); // Create mutable copy
+            currentMap.remove(sensorId);
+            sensorSupervisorMap.postValue(currentMap);
+        }
+    }
+
     /**
      * Check if there are any monitored persons.
      * 
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/StatisticsViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/StatisticsViewModel.java
index 2987ba8..ffbdf70 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/StatisticsViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/StatisticsViewModel.java
@@ -1,132 +1,132 @@
-package com.melisa.innovamotionapp.ui.viewmodels;
-
-import android.app.Application;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.lifecycle.AndroidViewModel;
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.Transformations;
-
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.OwnerSource;
-
-import java.util.Collections;
-import java.util.List;
-
-/**
- * ViewModel for Statistics Activity.
- * 
- * Supports two modes:
- * 1. User-based filtering: Shows data for a specific user (targetUserId)
- * 2. Sensor-based filtering: Shows data for a specific sensor (sensorId)
- * 
- * Sensor-based filtering takes precedence when sensorId is set.
- */
-public class StatisticsViewModel extends AndroidViewModel {
-    private static final String TAG = "UI/StatsVM";
-    
-    private final ReceivedBtDataDao dao;
-    private final GlobalData global = GlobalData.getInstance();
-    private final MutableLiveData<String> targetUserId = new MutableLiveData<>();
-    private final MutableLiveData<String> sensorId = new MutableLiveData<>();
-
-    public StatisticsViewModel(@NonNull Application app) {
-        super(app);
-        dao = InnovaDatabase.getInstance(app).receivedBtDataDao();
-        // Default: keep null until Activity sets it when session is ready
-        targetUserId.setValue(null);
-        sensorId.setValue(null);
-    }
-
-    public void setTargetUserId(String userId) { 
-        targetUserId.setValue(userId); 
-    }
-
-    /**
-     * Set sensor ID for sensor-specific filtering.
-     * When set, data will be filtered to this specific sensor.
-     */
-    public void setSensorId(@Nullable String sensorId) {
-        this.sensorId.setValue(sensorId);
-    }
-
-    /**
-     * Check if sensor-based filtering is active.
-     */
-    public boolean isSensorMode() {
-        String id = sensorId.getValue();
-        return id != null && !id.isEmpty();
-    }
-
-    /**
-     * Get all data for user OR sensor, depending on which mode is active.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getAllForUser() {
-        // If sensorId is set, use sensor-based filtering
-        return Transformations.switchMap(sensorId, sid -> {
-            if (sid != null && !sid.isEmpty()) {
-                Log.i(TAG, "subscribe sensorId=" + sid);
-                return dao.getAllForSensor(sid);
-            }
-            // Otherwise, use user-based filtering
-            return Transformations.switchMap(targetUserId, uid -> {
-                Log.i(TAG, "subscribe targetUser=" + uid);
-                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
-                return dao.getAllForUserLive(uid);
-            });
-        });
-    }
-
-    /**
-     * Get range data for user OR sensor, depending on which mode is active.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getRangeForUser(long start, long end) {
-        // If sensorId is set, use sensor-based filtering
-        return Transformations.switchMap(sensorId, sid -> {
-            if (sid != null && !sid.isEmpty()) {
-                Log.i(TAG, "subscribe sensorId=" + sid + " range=[" + start + "," + end + "]");
-                return dao.getRangeForSensor(sid, start, end);
-            }
-            // Otherwise, use user-based filtering
-            return Transformations.switchMap(targetUserId, uid -> {
-                Log.i(TAG, "subscribe targetUser=" + uid + " range=[" + start + "," + end + "]");
-                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
-                return dao.getRangeForUserLive(uid, start, end);
-            });
-        });
-    }
-
-    /**
-     * Get all data for a specific sensor.
-     * Use this when you explicitly want sensor-based data.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getAllForSensor() {
-        return Transformations.switchMap(sensorId, sid -> {
-            Log.i(TAG, "getAllForSensor sensorId=" + sid);
-            if (sid == null || sid.isEmpty()) {
-                return new MutableLiveData<>(Collections.emptyList());
-            }
-            return dao.getAllForSensor(sid);
-        });
-    }
-
-    /**
-     * Get range data for a specific sensor.
-     * Use this when you explicitly want sensor-based data.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getRangeForSensor(long start, long end) {
-        return Transformations.switchMap(sensorId, sid -> {
-            Log.i(TAG, "getRangeForSensor sensorId=" + sid + " range=[" + start + "," + end + "]");
-            if (sid == null || sid.isEmpty()) {
-                return new MutableLiveData<>(Collections.emptyList());
-            }
-            return dao.getRangeForSensor(sid, start, end);
-        });
-    }
-}
+package com.melisa.innovamotionapp.ui.viewmodels;
+
+import android.app.Application;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.Transformations;
+
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.OwnerSource;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * ViewModel for Statistics Activity.
+ * 
+ * Supports two modes:
+ * 1. User-based filtering: Shows data for a specific user (targetUserId)
+ * 2. Sensor-based filtering: Shows data for a specific sensor (sensorId)
+ * 
+ * Sensor-based filtering takes precedence when sensorId is set.
+ */
+public class StatisticsViewModel extends AndroidViewModel {
+    private static final String TAG = "UI/StatsVM";
+    
+    private final ReceivedBtDataDao dao;
+    private final GlobalData global = GlobalData.getInstance();
+    private final MutableLiveData<String> targetUserId = new MutableLiveData<>();
+    private final MutableLiveData<String> sensorId = new MutableLiveData<>();
+
+    public StatisticsViewModel(@NonNull Application app) {
+        super(app);
+        dao = InnovaDatabase.getInstance(app).receivedBtDataDao();
+        // Default: keep null until Activity sets it when session is ready
+        targetUserId.setValue(null);
+        sensorId.setValue(null);
+    }
+
+    public void setTargetUserId(String userId) { 
+        targetUserId.setValue(userId); 
+    }
+
+    /**
+     * Set sensor ID for sensor-specific filtering.
+     * When set, data will be filtered to this specific sensor.
+     */
+    public void setSensorId(@Nullable String sensorId) {
+        this.sensorId.setValue(sensorId);
+    }
+
+    /**
+     * Check if sensor-based filtering is active.
+     */
+    public boolean isSensorMode() {
+        String id = sensorId.getValue();
+        return id != null && !id.isEmpty();
+    }
+
+    /**
+     * Get all data for user OR sensor, depending on which mode is active.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getAllForUser() {
+        // If sensorId is set, use sensor-based filtering
+        return Transformations.switchMap(sensorId, sid -> {
+            if (sid != null && !sid.isEmpty()) {
+                Log.i(TAG, "subscribe sensorId=" + sid);
+                return dao.getAllForSensor(sid);
+            }
+            // Otherwise, use user-based filtering
+            return Transformations.switchMap(targetUserId, uid -> {
+                Log.i(TAG, "subscribe targetUser=" + uid);
+                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
+                return dao.getAllForUserLive(uid);
+            });
+        });
+    }
+
+    /**
+     * Get range data for user OR sensor, depending on which mode is active.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getRangeForUser(long start, long end) {
+        // If sensorId is set, use sensor-based filtering
+        return Transformations.switchMap(sensorId, sid -> {
+            if (sid != null && !sid.isEmpty()) {
+                Log.i(TAG, "subscribe sensorId=" + sid + " range=[" + start + "," + end + "]");
+                return dao.getRangeForSensor(sid, start, end);
+            }
+            // Otherwise, use user-based filtering
+            return Transformations.switchMap(targetUserId, uid -> {
+                Log.i(TAG, "subscribe targetUser=" + uid + " range=[" + start + "," + end + "]");
+                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
+                return dao.getRangeForUserLive(uid, start, end);
+            });
+        });
+    }
+
+    /**
+     * Get all data for a specific sensor.
+     * Use this when you explicitly want sensor-based data.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getAllForSensor() {
+        return Transformations.switchMap(sensorId, sid -> {
+            Log.i(TAG, "getAllForSensor sensorId=" + sid);
+            if (sid == null || sid.isEmpty()) {
+                return new MutableLiveData<>(Collections.emptyList());
+            }
+            return dao.getAllForSensor(sid);
+        });
+    }
+
+    /**
+     * Get range data for a specific sensor.
+     * Use this when you explicitly want sensor-based data.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getRangeForSensor(long start, long end) {
+        return Transformations.switchMap(sensorId, sid -> {
+            Log.i(TAG, "getRangeForSensor sensorId=" + sid + " range=[" + start + "," + end + "]");
+            if (sid == null || sid.isEmpty()) {
+                return new MutableLiveData<>(Collections.emptyList());
+            }
+            return dao.getRangeForSensor(sid, start, end);
+        });
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorDashboardViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorDashboardViewModel.java
index 16c8acc..d2ec45b 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorDashboardViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorDashboardViewModel.java
@@ -5,10 +5,11 @@ import android.app.Application;
 import androidx.annotation.NonNull;
 import androidx.lifecycle.AndroidViewModel;
 import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MediatorLiveData;
 import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.Transformations;
 
 import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.MonitoredPerson;
 import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
 import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
 import com.melisa.innovamotionapp.data.posture.Posture;
@@ -19,7 +20,9 @@ import com.melisa.innovamotionapp.utils.PersonNameManager;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * ViewModel for the Supervisor Dashboard.
@@ -31,57 +34,102 @@ import java.util.List;
  * - Real-time updates as new data arrives
  * - Alerts sorted to top
  * - Alphabetical sorting by display name
+ * - Uses in-memory name cache to avoid main-thread DB access
  */
 public class SupervisorDashboardViewModel extends AndroidViewModel {
 
     private final ReceivedBtDataDao dao;
     private final PersonNameManager personNameManager;
     private final MutableLiveData<Boolean> isLoading = new MutableLiveData<>(false);
-    private final LiveData<List<PersonStatus>> personStatuses;
+    private final MediatorLiveData<List<PersonStatus>> personStatuses;
+    
+    // In-memory cache for name lookups (avoids main-thread DB access)
+    private final Map<String, String> nameCache = new HashMap<>();
+    
+    // Raw data source cache
+    private List<ReceivedBtDataEntity> latestEntities = null;
 
     public SupervisorDashboardViewModel(@NonNull Application application) {
         super(application);
 
         dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
         personNameManager = PersonNameManager.getInstance(application);
+        personStatuses = new MediatorLiveData<>();
 
         // Get latest reading for each sensor
         LiveData<List<ReceivedBtDataEntity>> latestPerSensor = dao.getLatestForEachSensor();
+        
+        // Observe person names to update the cache
+        LiveData<List<MonitoredPerson>> allPersons = personNameManager.getAllPersonsLive();
+
+        // Add source: entity data
+        personStatuses.addSource(latestPerSensor, entities -> {
+            latestEntities = entities;
+            transformToPersonStatuses();
+        });
 
-        // Transform to PersonStatus with display names
-        personStatuses = Transformations.map(latestPerSensor, entities -> {
-            if (entities == null) {
-                return Collections.emptyList();
-            }
-            
-            List<PersonStatus> statuses = new ArrayList<>();
-            for (ReceivedBtDataEntity entity : entities) {
-                String sensorId = entity.getSensorId();
-                if (sensorId == null || sensorId.isEmpty()) continue;
-
-                String displayName = personNameManager.getDisplayName(sensorId);
-                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
-                boolean isAlert = posture instanceof FallingPosture;
-
-                statuses.add(new PersonStatus(
-                        sensorId,
-                        displayName,
-                        posture,
-                        entity.getTimestamp(),
-                        isAlert
-                ));
+        // Add source: person names (update cache and re-transform)
+        personStatuses.addSource(allPersons, persons -> {
+            updateNameCache(persons);
+            transformToPersonStatuses();
+        });
+    }
+
+    /**
+     * Update the in-memory name cache from the person list.
+     */
+    private void updateNameCache(List<MonitoredPerson> persons) {
+        nameCache.clear();
+        if (persons != null) {
+            for (MonitoredPerson person : persons) {
+                nameCache.put(person.getSensorId(), person.getDisplayName());
             }
+        }
+    }
 
-            // Sort: alerts first, then by name alphabetically
-            Collections.sort(statuses, (a, b) -> {
-                if (a.isAlert() != b.isAlert()) {
-                    return a.isAlert() ? -1 : 1;
-                }
-                return a.getDisplayName().compareToIgnoreCase(b.getDisplayName());
-            });
+    /**
+     * Get display name from cache, falling back to sensorId if not found.
+     */
+    private String getDisplayNameFromCache(String sensorId) {
+        return nameCache.getOrDefault(sensorId, sensorId);
+    }
 
-            return statuses;
+    /**
+     * Transform raw entities into PersonStatus list using cached names.
+     */
+    private void transformToPersonStatuses() {
+        if (latestEntities == null) {
+            personStatuses.setValue(Collections.emptyList());
+            return;
+        }
+        
+        List<PersonStatus> statuses = new ArrayList<>();
+        for (ReceivedBtDataEntity entity : latestEntities) {
+            String sensorId = entity.getSensorId();
+            if (sensorId == null || sensorId.isEmpty()) continue;
+
+            String displayName = getDisplayNameFromCache(sensorId);
+            Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
+            boolean isAlert = posture instanceof FallingPosture;
+
+            statuses.add(new PersonStatus(
+                    sensorId,
+                    displayName,
+                    posture,
+                    entity.getTimestamp(),
+                    isAlert
+            ));
+        }
+
+        // Sort: alerts first, then by name alphabetically
+        Collections.sort(statuses, (a, b) -> {
+            if (a.isAlert() != b.isAlert()) {
+                return a.isAlert() ? -1 : 1;
+            }
+            return a.getDisplayName().compareToIgnoreCase(b.getDisplayName());
         });
+
+        personStatuses.setValue(statuses);
     }
 
     /**
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorFeedViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorFeedViewModel.java
index ae7dfc3..aa2d90b 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorFeedViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorFeedViewModel.java
@@ -1,107 +1,107 @@
-package com.melisa.innovamotionapp.ui.viewmodels;
-
-import android.app.Application;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.lifecycle.AndroidViewModel;
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.Transformations;
-
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.data.posture.Posture;
-import com.melisa.innovamotionapp.data.posture.PostureFactory;
-import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
-import com.melisa.innovamotionapp.utils.GlobalData;
-
-import java.util.List;
-
-/**
- * ViewModel for supervisor feed functionality.
- * Converts the latest database row to Posture and pushes it into GlobalData
- * so that BtConnectedActivity can observe it without changes.
- */
-public class SupervisorFeedViewModel extends AndroidViewModel {
-    private final ReceivedBtDataDao dao;
-    private final GlobalData global = GlobalData.getInstance();
-
-    public SupervisorFeedViewModel(@NonNull Application application) {
-        super(application);
-        dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
-    }
-
-    /**
-     * Live posture derived from the latest DB row for supervised users.
-     * Also updates GlobalData so BtConnectedActivity stays unchanged.
-     * 
-     * @return LiveData<Posture> that emits the latest posture from Room database
-     */
-    public LiveData<Posture> getLatestPosture() {
-        // Get supervised sensor IDs from GlobalData
-        List<String> supervisedSensorIds = global.supervisedSensorIds;
-        
-        if (supervisedSensorIds == null || supervisedSensorIds.isEmpty()) {
-            // Fallback to all data if no supervised sensors configured
-            Log.i("UI/Stats", "Subscribing for owner=all (no supervised sensors configured)");
-            LiveData<ReceivedBtDataEntity> latest = dao.getLatestMessage();
-            return Transformations.map(latest, entity -> {
-                if (entity == null) {
-                    return new UnknownPosture();
-                }
-                
-                // Convert the latest database entity to a Posture
-                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
-                
-                // Update GlobalData so existing observers (like BtConnectedActivity) 
-                // continue to work without any changes
-                global.setReceivedPosture(posture);
-                
-                return posture;
-            });
-        }
-        
-        // Filter by supervised sensor IDs
-        Log.i("UI/Stats", "Subscribing for owner=" + supervisedSensorIds);
-        LiveData<ReceivedBtDataEntity> latest = dao.getLatestForOwners(supervisedSensorIds);
-        return Transformations.map(latest, entity -> {
-            if (entity == null) {
-                return new UnknownPosture();
-            }
-            
-            // Convert the latest database entity to a Posture
-            Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
-            
-            // Update GlobalData so existing observers (like BtConnectedActivity) 
-            // continue to work without any changes
-            global.setReceivedPosture(posture);
-            
-            return posture;
-        });
-    }
-    
-    /**
-     * Get the latest posture for a specific device (extended feature).
-     * Useful when supervisors want to monitor a specific supervised user.
-     * 
-     * @param deviceAddress The device address to filter by
-     * @return LiveData<Posture> that emits the latest posture from the specified device
-     */
-    public LiveData<Posture> getLatestPostureForDevice(String deviceAddress) {
-        LiveData<ReceivedBtDataEntity> latestForDevice = dao.getLatestForDevice(deviceAddress);
-        return Transformations.map(latestForDevice, entity -> {
-            if (entity == null) {
-                return new UnknownPosture();
-            }
-            
-            // Convert the device-specific database entity to a Posture
-            Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
-            
-            // Update GlobalData so existing observers continue to work
-            global.setReceivedPosture(posture);
-            
-            return posture;
-        });
-    }
-}
+package com.melisa.innovamotionapp.ui.viewmodels;
+
+import android.app.Application;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.Transformations;
+
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.data.posture.Posture;
+import com.melisa.innovamotionapp.data.posture.PostureFactory;
+import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
+import com.melisa.innovamotionapp.utils.GlobalData;
+
+import java.util.List;
+
+/**
+ * ViewModel for supervisor feed functionality.
+ * Converts the latest database row to Posture and pushes it into GlobalData
+ * so that BtConnectedActivity can observe it without changes.
+ */
+public class SupervisorFeedViewModel extends AndroidViewModel {
+    private final ReceivedBtDataDao dao;
+    private final GlobalData global = GlobalData.getInstance();
+
+    public SupervisorFeedViewModel(@NonNull Application application) {
+        super(application);
+        dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
+    }
+
+    /**
+     * Live posture derived from the latest DB row for supervised users.
+     * Also updates GlobalData so BtConnectedActivity stays unchanged.
+     * 
+     * @return LiveData<Posture> that emits the latest posture from Room database
+     */
+    public LiveData<Posture> getLatestPosture() {
+        // Get supervised sensor IDs from GlobalData
+        List<String> supervisedSensorIds = global.supervisedSensorIds;
+        
+        if (supervisedSensorIds == null || supervisedSensorIds.isEmpty()) {
+            // Fallback to all data if no supervised sensors configured
+            Log.i("UI/Stats", "Subscribing for owner=all (no supervised sensors configured)");
+            LiveData<ReceivedBtDataEntity> latest = dao.getLatestMessage();
+            return Transformations.map(latest, entity -> {
+                if (entity == null) {
+                    return new UnknownPosture();
+                }
+                
+                // Convert the latest database entity to a Posture
+                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
+                
+                // Update GlobalData so existing observers (like BtConnectedActivity) 
+                // continue to work without any changes
+                global.setReceivedPosture(posture);
+                
+                return posture;
+            });
+        }
+        
+        // Filter by supervised sensor IDs
+        Log.i("UI/Stats", "Subscribing for owner=" + supervisedSensorIds);
+        LiveData<ReceivedBtDataEntity> latest = dao.getLatestForOwners(supervisedSensorIds);
+        return Transformations.map(latest, entity -> {
+            if (entity == null) {
+                return new UnknownPosture();
+            }
+            
+            // Convert the latest database entity to a Posture
+            Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
+            
+            // Update GlobalData so existing observers (like BtConnectedActivity) 
+            // continue to work without any changes
+            global.setReceivedPosture(posture);
+            
+            return posture;
+        });
+    }
+    
+    /**
+     * Get the latest posture for a specific device (extended feature).
+     * Useful when supervisors want to monitor a specific supervised user.
+     * 
+     * @param deviceAddress The device address to filter by
+     * @return LiveData<Posture> that emits the latest posture from the specified device
+     */
+    public LiveData<Posture> getLatestPostureForDevice(String deviceAddress) {
+        LiveData<ReceivedBtDataEntity> latestForDevice = dao.getLatestForDevice(deviceAddress);
+        return Transformations.map(latestForDevice, entity -> {
+            if (entity == null) {
+                return new UnknownPosture();
+            }
+            
+            // Convert the device-specific database entity to a Posture
+            Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
+            
+            // Update GlobalData so existing observers continue to work
+            global.setReceivedPosture(posture);
+            
+            return posture;
+        });
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/TimeLapseViewModel.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/TimeLapseViewModel.java
index 62ed4bd..241a8ef 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/TimeLapseViewModel.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/TimeLapseViewModel.java
@@ -1,100 +1,100 @@
-package com.melisa.innovamotionapp.ui.viewmodels;
-
-import android.app.Application;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.lifecycle.AndroidViewModel;
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.Transformations;
-
-import com.melisa.innovamotionapp.data.database.InnovaDatabase;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
-import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
-import com.melisa.innovamotionapp.utils.GlobalData;
-import com.melisa.innovamotionapp.utils.OwnerSource;
-
-import java.util.Collections;
-import java.util.List;
-
-/**
- * ViewModel for TimeLapse Activity.
- * 
- * Supports two modes:
- * 1. User-based filtering: Shows data for a specific user (targetUserId)
- * 2. Sensor-based filtering: Shows data for a specific sensor (sensorId)
- * 
- * Sensor-based filtering takes precedence when sensorId is set.
- */
-public class TimeLapseViewModel extends AndroidViewModel {
-    private static final String TAG = "UI/TimeLapseVM";
-    
-    private final ReceivedBtDataDao dao;
-    private final GlobalData global = GlobalData.getInstance();
-    private final MutableLiveData<String> targetUserId = new MutableLiveData<>();
-    private final MutableLiveData<String> sensorId = new MutableLiveData<>();
-    private final MutableLiveData<List<ReceivedBtDataEntity>> latestDevicePostureData = new MutableLiveData<>();
-
-    public TimeLapseViewModel(@NonNull Application app) {
-        super(app);
-        dao = InnovaDatabase.getInstance(app).receivedBtDataDao();
-        // Default: keep null until Activity sets it
-        targetUserId.setValue(null);
-        sensorId.setValue(null);
-    }
-
-    public void setTargetUserId(String userId) { 
-        targetUserId.setValue(userId); 
-    }
-
-    /**
-     * Set sensor ID for sensor-specific filtering.
-     * When set, data will be filtered to this specific sensor.
-     */
-    public void setSensorId(@Nullable String sensorId) {
-        this.sensorId.setValue(sensorId);
-    }
-
-    /**
-     * Check if sensor-based filtering is active.
-     */
-    public boolean isSensorMode() {
-        String id = sensorId.getValue();
-        return id != null && !id.isEmpty();
-    }
-
-    /**
-     * Get all data for user OR sensor, depending on which mode is active.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getAllForUser() {
-        // If sensorId is set, use sensor-based filtering
-        return Transformations.switchMap(sensorId, sid -> {
-            if (sid != null && !sid.isEmpty()) {
-                Log.i(TAG, "subscribe sensorId=" + sid);
-                return dao.getAllForSensor(sid);
-            }
-            // Otherwise, use user-based filtering
-            return Transformations.switchMap(targetUserId, uid -> {
-                Log.i(TAG, "subscribe targetUser=" + uid);
-                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
-                return dao.getAllForUserLive(uid);
-            });
-        });
-    }
-
-    /**
-     * Get all data for a specific sensor.
-     * Use this when you explicitly want sensor-based data.
-     */
-    public LiveData<List<ReceivedBtDataEntity>> getAllForSensor() {
-        return Transformations.switchMap(sensorId, sid -> {
-            Log.i(TAG, "getAllForSensor sensorId=" + sid);
-            if (sid == null || sid.isEmpty()) {
-                return new MutableLiveData<>(Collections.emptyList());
-            }
-            return dao.getAllForSensor(sid);
-        });
-    }
-}
+package com.melisa.innovamotionapp.ui.viewmodels;
+
+import android.app.Application;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.lifecycle.AndroidViewModel;
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+import androidx.lifecycle.Transformations;
+
+import com.melisa.innovamotionapp.data.database.InnovaDatabase;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataDao;
+import com.melisa.innovamotionapp.data.database.ReceivedBtDataEntity;
+import com.melisa.innovamotionapp.utils.GlobalData;
+import com.melisa.innovamotionapp.utils.OwnerSource;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * ViewModel for TimeLapse Activity.
+ * 
+ * Supports two modes:
+ * 1. User-based filtering: Shows data for a specific user (targetUserId)
+ * 2. Sensor-based filtering: Shows data for a specific sensor (sensorId)
+ * 
+ * Sensor-based filtering takes precedence when sensorId is set.
+ */
+public class TimeLapseViewModel extends AndroidViewModel {
+    private static final String TAG = "UI/TimeLapseVM";
+    
+    private final ReceivedBtDataDao dao;
+    private final GlobalData global = GlobalData.getInstance();
+    private final MutableLiveData<String> targetUserId = new MutableLiveData<>();
+    private final MutableLiveData<String> sensorId = new MutableLiveData<>();
+    private final MutableLiveData<List<ReceivedBtDataEntity>> latestDevicePostureData = new MutableLiveData<>();
+
+    public TimeLapseViewModel(@NonNull Application app) {
+        super(app);
+        dao = InnovaDatabase.getInstance(app).receivedBtDataDao();
+        // Default: keep null until Activity sets it
+        targetUserId.setValue(null);
+        sensorId.setValue(null);
+    }
+
+    public void setTargetUserId(String userId) { 
+        targetUserId.setValue(userId); 
+    }
+
+    /**
+     * Set sensor ID for sensor-specific filtering.
+     * When set, data will be filtered to this specific sensor.
+     */
+    public void setSensorId(@Nullable String sensorId) {
+        this.sensorId.setValue(sensorId);
+    }
+
+    /**
+     * Check if sensor-based filtering is active.
+     */
+    public boolean isSensorMode() {
+        String id = sensorId.getValue();
+        return id != null && !id.isEmpty();
+    }
+
+    /**
+     * Get all data for user OR sensor, depending on which mode is active.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getAllForUser() {
+        // If sensorId is set, use sensor-based filtering
+        return Transformations.switchMap(sensorId, sid -> {
+            if (sid != null && !sid.isEmpty()) {
+                Log.i(TAG, "subscribe sensorId=" + sid);
+                return dao.getAllForSensor(sid);
+            }
+            // Otherwise, use user-based filtering
+            return Transformations.switchMap(targetUserId, uid -> {
+                Log.i(TAG, "subscribe targetUser=" + uid);
+                if (uid == null) return new MutableLiveData<>(Collections.emptyList());
+                return dao.getAllForUserLive(uid);
+            });
+        });
+    }
+
+    /**
+     * Get all data for a specific sensor.
+     * Use this when you explicitly want sensor-based data.
+     */
+    public LiveData<List<ReceivedBtDataEntity>> getAllForSensor() {
+        return Transformations.switchMap(sensorId, sid -> {
+            Log.i(TAG, "getAllForSensor sensorId=" + sid);
+            if (sid == null || sid.isEmpty()) {
+                return new MutableLiveData<>(Collections.emptyList());
+            }
+            return dao.getAllForSensor(sid);
+        });
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/uistuff/OnDeviceClickListener.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/uistuff/OnDeviceClickListener.java
index 32566f6..fd8b25e 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/uistuff/OnDeviceClickListener.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/uistuff/OnDeviceClickListener.java
@@ -1,7 +1,7 @@
-package com.melisa.innovamotionapp.uistuff;
-
-import android.bluetooth.BluetoothDevice;
-
-public interface OnDeviceClickListener {
-    void onDeviceClick(BluetoothDevice device);
-}
+package com.melisa.innovamotionapp.uistuff;
+
+import android.bluetooth.BluetoothDevice;
+
+public interface OnDeviceClickListener {
+    void onDeviceClick(BluetoothDevice device);
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/AlertNotifications.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/AlertNotifications.java
index 305430c..f707355 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/AlertNotifications.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/AlertNotifications.java
@@ -1,67 +1,67 @@
-package com.melisa.innovamotionapp.utils;
-
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.TaskStackBuilder;
-import android.content.Context;
-import android.content.Intent;
-
-import androidx.annotation.NonNull;
-import androidx.core.app.NotificationCompat;
-
-import com.melisa.innovamotionapp.R;
-import com.melisa.innovamotionapp.activities.MainActivity;
-
-/**
- * Utility class for creating and showing alert notifications.
- */
-public final class AlertNotifications {
-    private AlertNotifications() {}
-
-    /**
-     * Show a fall detection alert notification.
-     * 
-     * The notification includes the person's name in the title for easy identification
-     * in multi-user monitoring scenarios.
-     * 
-     * @param ctx         Application context
-     * @param personName  The display name of the person who fell (e.g., "Ion Popescu" or sensor ID)
-     * @param msg         Optional message body (uses default if null)
-     */
-    public static void notifyFall(@NonNull Context ctx, @NonNull String personName, String msg) {
-        NotificationManager nm = (NotificationManager) ctx.getSystemService(Context.NOTIFICATION_SERVICE);
-
-        Intent openIntent = new Intent(ctx, MainActivity.class)
-                .setAction(NotificationConfig.ACTION_VIEW_FALL)
-                .putExtra("from_notification", true)
-                .putExtra("fall_person_name", personName)
-                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-
-        PendingIntent contentPI = TaskStackBuilder.create(ctx)
-                .addNextIntentWithParentStack(openIntent)
-                .getPendingIntent(
-                        NotificationConfig.RC_OPEN_FROM_FALL,
-                        android.os.Build.VERSION.SDK_INT >= 23
-                                ? PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
-                                : PendingIntent.FLAG_UPDATE_CURRENT
-                );
-
-        // Title includes person name for multi-user monitoring
-        String title = ctx.getString(R.string.notif_fall_title, personName);
-        String body = msg != null ? msg : ctx.getString(R.string.notif_fall_text_generic);
-
-        NotificationCompat.Builder b = new NotificationCompat.Builder(ctx, NotificationConfig.CHANNEL_FALL_ALERTS)
-                .setSmallIcon(R.drawable.ic_launcher_foreground)
-                .setContentTitle(title)
-                .setContentText(body)
-                .setStyle(new NotificationCompat.BigTextStyle().bigText(body))
-                .setPriority(NotificationCompat.PRIORITY_HIGH)
-                .setCategory(NotificationCompat.CATEGORY_ALARM)
-                .setAutoCancel(true)
-                .setContentIntent(contentPI);
-
-        // Use unique notification ID per person to avoid overwriting
-        int notificationId = NotificationConfig.NOTIF_ID_FALL_BASE + personName.hashCode();
-        nm.notify(notificationId, b.build());
-    }
+package com.melisa.innovamotionapp.utils;
+
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.TaskStackBuilder;
+import android.content.Context;
+import android.content.Intent;
+
+import androidx.annotation.NonNull;
+import androidx.core.app.NotificationCompat;
+
+import com.melisa.innovamotionapp.R;
+import com.melisa.innovamotionapp.activities.MainActivity;
+
+/**
+ * Utility class for creating and showing alert notifications.
+ */
+public final class AlertNotifications {
+    private AlertNotifications() {}
+
+    /**
+     * Show a fall detection alert notification.
+     * 
+     * The notification includes the person's name in the title for easy identification
+     * in multi-user monitoring scenarios.
+     * 
+     * @param ctx         Application context
+     * @param personName  The display name of the person who fell (e.g., "Ion Popescu" or sensor ID)
+     * @param msg         Optional message body (uses default if null)
+     */
+    public static void notifyFall(@NonNull Context ctx, @NonNull String personName, String msg) {
+        NotificationManager nm = (NotificationManager) ctx.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        Intent openIntent = new Intent(ctx, MainActivity.class)
+                .setAction(NotificationConfig.ACTION_VIEW_FALL)
+                .putExtra("from_notification", true)
+                .putExtra("fall_person_name", personName)
+                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+
+        PendingIntent contentPI = TaskStackBuilder.create(ctx)
+                .addNextIntentWithParentStack(openIntent)
+                .getPendingIntent(
+                        NotificationConfig.RC_OPEN_FROM_FALL,
+                        android.os.Build.VERSION.SDK_INT >= 23
+                                ? PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE
+                                : PendingIntent.FLAG_UPDATE_CURRENT
+                );
+
+        // Title includes person name for multi-user monitoring
+        String title = ctx.getString(R.string.notif_fall_title, personName);
+        String body = msg != null ? msg : ctx.getString(R.string.notif_fall_text_generic);
+
+        NotificationCompat.Builder b = new NotificationCompat.Builder(ctx, NotificationConfig.CHANNEL_FALL_ALERTS)
+                .setSmallIcon(R.drawable.ic_launcher_foreground)
+                .setContentTitle(title)
+                .setContentText(body)
+                .setStyle(new NotificationCompat.BigTextStyle().bigText(body))
+                .setPriority(NotificationCompat.PRIORITY_HIGH)
+                .setCategory(NotificationCompat.CATEGORY_ALARM)
+                .setAutoCancel(true)
+                .setContentIntent(contentPI);
+
+        // Use unique notification ID per person to avoid overwriting
+        int notificationId = NotificationConfig.NOTIF_ID_FALL_BASE + personName.hashCode();
+        nm.notify(notificationId, b.build());
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Constants.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Constants.java
index ec23d94..d910928 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Constants.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Constants.java
@@ -55,6 +55,9 @@ public final class Constants {
     /** Collection name for person names in Firestore */
     public static final String FIRESTORE_COLLECTION_PERSON_NAMES = "person_names";
     
+    /** Collection name for sensor-supervisor assignments in Firestore */
+    public static final String FIRESTORE_COLLECTION_SENSOR_ASSIGNMENTS = "sensor_assignments";
+    
     // ========== UI CONFIGURATION ==========
     
     /** Maximum messages to display in the message log */
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/GlobalData.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/GlobalData.java
index 274ab3d..2780eb6 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/GlobalData.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/GlobalData.java
@@ -1,99 +1,99 @@
-package com.melisa.innovamotionapp.utils;
-
-import android.app.Application;
-import android.bluetooth.BluetoothDevice;
-
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-
-import com.melisa.innovamotionapp.bluetooth.DeviceCommunicationManager;
-import com.melisa.innovamotionapp.data.posture.Posture;
-import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
-import com.melisa.innovamotionapp.sync.FirestoreSyncService;
-import com.melisa.innovamotionapp.sync.SessionGate;
-import com.melisa.innovamotionapp.sync.UserSession;
-
-import java.util.LinkedHashSet;
-
-public class GlobalData extends Application {
-    private static GlobalData instance;
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        instance = this;
-        userDeviceSettingsStorage = new UserDeviceSettingsStorage(this);
-        
-        // Seed a safe default so observers never see null
-        receivedPosture.setValue(new UnknownPosture());
-
-        // Single source of truth: init all channels here (both BT + Fall)
-        NotificationConfig.initAllChannels(this);
-    }
-    
-    public static GlobalData getInstance() {
-        return instance;
-    }
-
-    public final DeviceCommunicationManager deviceCommunicationManager = new DeviceCommunicationManager(this);
-
-    public LinkedHashSet<BluetoothDevice> nearbyBtDevices = new LinkedHashSet<>();
-
-    public UserDeviceSettingsStorage userDeviceSettingsStorage;
-    private final MutableLiveData<Posture> receivedPosture = new MutableLiveData<>();
-    private final MutableLiveData<Boolean> isConnectedDevice = new MutableLiveData<>();
-    public String currentUserRole = null; // "aggregator" or "supervisor"
-    public String currentUserUid = null;
-    public java.util.List<String> supervisedSensorIds = new java.util.ArrayList<>();
-
-    public MutableLiveData<Boolean> getIsConnectedDevice() {
-        return isConnectedDevice;
-    }
-    public LiveData<Posture> getReceivedPosture() {
-        return receivedPosture;
-    }
-
-    public void setReceivedPosture(Posture receivedPosture) {
-        this.receivedPosture.postValue(receivedPosture);
-    }
-    public void setIsConnectedDevice(boolean connectionEstablished) {
-        isConnectedDevice.postValue(connectionEstablished);
-    }
-    
-    /**
-     * Set current user UID
-     */
-    public void setCurrentUserUid(String uid) {
-        this.currentUserUid = uid;
-    }
-    
-    /**
-     * Set current user role
-     */
-    public void setCurrentUserRole(String role) {
-        this.currentUserRole = role;
-    }
-    
-    /**
-     * Set supervised sensor IDs (for supervisor users)
-     */
-    public void setSupervisedSensorIds(java.util.List<String> sensorIds) {
-        this.supervisedSensorIds = sensorIds != null ? new java.util.ArrayList<>(sensorIds) : new java.util.ArrayList<>();
-    }
-    
-    /**
-     * Reset session data (called on sign-out)
-     */
-    public void resetSessionData() {
-        android.util.Log.d("GlobalData", "Resetting session data");
-        currentUserUid = null;
-        currentUserRole = null;
-        supervisedSensorIds.clear();
-        
-        // Reset LiveData to neutral state
-        receivedPosture.postValue(null);
-        isConnectedDevice.postValue(false);
-    }
-    
-    public String userName = "Popescu Mihaita";
-}
+package com.melisa.innovamotionapp.utils;
+
+import android.app.Application;
+import android.bluetooth.BluetoothDevice;
+
+import androidx.lifecycle.LiveData;
+import androidx.lifecycle.MutableLiveData;
+
+import com.melisa.innovamotionapp.bluetooth.DeviceCommunicationManager;
+import com.melisa.innovamotionapp.data.posture.Posture;
+import com.melisa.innovamotionapp.data.posture.types.UnknownPosture;
+import com.melisa.innovamotionapp.sync.FirestoreSyncService;
+import com.melisa.innovamotionapp.sync.SessionGate;
+import com.melisa.innovamotionapp.sync.UserSession;
+
+import java.util.LinkedHashSet;
+
+public class GlobalData extends Application {
+    private static GlobalData instance;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        instance = this;
+        userDeviceSettingsStorage = new UserDeviceSettingsStorage(this);
+        
+        // Seed a safe default so observers never see null
+        receivedPosture.setValue(new UnknownPosture());
+
+        // Single source of truth: init all channels here (both BT + Fall)
+        NotificationConfig.initAllChannels(this);
+    }
+    
+    public static GlobalData getInstance() {
+        return instance;
+    }
+
+    public final DeviceCommunicationManager deviceCommunicationManager = new DeviceCommunicationManager(this);
+
+    public LinkedHashSet<BluetoothDevice> nearbyBtDevices = new LinkedHashSet<>();
+
+    public UserDeviceSettingsStorage userDeviceSettingsStorage;
+    private final MutableLiveData<Posture> receivedPosture = new MutableLiveData<>();
+    private final MutableLiveData<Boolean> isConnectedDevice = new MutableLiveData<>();
+    public String currentUserRole = null; // "aggregator" or "supervisor"
+    public String currentUserUid = null;
+    public java.util.List<String> supervisedSensorIds = new java.util.ArrayList<>();
+
+    public MutableLiveData<Boolean> getIsConnectedDevice() {
+        return isConnectedDevice;
+    }
+    public LiveData<Posture> getReceivedPosture() {
+        return receivedPosture;
+    }
+
+    public void setReceivedPosture(Posture receivedPosture) {
+        this.receivedPosture.postValue(receivedPosture);
+    }
+    public void setIsConnectedDevice(boolean connectionEstablished) {
+        isConnectedDevice.postValue(connectionEstablished);
+    }
+    
+    /**
+     * Set current user UID
+     */
+    public void setCurrentUserUid(String uid) {
+        this.currentUserUid = uid;
+    }
+    
+    /**
+     * Set current user role
+     */
+    public void setCurrentUserRole(String role) {
+        this.currentUserRole = role;
+    }
+    
+    /**
+     * Set supervised sensor IDs (for supervisor users)
+     */
+    public void setSupervisedSensorIds(java.util.List<String> sensorIds) {
+        this.supervisedSensorIds = sensorIds != null ? new java.util.ArrayList<>(sensorIds) : new java.util.ArrayList<>();
+    }
+    
+    /**
+     * Reset session data (called on sign-out)
+     */
+    public void resetSessionData() {
+        android.util.Log.d("GlobalData", "Resetting session data");
+        currentUserUid = null;
+        currentUserRole = null;
+        supervisedSensorIds.clear();
+        
+        // Reset LiveData to neutral state
+        receivedPosture.postValue(null);
+        isConnectedDevice.postValue(false);
+    }
+    
+    public String userName = "Popescu Mihaita";
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Logger.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Logger.java
index 168bcda..1ca97d0 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Logger.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/Logger.java
@@ -1,178 +1,178 @@
-package com.melisa.innovamotionapp.utils;
-
-import android.util.Log;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-/**
- * Centralized logging utility for InnovaMotionApp.
- * Provides consistent logging across the application with different log levels,
- * automatic tag generation, and production-safe logging.
- * 
- * Usage:
- * Logger.d("MainActivity", "User logged in successfully");
- * Logger.e("BluetoothService", "Connection failed", exception);
- * Logger.i("StatisticsActivity", "Chart data updated");
- */
-public class Logger {
-    
-    private static final String APP_TAG = "InnovaMotion";
-    private static final boolean ENABLE_DEBUG_LOGS = true; // Set to false in production
-    private static final boolean ENABLE_VERBOSE_LOGS = false; // Usually false in production
-    
-    /**
-     * Debug log - for detailed debugging information
-     * @param tag The tag to identify the source (usually class name)
-     * @param message The message to log
-     */
-    public static void d(@NonNull String tag, @NonNull String message) {
-        if (ENABLE_DEBUG_LOGS) {
-            Log.d(formatTag(tag), message);
-        }
-    }
-    
-    /**
-     * Debug log with exception
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     * @param throwable The exception to log
-     */
-    public static void d(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
-        if (ENABLE_DEBUG_LOGS) {
-            Log.d(formatTag(tag), message, throwable);
-        }
-    }
-    
-    /**
-     * Info log - for general information
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     */
-    public static void i(@NonNull String tag, @NonNull String message) {
-        Log.i(formatTag(tag), message);
-    }
-    
-    /**
-     * Info log with exception
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     * @param throwable The exception to log
-     */
-    public static void i(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
-        Log.i(formatTag(tag), message, throwable);
-    }
-    
-    /**
-     * Warning log - for potential issues
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     */
-    public static void w(@NonNull String tag, @NonNull String message) {
-        Log.w(formatTag(tag), message);
-    }
-    
-    /**
-     * Warning log with exception
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     * @param throwable The exception to log
-     */
-    public static void w(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
-        Log.w(formatTag(tag), message, throwable);
-    }
-    
-    /**
-     * Error log - for errors and exceptions
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     */
-    public static void e(@NonNull String tag, @NonNull String message) {
-        Log.e(formatTag(tag), message);
-    }
-    
-    /**
-     * Error log with exception
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     * @param throwable The exception to log
-     */
-    public static void e(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
-        Log.e(formatTag(tag), message, throwable);
-    }
-    
-    /**
-     * Verbose log - for very detailed debugging (usually disabled in production)
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     */
-    public static void v(@NonNull String tag, @NonNull String message) {
-        if (ENABLE_VERBOSE_LOGS) {
-            Log.v(formatTag(tag), message);
-        }
-    }
-    
-    /**
-     * Verbose log with exception
-     * @param tag The tag to identify the source
-     * @param message The message to log
-     * @param throwable The exception to log
-     */
-    public static void v(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
-        if (ENABLE_VERBOSE_LOGS) {
-            Log.v(formatTag(tag), message, throwable);
-        }
-    }
-    
-    /**
-     * Logs Bluetooth-specific events with consistent formatting
-     * @param tag The source tag
-     * @param deviceAddress The Bluetooth device address
-     * @param event The event description
-     */
-    public static void bluetooth(@NonNull String tag, @NonNull String deviceAddress, @NonNull String event) {
-        i(tag, String.format("BT[%s]: %s", deviceAddress, event));
-    }
-    
-    /**
-     * Logs user interaction events
-     * @param tag The source tag
-     * @param action The user action performed
-     */
-    public static void userAction(@NonNull String tag, @NonNull String action) {
-        i(tag, String.format("USER_ACTION: %s", action));
-    }
-    
-    /**
-     * Logs performance-related information
-     * @param tag The source tag
-     * @param operation The operation being measured
-     * @param durationMs The duration in milliseconds
-     */
-    public static void performance(@NonNull String tag, @NonNull String operation, long durationMs) {
-        d(tag, String.format("PERF: %s took %dms", operation, durationMs));
-    }
-    
-    /**
-     * Formats the tag with app prefix for easier filtering in logs
-     * @param tag The original tag
-     * @return Formatted tag with app prefix
-     */
-    private static String formatTag(@NonNull String tag) {
-        return APP_TAG + "_" + tag;
-    }
-    
-    /**
-     * Utility method to get the calling class name automatically
-     * Useful when you don't want to specify the tag manually
-     * @return The simple name of the calling class
-     */
-    public static String getCallingClassName() {
-        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
-        // Index 3 because: 0=getStackTrace, 1=getCallingClassName, 2=calling method, 3=actual caller
-        if (stackTrace.length > 3) {
-            String fullClassName = stackTrace[3].getClassName();
-            return fullClassName.substring(fullClassName.lastIndexOf('.') + 1);
-        }
-        return "Unknown";
-    }
-}
+package com.melisa.innovamotionapp.utils;
+
+import android.util.Log;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/**
+ * Centralized logging utility for InnovaMotionApp.
+ * Provides consistent logging across the application with different log levels,
+ * automatic tag generation, and production-safe logging.
+ * 
+ * Usage:
+ * Logger.d("MainActivity", "User logged in successfully");
+ * Logger.e("BluetoothService", "Connection failed", exception);
+ * Logger.i("StatisticsActivity", "Chart data updated");
+ */
+public class Logger {
+    
+    private static final String APP_TAG = "InnovaMotion";
+    private static final boolean ENABLE_DEBUG_LOGS = true; // Set to false in production
+    private static final boolean ENABLE_VERBOSE_LOGS = false; // Usually false in production
+    
+    /**
+     * Debug log - for detailed debugging information
+     * @param tag The tag to identify the source (usually class name)
+     * @param message The message to log
+     */
+    public static void d(@NonNull String tag, @NonNull String message) {
+        if (ENABLE_DEBUG_LOGS) {
+            Log.d(formatTag(tag), message);
+        }
+    }
+    
+    /**
+     * Debug log with exception
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     * @param throwable The exception to log
+     */
+    public static void d(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
+        if (ENABLE_DEBUG_LOGS) {
+            Log.d(formatTag(tag), message, throwable);
+        }
+    }
+    
+    /**
+     * Info log - for general information
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     */
+    public static void i(@NonNull String tag, @NonNull String message) {
+        Log.i(formatTag(tag), message);
+    }
+    
+    /**
+     * Info log with exception
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     * @param throwable The exception to log
+     */
+    public static void i(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
+        Log.i(formatTag(tag), message, throwable);
+    }
+    
+    /**
+     * Warning log - for potential issues
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     */
+    public static void w(@NonNull String tag, @NonNull String message) {
+        Log.w(formatTag(tag), message);
+    }
+    
+    /**
+     * Warning log with exception
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     * @param throwable The exception to log
+     */
+    public static void w(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
+        Log.w(formatTag(tag), message, throwable);
+    }
+    
+    /**
+     * Error log - for errors and exceptions
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     */
+    public static void e(@NonNull String tag, @NonNull String message) {
+        Log.e(formatTag(tag), message);
+    }
+    
+    /**
+     * Error log with exception
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     * @param throwable The exception to log
+     */
+    public static void e(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
+        Log.e(formatTag(tag), message, throwable);
+    }
+    
+    /**
+     * Verbose log - for very detailed debugging (usually disabled in production)
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     */
+    public static void v(@NonNull String tag, @NonNull String message) {
+        if (ENABLE_VERBOSE_LOGS) {
+            Log.v(formatTag(tag), message);
+        }
+    }
+    
+    /**
+     * Verbose log with exception
+     * @param tag The tag to identify the source
+     * @param message The message to log
+     * @param throwable The exception to log
+     */
+    public static void v(@NonNull String tag, @NonNull String message, @Nullable Throwable throwable) {
+        if (ENABLE_VERBOSE_LOGS) {
+            Log.v(formatTag(tag), message, throwable);
+        }
+    }
+    
+    /**
+     * Logs Bluetooth-specific events with consistent formatting
+     * @param tag The source tag
+     * @param deviceAddress The Bluetooth device address
+     * @param event The event description
+     */
+    public static void bluetooth(@NonNull String tag, @NonNull String deviceAddress, @NonNull String event) {
+        i(tag, String.format("BT[%s]: %s", deviceAddress, event));
+    }
+    
+    /**
+     * Logs user interaction events
+     * @param tag The source tag
+     * @param action The user action performed
+     */
+    public static void userAction(@NonNull String tag, @NonNull String action) {
+        i(tag, String.format("USER_ACTION: %s", action));
+    }
+    
+    /**
+     * Logs performance-related information
+     * @param tag The source tag
+     * @param operation The operation being measured
+     * @param durationMs The duration in milliseconds
+     */
+    public static void performance(@NonNull String tag, @NonNull String operation, long durationMs) {
+        d(tag, String.format("PERF: %s took %dms", operation, durationMs));
+    }
+    
+    /**
+     * Formats the tag with app prefix for easier filtering in logs
+     * @param tag The original tag
+     * @return Formatted tag with app prefix
+     */
+    private static String formatTag(@NonNull String tag) {
+        return APP_TAG + "_" + tag;
+    }
+    
+    /**
+     * Utility method to get the calling class name automatically
+     * Useful when you don't want to specify the tag manually
+     * @return The simple name of the calling class
+     */
+    public static String getCallingClassName() {
+        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
+        // Index 3 because: 0=getStackTrace, 1=getCallingClassName, 2=calling method, 3=actual caller
+        if (stackTrace.length > 3) {
+            String fullClassName = stackTrace[3].getClassName();
+            return fullClassName.substring(fullClassName.lastIndexOf('.') + 1);
+        }
+        return "Unknown";
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/MockDataGenerator.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/MockDataGenerator.java
index 5d4b048..bde9dde 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/MockDataGenerator.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/MockDataGenerator.java
@@ -144,10 +144,8 @@ public class MockDataGenerator {
                 // Generate sensor IDs
                 List<String> sensorIds = generateSensorIds(sensorCount);
                 
-                // Create person entries for name resolution scenario
-                if (scenario == TestScenario.NAME_RESOLUTION) {
-                    createPersonEntries(sensorIds);
-                }
+                // Create person entries for ALL scenarios to ensure Live Posture tab works
+                createPersonEntries(sensorIds);
                 
                 // Generate readings
                 List<ReceivedBtDataEntity> allReadings = new ArrayList<>();
@@ -190,6 +188,12 @@ public class MockDataGenerator {
                 // Insert all readings into database
                 btDataDao.insertAll(allReadings);
                 
+                // #region agent log
+                // H5: Verify data was inserted into Room
+                int dbCount = btDataDao.dbgCountAll();
+                android.util.Log.w("DBG_H5", "After insertAll: insertedCount=" + allReadings.size() + ", dbCountAfter=" + dbCount + ", ownerUserId=" + ownerUserId + ", sensorIds=" + sensorIds);
+                // #endregion
+                
                 int totalReadings = allReadings.size();
                 Logger.i(TAG, "Scenario complete: " + totalReadings + " readings for " + sensorCount + " sensors");
                 
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/NotificationConfig.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/NotificationConfig.java
index 64c6404..99d27b1 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/NotificationConfig.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/NotificationConfig.java
@@ -1,51 +1,51 @@
-package com.melisa.innovamotionapp.utils;
-
-import android.app.NotificationChannel;
-import android.app.NotificationManager;
-import android.content.Context;
-import android.os.Build;
-
-import com.melisa.innovamotionapp.R;
-
-public final class NotificationConfig {
-    private NotificationConfig() {}
-
-    // Channel IDs (stable identifiers)
-    public static final String CHANNEL_BT_SERVICE = "bluetooth_service_channel";
-    public static final String CHANNEL_FALL_ALERTS = "fall_alerts";
-
-    // Notification IDs (stable integers)
-    public static final int NOTIF_ID_BT_SERVICE = 1;      // foreground service
-    public static final int NOTIF_ID_FALL_BASE   = 9000;  // can reuse or offset if needed
-
-    // PendingIntent request codes
-    public static final int RC_OPEN_FROM_SERVICE = 2001;
-    public static final int RC_OPEN_FROM_FALL    = 1001;
-
-    // Intent actions
-    public static final String ACTION_OPEN_FROM_SERVICE = "com.melisa.ACTION_OPEN_FROM_SERVICE";
-    public static final String ACTION_VIEW_FALL        = "com.melisa.ACTION_VIEW_FALL";
-
-    /** Call once at app startup (e.g., in Application.onCreate). */
-    public static void initAllChannels(Context ctx) {
-        NotificationManager nm = ctx.getSystemService(NotificationManager.class);
-
-        // Bluetooth Service channel (quiet/low)
-        NotificationChannel bt = new NotificationChannel(
-                CHANNEL_BT_SERVICE,
-                ctx.getString(R.string.ch_bt_service_name),
-                NotificationManager.IMPORTANCE_MIN
-        );
-        bt.setDescription(ctx.getString(R.string.ch_bt_service_desc));
-        nm.createNotificationChannel(bt);
-
-        // Fall Alerts (high/important)
-        NotificationChannel fall = new NotificationChannel(
-                CHANNEL_FALL_ALERTS,
-                ctx.getString(R.string.ch_fall_alerts_name),
-                NotificationManager.IMPORTANCE_HIGH
-        );
-        fall.setDescription(ctx.getString(R.string.ch_fall_alerts_desc));
-        nm.createNotificationChannel(fall);
-    }
+package com.melisa.innovamotionapp.utils;
+
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.os.Build;
+
+import com.melisa.innovamotionapp.R;
+
+public final class NotificationConfig {
+    private NotificationConfig() {}
+
+    // Channel IDs (stable identifiers)
+    public static final String CHANNEL_BT_SERVICE = "bluetooth_service_channel";
+    public static final String CHANNEL_FALL_ALERTS = "fall_alerts";
+
+    // Notification IDs (stable integers)
+    public static final int NOTIF_ID_BT_SERVICE = 1;      // foreground service
+    public static final int NOTIF_ID_FALL_BASE   = 9000;  // can reuse or offset if needed
+
+    // PendingIntent request codes
+    public static final int RC_OPEN_FROM_SERVICE = 2001;
+    public static final int RC_OPEN_FROM_FALL    = 1001;
+
+    // Intent actions
+    public static final String ACTION_OPEN_FROM_SERVICE = "com.melisa.ACTION_OPEN_FROM_SERVICE";
+    public static final String ACTION_VIEW_FALL        = "com.melisa.ACTION_VIEW_FALL";
+
+    /** Call once at app startup (e.g., in Application.onCreate). */
+    public static void initAllChannels(Context ctx) {
+        NotificationManager nm = ctx.getSystemService(NotificationManager.class);
+
+        // Bluetooth Service channel (quiet/low)
+        NotificationChannel bt = new NotificationChannel(
+                CHANNEL_BT_SERVICE,
+                ctx.getString(R.string.ch_bt_service_name),
+                NotificationManager.IMPORTANCE_MIN
+        );
+        bt.setDescription(ctx.getString(R.string.ch_bt_service_desc));
+        nm.createNotificationChannel(bt);
+
+        // Fall Alerts (high/important)
+        NotificationChannel fall = new NotificationChannel(
+                CHANNEL_FALL_ALERTS,
+                ctx.getString(R.string.ch_fall_alerts_name),
+                NotificationManager.IMPORTANCE_HIGH
+        );
+        fall.setDescription(ctx.getString(R.string.ch_fall_alerts_desc));
+        nm.createNotificationChannel(fall);
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/OwnerSource.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/OwnerSource.java
index 713f755..e0b78b2 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/OwnerSource.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/OwnerSource.java
@@ -1,31 +1,31 @@
-package com.melisa.innovamotionapp.utils;
-
-import android.util.Log;
-import java.util.List;
-
-public final class OwnerSource {
-    private OwnerSource() {}
-
-    /** 
-     * For supervised: read currentUserUid.
-     * For supervisor: read the FIRST supervised child (or your selected child if you later add UI).
-     */
-    public static String resolveOwnerUidForUI(GlobalData global) {
-        String role = global.currentUserRole;
-        if ("supervised".equals(role)) {
-            Log.i("UI/Owner", "role=supervised -> owner=" + global.currentUserUid);
-            return global.currentUserUid;
-        }
-        if ("supervisor".equals(role)) {
-            List<String> sensorIds = global.supervisedSensorIds;
-            if (sensorIds != null && !sensorIds.isEmpty()) {
-                Log.i("UI/Owner", "role=supervisor -> sensorId=" + sensorIds.get(0));
-                return sensorIds.get(0);
-            }
-            Log.e("UI/Owner", "role=supervisor but no supervisedSensorIds!");
-            return null;
-        }
-        Log.e("UI/Owner", "UNKNOWN role; cannot resolve owner");
-        return null;
-    }
-}
+package com.melisa.innovamotionapp.utils;
+
+import android.util.Log;
+import java.util.List;
+
+public final class OwnerSource {
+    private OwnerSource() {}
+
+    /** 
+     * For supervised: read currentUserUid.
+     * For supervisor: read the FIRST supervised child (or your selected child if you later add UI).
+     */
+    public static String resolveOwnerUidForUI(GlobalData global) {
+        String role = global.currentUserRole;
+        if ("supervised".equals(role)) {
+            Log.i("UI/Owner", "role=supervised -> owner=" + global.currentUserUid);
+            return global.currentUserUid;
+        }
+        if ("supervisor".equals(role)) {
+            List<String> sensorIds = global.supervisedSensorIds;
+            if (sensorIds != null && !sensorIds.isEmpty()) {
+                Log.i("UI/Owner", "role=supervisor -> sensorId=" + sensorIds.get(0));
+                return sensorIds.get(0);
+            }
+            Log.e("UI/Owner", "role=supervisor but no supervisedSensorIds!");
+            return null;
+        }
+        Log.e("UI/Owner", "UNKNOWN role; cannot resolve owner");
+        return null;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/RoleProvider.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/RoleProvider.java
index 651e589..8b5d592 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/RoleProvider.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/RoleProvider.java
@@ -1,49 +1,49 @@
-package com.melisa.innovamotionapp.utils;
-
-/**
- * Utility class for accessing the current user's role.
- * Provides a simple interface to get the cached role from GlobalData.
- */
-public final class RoleProvider {
-    public enum Role { 
-        AGGREGATOR,  // Collects data from sensors, uploads to cloud (formerly "supervised")
-        SUPERVISOR,  // Monitors aggregators' data
-        UNKNOWN 
-    }
-
-    private RoleProvider() {}
-
-    /**
-     * Get the current user's role from cached data.
-     * This assumes the role is already cached in GlobalData after login.
-     * 
-     * @return The current user's role, or UNKNOWN if not available
-     */
-    public static Role getCurrentRole() {
-        // Get role from GlobalData (should be cached after login)
-        String role = GlobalData.getInstance().currentUserRole;
-        if ("aggregator".equalsIgnoreCase(role)) {
-            return Role.AGGREGATOR;
-        }
-        if ("supervisor".equalsIgnoreCase(role)) {
-            return Role.SUPERVISOR;
-        }
-        return Role.UNKNOWN;
-    }
-    
-    /**
-     * Check if the current user is a supervisor
-     * @return true if user is a supervisor, false otherwise
-     */
-    public static boolean isSupervisor() {
-        return getCurrentRole() == Role.SUPERVISOR;
-    }
-    
-    /**
-     * Check if the current user is an aggregator (formerly "supervised")
-     * @return true if user is an aggregator, false otherwise
-     */
-    public static boolean isAggregator() {
-        return getCurrentRole() == Role.AGGREGATOR;
-    }
-}
+package com.melisa.innovamotionapp.utils;
+
+/**
+ * Utility class for accessing the current user's role.
+ * Provides a simple interface to get the cached role from GlobalData.
+ */
+public final class RoleProvider {
+    public enum Role { 
+        AGGREGATOR,  // Collects data from sensors, uploads to cloud (formerly "supervised")
+        SUPERVISOR,  // Monitors aggregators' data
+        UNKNOWN 
+    }
+
+    private RoleProvider() {}
+
+    /**
+     * Get the current user's role from cached data.
+     * This assumes the role is already cached in GlobalData after login.
+     * 
+     * @return The current user's role, or UNKNOWN if not available
+     */
+    public static Role getCurrentRole() {
+        // Get role from GlobalData (should be cached after login)
+        String role = GlobalData.getInstance().currentUserRole;
+        if ("aggregator".equalsIgnoreCase(role)) {
+            return Role.AGGREGATOR;
+        }
+        if ("supervisor".equalsIgnoreCase(role)) {
+            return Role.SUPERVISOR;
+        }
+        return Role.UNKNOWN;
+    }
+    
+    /**
+     * Check if the current user is a supervisor
+     * @return true if user is a supervisor, false otherwise
+     */
+    public static boolean isSupervisor() {
+        return getCurrentRole() == Role.SUPERVISOR;
+    }
+    
+    /**
+     * Check if the current user is an aggregator (formerly "supervised")
+     * @return true if user is an aggregator, false otherwise
+     */
+    public static boolean isAggregator() {
+        return getCurrentRole() == Role.AGGREGATOR;
+    }
+}
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/TargetUserResolver.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/TargetUserResolver.java
index d9411c7..6b56309 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/TargetUserResolver.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/TargetUserResolver.java
@@ -1,24 +1,24 @@
-package com.melisa.innovamotionapp.utils;
-
-import android.content.Context;
-
-import com.melisa.innovamotionapp.sync.UserSession;
-
-public final class TargetUserResolver {
-    private TargetUserResolver() {}
-
-    public static String resolveTargetUserId(Context context) {
-        UserSession session = UserSession.getInstance(context.getApplicationContext());
-        if (!session.isLoaded()) return null;
-        if (session.isAggregator()) {
-            return session.getCurrentUserId();
-        } else if (session.isSupervisor()) {
-            // For supervisors, return first supervised sensor ID (for data access)
-            java.util.List<String> sensorIds = session.getSupervisedSensorIds();
-            return (sensorIds == null || sensorIds.isEmpty()) ? null : sensorIds.get(0);
-        }
-        return null;
-    }
-}
-
-
+package com.melisa.innovamotionapp.utils;
+
+import android.content.Context;
+
+import com.melisa.innovamotionapp.sync.UserSession;
+
+public final class TargetUserResolver {
+    private TargetUserResolver() {}
+
+    public static String resolveTargetUserId(Context context) {
+        UserSession session = UserSession.getInstance(context.getApplicationContext());
+        if (!session.isLoaded()) return null;
+        if (session.isAggregator()) {
+            return session.getCurrentUserId();
+        } else if (session.isSupervisor()) {
+            // For supervisors, return first supervised sensor ID (for data access)
+            java.util.List<String> sensorIds = session.getSupervisedSensorIds();
+            return (sensorIds == null || sensorIds.isEmpty()) ? null : sensorIds.get(0);
+        }
+        return null;
+    }
+}
+
+
diff --git a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/UserDeviceSettingsStorage.java b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/UserDeviceSettingsStorage.java
index 1c6e66c..7dcfb35 100644
--- a/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/UserDeviceSettingsStorage.java
+++ b/InnovaMotionApp/app/src/main/java/com/melisa/innovamotionapp/utils/UserDeviceSettingsStorage.java
@@ -1,41 +1,41 @@
-package com.melisa.innovamotionapp.utils;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-
-
-public class UserDeviceSettingsStorage {
-    private static final String PREF_NAME = "UserDevicePrefs";
-    private static final String LATEST_USER_KEY = "latestUser";
-    private static final String LATEST_DEVICE_ADDRESS = "lastDeviceAddress";
-    private final SharedPreferences sharedPreferences;
-
-    public UserDeviceSettingsStorage(Context context) {
-        sharedPreferences = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
-    }
-
-    // Save the latest username
-    public void saveLatestUser(String userName) {
-        SharedPreferences.Editor editor = sharedPreferences.edit();
-        editor.putString(LATEST_USER_KEY, userName);
-        editor.apply();
-    }
-
-    // Save the latest device address
-    public void saveLatestDeviceAddress(String deviceAddress) {
-        SharedPreferences.Editor editor = sharedPreferences.edit();
-        editor.putString(LATEST_DEVICE_ADDRESS, deviceAddress);
-        editor.apply();
-    }
-
-    // Retrieve the latest username
-    public String getLatestUser() {
-        return sharedPreferences.getString(LATEST_USER_KEY, "");
-    }
-
-    // Retrieve the latest device address
-    public String getLatestDeviceAddress() {
-        return sharedPreferences.getString(LATEST_DEVICE_ADDRESS, "");
-    }
-
+package com.melisa.innovamotionapp.utils;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+
+
+public class UserDeviceSettingsStorage {
+    private static final String PREF_NAME = "UserDevicePrefs";
+    private static final String LATEST_USER_KEY = "latestUser";
+    private static final String LATEST_DEVICE_ADDRESS = "lastDeviceAddress";
+    private final SharedPreferences sharedPreferences;
+
+    public UserDeviceSettingsStorage(Context context) {
+        sharedPreferences = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
+    }
+
+    // Save the latest username
+    public void saveLatestUser(String userName) {
+        SharedPreferences.Editor editor = sharedPreferences.edit();
+        editor.putString(LATEST_USER_KEY, userName);
+        editor.apply();
+    }
+
+    // Save the latest device address
+    public void saveLatestDeviceAddress(String deviceAddress) {
+        SharedPreferences.Editor editor = sharedPreferences.edit();
+        editor.putString(LATEST_DEVICE_ADDRESS, deviceAddress);
+        editor.apply();
+    }
+
+    // Retrieve the latest username
+    public String getLatestUser() {
+        return sharedPreferences.getString(LATEST_USER_KEY, "");
+    }
+
+    // Retrieve the latest device address
+    public String getLatestDeviceAddress() {
+        return sharedPreferences.getString(LATEST_DEVICE_ADDRESS, "");
+    }
+
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_connected_24.xml b/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_connected_24.xml
index 35ff964..8eae476 100644
--- a/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_connected_24.xml
+++ b/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_connected_24.xml
@@ -1,5 +1,5 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
-      
-    <path android:fillColor="@android:color/white" android:pathData="M7,12l-2,-2 -2,2 2,2 2,-2zM17.71,7.71L12,2h-1v7.59L6.41,5 5,6.41 10.59,12 5,17.59 6.41,19 11,14.41L11,22h1l5.71,-5.71 -4.3,-4.29 4.3,-4.29zM13,5.83l1.88,1.88L13,9.59L13,5.83zM14.88,16.29L13,18.17v-3.76l1.88,1.88zM19,10l-2,2 2,2 2,-2 -2,-2z"/>
-    
-</vector>
+<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
+      
+    <path android:fillColor="@android:color/white" android:pathData="M7,12l-2,-2 -2,2 2,2 2,-2zM17.71,7.71L12,2h-1v7.59L6.41,5 5,6.41 10.59,12 5,17.59 6.41,19 11,14.41L11,22h1l5.71,-5.71 -4.3,-4.29 4.3,-4.29zM13,5.83l1.88,1.88L13,9.59L13,5.83zM14.88,16.29L13,18.17v-3.76l1.88,1.88zM19,10l-2,2 2,2 2,-2 -2,-2z"/>
+    
+</vector>
diff --git a/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_disabled_24.xml b/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_disabled_24.xml
index 3bb57e6..e1590b2 100644
--- a/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_disabled_24.xml
+++ b/InnovaMotionApp/app/src/main/res/drawable/baseline_bluetooth_disabled_24.xml
@@ -1,5 +1,5 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
-      
-    <path android:fillColor="@android:color/white" android:pathData="M13,5.83l1.88,1.88 -1.6,1.6 1.41,1.41 3.02,-3.02L12,2h-1v5.03l2,2v-3.2zM5.41,4L4,5.41 10.59,12 5,17.59 6.41,19 11,14.41V22h1l4.29,-4.29 2.3,2.29L20,18.59 5.41,4zM13,18.17v-3.76l1.88,1.88L13,18.17z"/>
-    
-</vector>
+<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
+      
+    <path android:fillColor="@android:color/white" android:pathData="M13,5.83l1.88,1.88 -1.6,1.6 1.41,1.41 3.02,-3.02L12,2h-1v5.03l2,2v-3.2zM5.41,4L4,5.41 10.59,12 5,17.59 6.41,19 11,14.41V22h1l4.29,-4.29 2.3,2.29L20,18.59 5.41,4zM13,18.17v-3.76l1.88,1.88L13,18.17z"/>
+    
+</vector>
diff --git a/InnovaMotionApp/app/src/main/res/drawable/ic_google.xml b/InnovaMotionApp/app/src/main/res/drawable/ic_google.xml
index edd1649..f9b6226 100644
--- a/InnovaMotionApp/app/src/main/res/drawable/ic_google.xml
+++ b/InnovaMotionApp/app/src/main/res/drawable/ic_google.xml
@@ -1,18 +1,18 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="24dp"
-    android:height="24dp"
-    android:viewportWidth="24"
-    android:viewportHeight="24">
-    <path
-        android:fillColor="#4285F4"
-        android:pathData="M22.56,12.25c0,-0.78 -0.07,-1.53 -0.2,-2.25H12v4.26h5.92c-0.26,1.37 -1.04,2.53 -2.21,3.31v2.77h3.57c2.08,-1.92 3.28,-4.74 3.28,-8.09z"/>
-    <path
-        android:fillColor="#34A853"
-        android:pathData="M12,23c2.97,0 5.46,-0.98 7.28,-2.66l-3.57,-2.77c-0.98,0.66 -2.23,1.06 -3.71,1.06 -2.86,0 -5.29,-1.93 -6.16,-4.53H2.18v2.84C3.99,20.53 7.7,23 12,23z"/>
-    <path
-        android:fillColor="#FBBC05"
-        android:pathData="M5.84,14.09c-0.22,-0.66 -0.35,-1.36 -0.35,-2.09s0.13,-1.43 0.35,-2.09V7.07H2.18C1.43,8.55 1,10.22 1,12s0.43,3.45 1.18,4.93l2.85,-2.22 0.81,-0.62z"/>
-    <path
-        android:fillColor="#EA4335"
-        android:pathData="M12,5.38c1.62,0 3.06,0.56 4.21,1.64l3.15,-3.15C17.45,2.09 14.97,1 12,1 7.7,1 3.99,3.47 2.18,7.07l3.66,2.84c0.87,-2.6 3.3,-4.53 6.16,-4.53z"/>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+    <path
+        android:fillColor="#4285F4"
+        android:pathData="M22.56,12.25c0,-0.78 -0.07,-1.53 -0.2,-2.25H12v4.26h5.92c-0.26,1.37 -1.04,2.53 -2.21,3.31v2.77h3.57c2.08,-1.92 3.28,-4.74 3.28,-8.09z"/>
+    <path
+        android:fillColor="#34A853"
+        android:pathData="M12,23c2.97,0 5.46,-0.98 7.28,-2.66l-3.57,-2.77c-0.98,0.66 -2.23,1.06 -3.71,1.06 -2.86,0 -5.29,-1.93 -6.16,-4.53H2.18v2.84C3.99,20.53 7.7,23 12,23z"/>
+    <path
+        android:fillColor="#FBBC05"
+        android:pathData="M5.84,14.09c-0.22,-0.66 -0.35,-1.36 -0.35,-2.09s0.13,-1.43 0.35,-2.09V7.07H2.18C1.43,8.55 1,10.22 1,12s0.43,3.45 1.18,4.93l2.85,-2.22 0.81,-0.62z"/>
+    <path
+        android:fillColor="#EA4335"
+        android:pathData="M12,5.38c1.62,0 3.06,0.56 4.21,1.64l3.15,-3.15C17.45,2.09 14.97,1 12,1 7.7,1 3.99,3.47 2.18,7.07l3.66,2.84c0.87,-2.6 3.3,-4.53 6.16,-4.53z"/>
 </vector>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_background.xml b/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_background.xml
index 07d5da9..a4f78de 100644
--- a/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_background.xml
+++ b/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_background.xml
@@ -1,170 +1,170 @@
-<?xml version="1.0" encoding="utf-8"?>
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="108dp"
-    android:height="108dp"
-    android:viewportWidth="108"
-    android:viewportHeight="108">
-    <path
-        android:fillColor="#3DDC84"
-        android:pathData="M0,0h108v108h-108z" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M9,0L9,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,0L19,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M29,0L29,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M39,0L39,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M49,0L49,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M59,0L59,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M69,0L69,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M79,0L79,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M89,0L89,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M99,0L99,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,9L108,9"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,19L108,19"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,29L108,29"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,39L108,39"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,49L108,49"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,59L108,59"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,69L108,69"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,79L108,79"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,89L108,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,99L108,99"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,29L89,29"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,39L89,39"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,49L89,49"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,59L89,59"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,69L89,69"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,79L89,79"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M29,19L29,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M39,19L39,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M49,19L49,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M59,19L59,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M69,19L69,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M79,19L79,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-</vector>
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path
+        android:fillColor="#3DDC84"
+        android:pathData="M0,0h108v108h-108z" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M9,0L9,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,0L19,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,0L29,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,0L39,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,0L49,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,0L59,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,0L69,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,0L79,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M89,0L89,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M99,0L99,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,9L108,9"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,19L108,19"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,29L108,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,39L108,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,49L108,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,59L108,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,69L108,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,79L108,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,89L108,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,99L108,99"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,29L89,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,39L89,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,49L89,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,59L89,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,69L89,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,79L89,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,19L29,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,19L39,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,19L49,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,19L59,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,19L69,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,19L79,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+</vector>
diff --git a/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_foreground.xml b/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_foreground.xml
index 2b068d1..cc14f03 100644
--- a/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_foreground.xml
+++ b/InnovaMotionApp/app/src/main/res/drawable/ic_launcher_foreground.xml
@@ -1,30 +1,30 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:aapt="http://schemas.android.com/aapt"
-    android:width="108dp"
-    android:height="108dp"
-    android:viewportWidth="108"
-    android:viewportHeight="108">
-    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
-        <aapt:attr name="android:fillColor">
-            <gradient
-                android:endX="85.84757"
-                android:endY="92.4963"
-                android:startX="42.9492"
-                android:startY="49.59793"
-                android:type="linear">
-                <item
-                    android:color="#44000000"
-                    android:offset="0.0" />
-                <item
-                    android:color="#00000000"
-                    android:offset="1.0" />
-            </gradient>
-        </aapt:attr>
-    </path>
-    <path
-        android:fillColor="#FFFFFF"
-        android:fillType="nonZero"
-        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
-        android:strokeWidth="1"
-        android:strokeColor="#00000000" />
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:aapt="http://schemas.android.com/aapt"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
+        <aapt:attr name="android:fillColor">
+            <gradient
+                android:endX="85.84757"
+                android:endY="92.4963"
+                android:startX="42.9492"
+                android:startY="49.59793"
+                android:type="linear">
+                <item
+                    android:color="#44000000"
+                    android:offset="0.0" />
+                <item
+                    android:color="#00000000"
+                    android:offset="1.0" />
+            </gradient>
+        </aapt:attr>
+    </path>
+    <path
+        android:fillColor="#FFFFFF"
+        android:fillType="nonZero"
+        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
+        android:strokeWidth="1"
+        android:strokeColor="#00000000" />
 </vector>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/layout-w320dp/activity_login.xml b/InnovaMotionApp/app/src/main/res/layout-w320dp/activity_login.xml
index 2cba91e..714e0df 100644
--- a/InnovaMotionApp/app/src/main/res/layout-w320dp/activity_login.xml
+++ b/InnovaMotionApp/app/src/main/res/layout-w320dp/activity_login.xml
@@ -1,205 +1,205 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:fillViewport="true"
-    android:background="?android:attr/colorBackground"
-    tools:context="._login.login.LoginActivity">
-
-    <androidx.constraintlayout.widget.ConstraintLayout
-        android:id="@+id/container"
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:padding="32dp"
-        android:clipChildren="false"
-        android:clipToPadding="false">>
-
-        <!-- App Logo or Title -->
-        <TextView
-            android:id="@+id/app_title"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="48dp"
-            android:text="@string/app_name"
-            android:textSize="32sp"
-            android:textStyle="bold"
-            android:textColor="?attr/colorOnBackground"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toTopOf="parent" />
-
-        <TextView
-            android:id="@+id/welcome_text"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="8dp"
-            android:text="Welcome back!"
-            android:textSize="16sp"
-            android:textColor="?attr/colorOnSurfaceVariant"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toBottomOf="@+id/app_title" />
-
-        <!-- Login Form Card -->
-        <androidx.cardview.widget.CardView
-            android:id="@+id/login_card"
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="48dp"
-            app:cardCornerRadius="16dp"
-            app:cardElevation="8dp"
-            app:cardBackgroundColor="?attr/colorSurface"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toBottomOf="@+id/welcome_text">
-
-            <LinearLayout
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:orientation="vertical"
-                android:padding="24dp">
-
-
-
-                <!-- Google Sign-In Button -->
-                <com.google.android.material.button.MaterialButton
-                    android:id="@+id/google_sign_in_button"
-                    android:layout_width="match_parent"
-                    android:layout_height="56dp"
-                    android:text="@string/sign_in_with_google"
-                    android:textColor="?attr/colorOnSurfaceVariant"
-                    android:textSize="16sp"
-                    app:icon="@drawable/ic_google"
-                    app:iconGravity="textStart"
-                    app:iconTint="@null"
-                    app:cornerRadius="28dp"
-                    app:strokeColor="?attr/colorOutline"
-                    app:strokeWidth="1dp"
-                    style="@style/Widget.MaterialComponents.Button.OutlinedButton" />
-
-                <!-- Signed-in management section -->
-                <LinearLayout
-                    android:id="@+id/signed_in_section"
-                    android:layout_width="match_parent"
-                    android:layout_height="wrap_content"
-                    android:orientation="vertical"
-                    android:paddingTop="8dp"
-                    android:visibility="gone">
-
-                    <TextView
-                        android:id="@+id/signed_in_as_text"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:textColor="?attr/colorOnSurface"
-                        android:textSize="14sp"
-                        android:paddingBottom="8dp"
-                        android:text="@string/signed_in_as_placeholder" />
-
-                    <!-- Role selection header -->
-                    <TextView
-                        android:id="@+id/choose_role_text"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:text="@string/choose_account_type"
-                        android:textStyle="bold"
-                        android:textSize="16sp"
-                        android:paddingTop="8dp"
-                        android:paddingBottom="4dp"
-                        android:textColor="?attr/colorOnSurface" />
-
-                    <!-- Role selection radio group - VERTICAL for narrow screens -->
-                    <RadioGroup
-                        android:id="@+id/role_group"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:orientation="vertical">
-
-                        <RadioButton
-                            android:id="@+id/role_supervisor"
-                            android:layout_width="wrap_content"
-                            android:layout_height="wrap_content"
-                            android:text="@string/role_supervisor" />
-
-                        <RadioButton
-                            android:id="@+id/role_aggregator"
-                            android:layout_width="wrap_content"
-                            android:layout_height="wrap_content"
-                            android:layout_marginTop="8dp"
-                            android:text="@string/role_aggregator" />
-                    </RadioGroup>
-
-                    <com.google.android.material.textfield.TextInputLayout
-                        android:id="@+id/aggregator_email_layout"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:layout_marginTop="8dp"
-                        android:hint="@string/aggregator_email_hint"
-                        android:visibility="gone"
-                        style="@style/Theme.InnovaMotionApp.TextInputLayout">
-
-                        <com.google.android.material.textfield.TextInputEditText
-                            android:id="@+id/aggregator_email"
-                            android:layout_width="match_parent"
-                            android:layout_height="wrap_content"
-                            android:inputType="textEmailAddress"
-                            android:autofillHints="emailAddress" />
-
-                    </com.google.android.material.textfield.TextInputLayout>
-
-                    <!-- Proceed button to continue based on selected role -->
-                    <com.google.android.material.button.MaterialButton
-                        android:id="@+id/proceed_button"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:layout_marginTop="12dp"
-                        android:text="@string/proceed"
-                        style="@style/Theme.InnovaMotionApp.Button" />
-
-                    <com.google.android.material.button.MaterialButton
-                        android:id="@+id/sign_out_button"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:layout_marginTop="8dp"
-                        android:text="@string/sign_out"
-                        style="@style/Theme.InnovaMotionApp.Button.Secondary" />
-
-                </LinearLayout>
-
-            </LinearLayout>
-
-        </androidx.cardview.widget.CardView>
-
-        <!-- Loading Progress -->
-        <ProgressBar
-            android:id="@+id/loading"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:visibility="gone"
-            android:indeterminateTint="?attr/colorPrimary"
-            app:layout_constraintBottom_toBottomOf="@+id/login_card"
-            app:layout_constraintEnd_toEndOf="@+id/login_card"
-            app:layout_constraintStart_toStartOf="@+id/login_card"
-            app:layout_constraintTop_toTopOf="@+id/login_card" />
-
-        <!-- Footer Text -->
-        <TextView
-            android:id="@+id/footer_text"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="24dp"
-            android:layout_marginBottom="24dp"
-            android:text="By signing in, you agree to our Terms of Service and Privacy Policy"
-            android:textSize="12sp"
-            android:textColor="?attr/colorOnSurfaceVariant"
-            android:gravity="center"
-            app:layout_constraintBottom_toBottomOf="parent"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toBottomOf="@+id/login_card"
-            app:layout_constraintVertical_bias="1.0" />
-
-    </androidx.constraintlayout.widget.ConstraintLayout>
-
-</ScrollView>
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fillViewport="true"
+    android:background="?android:attr/colorBackground"
+    tools:context="._login.login.LoginActivity">
+
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:id="@+id/container"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:padding="32dp"
+        android:clipChildren="false"
+        android:clipToPadding="false">>
+
+        <!-- App Logo or Title -->
+        <TextView
+            android:id="@+id/app_title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="48dp"
+            android:text="@string/app_name"
+            android:textSize="32sp"
+            android:textStyle="bold"
+            android:textColor="?attr/colorOnBackground"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <TextView
+            android:id="@+id/welcome_text"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="8dp"
+            android:text="Welcome back!"
+            android:textSize="16sp"
+            android:textColor="?attr/colorOnSurfaceVariant"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/app_title" />
+
+        <!-- Login Form Card -->
+        <androidx.cardview.widget.CardView
+            android:id="@+id/login_card"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="48dp"
+            app:cardCornerRadius="16dp"
+            app:cardElevation="8dp"
+            app:cardBackgroundColor="?attr/colorSurface"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/welcome_text">
+
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical"
+                android:padding="24dp">
+
+
+
+                <!-- Google Sign-In Button -->
+                <com.google.android.material.button.MaterialButton
+                    android:id="@+id/google_sign_in_button"
+                    android:layout_width="match_parent"
+                    android:layout_height="56dp"
+                    android:text="@string/sign_in_with_google"
+                    android:textColor="?attr/colorOnSurfaceVariant"
+                    android:textSize="16sp"
+                    app:icon="@drawable/ic_google"
+                    app:iconGravity="textStart"
+                    app:iconTint="@null"
+                    app:cornerRadius="28dp"
+                    app:strokeColor="?attr/colorOutline"
+                    app:strokeWidth="1dp"
+                    style="@style/Widget.MaterialComponents.Button.OutlinedButton" />
+
+                <!-- Signed-in management section -->
+                <LinearLayout
+                    android:id="@+id/signed_in_section"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:orientation="vertical"
+                    android:paddingTop="8dp"
+                    android:visibility="gone">
+
+                    <TextView
+                        android:id="@+id/signed_in_as_text"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:textColor="?attr/colorOnSurface"
+                        android:textSize="14sp"
+                        android:paddingBottom="8dp"
+                        android:text="@string/signed_in_as_placeholder" />
+
+                    <!-- Role selection header -->
+                    <TextView
+                        android:id="@+id/choose_role_text"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:text="@string/choose_account_type"
+                        android:textStyle="bold"
+                        android:textSize="16sp"
+                        android:paddingTop="8dp"
+                        android:paddingBottom="4dp"
+                        android:textColor="?attr/colorOnSurface" />
+
+                    <!-- Role selection radio group - VERTICAL for narrow screens -->
+                    <RadioGroup
+                        android:id="@+id/role_group"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:orientation="vertical">
+
+                        <RadioButton
+                            android:id="@+id/role_supervisor"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:text="@string/role_supervisor" />
+
+                        <RadioButton
+                            android:id="@+id/role_aggregator"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:layout_marginTop="8dp"
+                            android:text="@string/role_aggregator" />
+                    </RadioGroup>
+
+                    <com.google.android.material.textfield.TextInputLayout
+                        android:id="@+id/aggregator_email_layout"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:layout_marginTop="8dp"
+                        android:hint="@string/aggregator_email_hint"
+                        android:visibility="gone"
+                        style="@style/Theme.InnovaMotionApp.TextInputLayout">
+
+                        <com.google.android.material.textfield.TextInputEditText
+                            android:id="@+id/aggregator_email"
+                            android:layout_width="match_parent"
+                            android:layout_height="wrap_content"
+                            android:inputType="textEmailAddress"
+                            android:autofillHints="emailAddress" />
+
+                    </com.google.android.material.textfield.TextInputLayout>
+
+                    <!-- Proceed button to continue based on selected role -->
+                    <com.google.android.material.button.MaterialButton
+                        android:id="@+id/proceed_button"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:layout_marginTop="12dp"
+                        android:text="@string/proceed"
+                        style="@style/Theme.InnovaMotionApp.Button" />
+
+                    <com.google.android.material.button.MaterialButton
+                        android:id="@+id/sign_out_button"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:layout_marginTop="8dp"
+                        android:text="@string/sign_out"
+                        style="@style/Theme.InnovaMotionApp.Button.Secondary" />
+
+                </LinearLayout>
+
+            </LinearLayout>
+
+        </androidx.cardview.widget.CardView>
+
+        <!-- Loading Progress -->
+        <ProgressBar
+            android:id="@+id/loading"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:visibility="gone"
+            android:indeterminateTint="?attr/colorPrimary"
+            app:layout_constraintBottom_toBottomOf="@+id/login_card"
+            app:layout_constraintEnd_toEndOf="@+id/login_card"
+            app:layout_constraintStart_toStartOf="@+id/login_card"
+            app:layout_constraintTop_toTopOf="@+id/login_card" />
+
+        <!-- Footer Text -->
+        <TextView
+            android:id="@+id/footer_text"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="24dp"
+            android:layout_marginBottom="24dp"
+            android:text="By signing in, you agree to our Terms of Service and Privacy Policy"
+            android:textSize="12sp"
+            android:textColor="?attr/colorOnSurfaceVariant"
+            android:gravity="center"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/login_card"
+            app:layout_constraintVertical_bias="1.0" />
+
+    </androidx.constraintlayout.widget.ConstraintLayout>
+
+</ScrollView>
diff --git a/InnovaMotionApp/app/src/main/res/layout-w320dp/bt_settings_activity.xml b/InnovaMotionApp/app/src/main/res/layout-w320dp/bt_settings_activity.xml
index 0ef076d..49ef07b 100644
--- a/InnovaMotionApp/app/src/main/res/layout-w320dp/bt_settings_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout-w320dp/bt_settings_activity.xml
@@ -1,81 +1,81 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:fillViewport="true">
-
-<androidx.constraintlayout.widget.ConstraintLayout
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    tools:context=".activities.BtSettingsActivity"
-    android:padding="16dp">
-
-    <!-- Sign out button in top-right corner -->
-    <com.google.android.material.button.MaterialButton
-        android:id="@+id/sign_out_button"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:text="@string/sign_out"
-        android:textSize="12sp"
-        app:icon="@android:drawable/ic_menu_close_clear_cancel"
-        app:iconSize="16dp"
-        style="@style/Theme.InnovaMotionApp.Button.Secondary"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-    <LinearLayout
-        android:id="@+id/mainContainer"
-        android:layout_width="0dp"
-        android:layout_height="0dp"
-        android:orientation="vertical"
-        android:gravity="center_horizontal"
-        android:padding="8dp"
-        android:layout_marginTop="8dp"
-        app:layout_constraintTop_toBottomOf="@id/sign_out_button"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent">
-
-        <!-- Vertical layout for narrow screens -->
-        <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical"
-            android:layout_marginBottom="16dp">
-
-            <TextView
-                android:id="@+id/textView2"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:text="Numele copilului:"
-                android:textSize="18sp"
-                android:layout_marginBottom="4dp" />
-
-            <EditText
-                android:id="@+id/inputChildName"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:hint="Popescu Mihaita"
-                android:inputType="textPersonName" />
-        </LinearLayout>
-
-        <Button
-            android:id="@+id/btConnection"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:enabled="false"
-            android:text="Conectare"
-            android:layout_gravity="center_horizontal"
-            android:layout_marginBottom="16dp" />
-
-        <ListView
-            android:id="@+id/deviceListRecyclerView"
-            android:layout_width="match_parent"
-            android:layout_height="0dp"
-            android:layout_weight="1" />
-    </LinearLayout>
-</androidx.constraintlayout.widget.ConstraintLayout>
-
-</ScrollView>
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fillViewport="true">
+
+<androidx.constraintlayout.widget.ConstraintLayout
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    tools:context=".activities.BtSettingsActivity"
+    android:padding="16dp">
+
+    <!-- Sign out button in top-right corner -->
+    <com.google.android.material.button.MaterialButton
+        android:id="@+id/sign_out_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/sign_out"
+        android:textSize="12sp"
+        app:icon="@android:drawable/ic_menu_close_clear_cancel"
+        app:iconSize="16dp"
+        style="@style/Theme.InnovaMotionApp.Button.Secondary"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <LinearLayout
+        android:id="@+id/mainContainer"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        android:orientation="vertical"
+        android:gravity="center_horizontal"
+        android:padding="8dp"
+        android:layout_marginTop="8dp"
+        app:layout_constraintTop_toBottomOf="@id/sign_out_button"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent">
+
+        <!-- Vertical layout for narrow screens -->
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:layout_marginBottom="16dp">
+
+            <TextView
+                android:id="@+id/textView2"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="Numele copilului:"
+                android:textSize="18sp"
+                android:layout_marginBottom="4dp" />
+
+            <EditText
+                android:id="@+id/inputChildName"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:hint="Popescu Mihaita"
+                android:inputType="textPersonName" />
+        </LinearLayout>
+
+        <Button
+            android:id="@+id/btConnection"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:enabled="false"
+            android:text="Conectare"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginBottom="16dp" />
+
+        <ListView
+            android:id="@+id/deviceListRecyclerView"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="1" />
+    </LinearLayout>
+</androidx.constraintlayout.widget.ConstraintLayout>
+
+</ScrollView>
diff --git a/InnovaMotionApp/app/src/main/res/layout/activity_aggregator_dashboard.xml b/InnovaMotionApp/app/src/main/res/layout/activity_aggregator_dashboard.xml
index dd6938a..3e4202b 100644
--- a/InnovaMotionApp/app/src/main/res/layout/activity_aggregator_dashboard.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/activity_aggregator_dashboard.xml
@@ -9,6 +9,16 @@
         android:layout_width="match_parent"
         android:layout_height="wrap_content">
 
+        <com.google.android.material.appbar.MaterialToolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?attr/actionBarSize"
+            android:background="?attr/colorPrimary"
+            app:title="@string/app_name"
+            app:titleTextColor="?attr/colorOnPrimary"
+            app:menu="@menu/aggregator_dashboard_menu"
+            style="@style/Widget.Material3.Toolbar.Surface" />
+
         <com.google.android.material.tabs.TabLayout
             android:id="@+id/tabLayout"
             android:layout_width="match_parent"
diff --git a/InnovaMotionApp/app/src/main/res/layout/activity_login.xml b/InnovaMotionApp/app/src/main/res/layout/activity_login.xml
index 28b870b..afc02c2 100644
--- a/InnovaMotionApp/app/src/main/res/layout/activity_login.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/activity_login.xml
@@ -1,205 +1,205 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:fillViewport="true"
-    android:background="?android:attr/colorBackground"
-    tools:context="._login.login.LoginActivity">
-
-    <androidx.constraintlayout.widget.ConstraintLayout
-        android:id="@+id/container"
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:padding="32dp"
-        android:clipChildren="false"
-        android:clipToPadding="false">
-
-        <!-- App Logo or Title -->
-        <TextView
-            android:id="@+id/app_title"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="48dp"
-            android:text="@string/app_name"
-            android:textSize="32sp"
-            android:textStyle="bold"
-            android:textColor="?attr/colorOnBackground"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toTopOf="parent" />
-
-        <TextView
-            android:id="@+id/welcome_text"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="8dp"
-            android:text="Welcome back!"
-            android:textSize="16sp"
-            android:textColor="?attr/colorOnSurfaceVariant"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toBottomOf="@+id/app_title" />
-
-        <!-- Login Form Card -->
-        <androidx.cardview.widget.CardView
-            android:id="@+id/login_card"
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="48dp"
-            app:cardCornerRadius="16dp"
-            app:cardElevation="8dp"
-            app:cardBackgroundColor="?attr/colorSurface"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toBottomOf="@+id/welcome_text">
-
-            <LinearLayout
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:orientation="vertical"
-                android:padding="24dp">
-
-
-
-                <!-- Google Sign-In Button -->
-                <com.google.android.material.button.MaterialButton
-                    android:id="@+id/google_sign_in_button"
-                    android:layout_width="match_parent"
-                    android:layout_height="56dp"
-                    android:text="@string/sign_in_with_google"
-                    android:textColor="?attr/colorOnSurfaceVariant"
-                    android:textSize="16sp"
-                    app:icon="@drawable/ic_google"
-                    app:iconGravity="textStart"
-                    app:iconTint="@null"
-                    app:cornerRadius="28dp"
-                    app:strokeColor="?attr/colorOutline"
-                    app:strokeWidth="1dp"
-                    style="@style/Widget.MaterialComponents.Button.OutlinedButton" />
-
-                <!-- Signed-in management section -->
-                <LinearLayout
-                    android:id="@+id/signed_in_section"
-                    android:layout_width="match_parent"
-                    android:layout_height="wrap_content"
-                    android:orientation="vertical"
-                    android:paddingTop="8dp"
-                    android:visibility="gone">
-
-                    <TextView
-                        android:id="@+id/signed_in_as_text"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:textColor="?attr/colorOnSurface"
-                        android:textSize="14sp"
-                        android:paddingBottom="8dp"
-                        android:text="@string/signed_in_as_placeholder" />
-
-                    <!-- Role selection header -->
-                    <TextView
-                        android:id="@+id/choose_role_text"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:text="@string/choose_account_type"
-                        android:textStyle="bold"
-                        android:textSize="16sp"
-                        android:paddingTop="8dp"
-                        android:paddingBottom="4dp"
-                        android:textColor="?attr/colorOnSurface" />
-
-                    <!-- Role selection radio group -->
-                    <RadioGroup
-                        android:id="@+id/role_group"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:orientation="horizontal">
-
-                        <RadioButton
-                            android:id="@+id/role_supervisor"
-                            android:layout_width="wrap_content"
-                            android:layout_height="wrap_content"
-                            android:text="@string/role_supervisor" />
-
-                        <RadioButton
-                            android:id="@+id/role_aggregator"
-                            android:layout_width="wrap_content"
-                            android:layout_height="wrap_content"
-                            android:layout_marginStart="24dp"
-                            android:text="@string/role_aggregator" />
-                    </RadioGroup>
-
-                    <com.google.android.material.textfield.TextInputLayout
-                        android:id="@+id/aggregator_email_layout"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:layout_marginTop="8dp"
-                        android:hint="@string/aggregator_email_hint"
-                        android:visibility="gone"
-                        style="@style/Theme.InnovaMotionApp.TextInputLayout">
-
-                        <com.google.android.material.textfield.TextInputEditText
-                            android:id="@+id/aggregator_email"
-                            android:layout_width="match_parent"
-                            android:layout_height="wrap_content"
-                            android:inputType="textEmailAddress"
-                            android:autofillHints="emailAddress" />
-
-                    </com.google.android.material.textfield.TextInputLayout>
-
-                    <!-- Proceed button to continue based on selected role -->
-                    <com.google.android.material.button.MaterialButton
-                        android:id="@+id/proceed_button"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:layout_marginTop="12dp"
-                        android:text="@string/proceed"
-                        style="@style/Theme.InnovaMotionApp.Button" />
-
-                    <com.google.android.material.button.MaterialButton
-                        android:id="@+id/sign_out_button"
-                        android:layout_width="match_parent"
-                        android:layout_height="wrap_content"
-                        android:layout_marginTop="8dp"
-                        android:text="@string/sign_out"
-                        style="@style/Theme.InnovaMotionApp.Button.Secondary" />
-
-                </LinearLayout>
-
-            </LinearLayout>
-
-        </androidx.cardview.widget.CardView>
-
-        <!-- Loading Progress -->
-        <ProgressBar
-            android:id="@+id/loading"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:visibility="gone"
-            android:indeterminateTint="?attr/colorPrimary"
-            app:layout_constraintBottom_toBottomOf="@+id/login_card"
-            app:layout_constraintEnd_toEndOf="@+id/login_card"
-            app:layout_constraintStart_toStartOf="@+id/login_card"
-            app:layout_constraintTop_toTopOf="@+id/login_card" />
-
-        <!-- Footer Text -->
-        <TextView
-            android:id="@+id/footer_text"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginTop="24dp"
-            android:layout_marginBottom="24dp"
-            android:text="By signing in, you agree to our Terms of Service and Privacy Policy"
-            android:textSize="12sp"
-            android:textColor="?attr/colorOnSurfaceVariant"
-            android:gravity="center"
-            app:layout_constraintBottom_toBottomOf="parent"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toBottomOf="@+id/login_card"
-            app:layout_constraintVertical_bias="1.0" />
-
-    </androidx.constraintlayout.widget.ConstraintLayout>
-
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fillViewport="true"
+    android:background="?android:attr/colorBackground"
+    tools:context="._login.login.LoginActivity">
+
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:id="@+id/container"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:padding="32dp"
+        android:clipChildren="false"
+        android:clipToPadding="false">
+
+        <!-- App Logo or Title -->
+        <TextView
+            android:id="@+id/app_title"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="48dp"
+            android:text="@string/app_name"
+            android:textSize="32sp"
+            android:textStyle="bold"
+            android:textColor="?attr/colorOnBackground"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent" />
+
+        <TextView
+            android:id="@+id/welcome_text"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="8dp"
+            android:text="Welcome back!"
+            android:textSize="16sp"
+            android:textColor="?attr/colorOnSurfaceVariant"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/app_title" />
+
+        <!-- Login Form Card -->
+        <androidx.cardview.widget.CardView
+            android:id="@+id/login_card"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="48dp"
+            app:cardCornerRadius="16dp"
+            app:cardElevation="8dp"
+            app:cardBackgroundColor="?attr/colorSurface"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/welcome_text">
+
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical"
+                android:padding="24dp">
+
+
+
+                <!-- Google Sign-In Button -->
+                <com.google.android.material.button.MaterialButton
+                    android:id="@+id/google_sign_in_button"
+                    android:layout_width="match_parent"
+                    android:layout_height="56dp"
+                    android:text="@string/sign_in_with_google"
+                    android:textColor="?attr/colorOnSurfaceVariant"
+                    android:textSize="16sp"
+                    app:icon="@drawable/ic_google"
+                    app:iconGravity="textStart"
+                    app:iconTint="@null"
+                    app:cornerRadius="28dp"
+                    app:strokeColor="?attr/colorOutline"
+                    app:strokeWidth="1dp"
+                    style="@style/Widget.MaterialComponents.Button.OutlinedButton" />
+
+                <!-- Signed-in management section -->
+                <LinearLayout
+                    android:id="@+id/signed_in_section"
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:orientation="vertical"
+                    android:paddingTop="8dp"
+                    android:visibility="gone">
+
+                    <TextView
+                        android:id="@+id/signed_in_as_text"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:textColor="?attr/colorOnSurface"
+                        android:textSize="14sp"
+                        android:paddingBottom="8dp"
+                        android:text="@string/signed_in_as_placeholder" />
+
+                    <!-- Role selection header -->
+                    <TextView
+                        android:id="@+id/choose_role_text"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:text="@string/choose_account_type"
+                        android:textStyle="bold"
+                        android:textSize="16sp"
+                        android:paddingTop="8dp"
+                        android:paddingBottom="4dp"
+                        android:textColor="?attr/colorOnSurface" />
+
+                    <!-- Role selection radio group -->
+                    <RadioGroup
+                        android:id="@+id/role_group"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:orientation="horizontal">
+
+                        <RadioButton
+                            android:id="@+id/role_supervisor"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:text="@string/role_supervisor" />
+
+                        <RadioButton
+                            android:id="@+id/role_aggregator"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:layout_marginStart="24dp"
+                            android:text="@string/role_aggregator" />
+                    </RadioGroup>
+
+                    <com.google.android.material.textfield.TextInputLayout
+                        android:id="@+id/aggregator_email_layout"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:layout_marginTop="8dp"
+                        android:hint="@string/aggregator_email_hint"
+                        android:visibility="gone"
+                        style="@style/Theme.InnovaMotionApp.TextInputLayout">
+
+                        <com.google.android.material.textfield.TextInputEditText
+                            android:id="@+id/aggregator_email"
+                            android:layout_width="match_parent"
+                            android:layout_height="wrap_content"
+                            android:inputType="textEmailAddress"
+                            android:autofillHints="emailAddress" />
+
+                    </com.google.android.material.textfield.TextInputLayout>
+
+                    <!-- Proceed button to continue based on selected role -->
+                    <com.google.android.material.button.MaterialButton
+                        android:id="@+id/proceed_button"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:layout_marginTop="12dp"
+                        android:text="@string/proceed"
+                        style="@style/Theme.InnovaMotionApp.Button" />
+
+                    <com.google.android.material.button.MaterialButton
+                        android:id="@+id/sign_out_button"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:layout_marginTop="8dp"
+                        android:text="@string/sign_out"
+                        style="@style/Theme.InnovaMotionApp.Button.Secondary" />
+
+                </LinearLayout>
+
+            </LinearLayout>
+
+        </androidx.cardview.widget.CardView>
+
+        <!-- Loading Progress -->
+        <ProgressBar
+            android:id="@+id/loading"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:visibility="gone"
+            android:indeterminateTint="?attr/colorPrimary"
+            app:layout_constraintBottom_toBottomOf="@+id/login_card"
+            app:layout_constraintEnd_toEndOf="@+id/login_card"
+            app:layout_constraintStart_toStartOf="@+id/login_card"
+            app:layout_constraintTop_toTopOf="@+id/login_card" />
+
+        <!-- Footer Text -->
+        <TextView
+            android:id="@+id/footer_text"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="24dp"
+            android:layout_marginBottom="24dp"
+            android:text="By signing in, you agree to our Terms of Service and Privacy Policy"
+            android:textSize="12sp"
+            android:textColor="?attr/colorOnSurfaceVariant"
+            android:gravity="center"
+            app:layout_constraintBottom_toBottomOf="parent"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toBottomOf="@+id/login_card"
+            app:layout_constraintVertical_bias="1.0" />
+
+    </androidx.constraintlayout.widget.ConstraintLayout>
+
 </ScrollView>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/layout/autocomplete_item.xml b/InnovaMotionApp/app/src/main/res/layout/autocomplete_item.xml
index 73430e1..9de46e7 100644
--- a/InnovaMotionApp/app/src/main/res/layout/autocomplete_item.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/autocomplete_item.xml
@@ -1,10 +1,10 @@
-<?xml version="1.0" encoding="utf-8"?>
-<TextView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:padding="16dp"
-    android:textSize="16sp"
-    android:textColor="@color/primary_text"
-    android:background="?android:attr/selectableItemBackground"
-    android:singleLine="true"
-    android:ellipsize="end" />
+<?xml version="1.0" encoding="utf-8"?>
+<TextView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:padding="16dp"
+    android:textSize="16sp"
+    android:textColor="@color/primary_text"
+    android:background="?android:attr/selectableItemBackground"
+    android:singleLine="true"
+    android:ellipsize="end" />
diff --git a/InnovaMotionApp/app/src/main/res/layout/bt_connected_activity.xml b/InnovaMotionApp/app/src/main/res/layout/bt_connected_activity.xml
index f03275d..8f7f830 100644
--- a/InnovaMotionApp/app/src/main/res/layout/bt_connected_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/bt_connected_activity.xml
@@ -1,69 +1,69 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:padding="16dp"
-    tools:context=".activities.BtConnectedActivity">
-
-    <TextView
-        android:id="@+id/descriptionTextView"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:gravity="center"
-        android:text="Mihaita sta pe scaun"
-        android:textSize="18sp"
-        android:textStyle="bold"
-        android:padding="8dp"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-    <androidx.constraintlayout.widget.ConstraintLayout
-        android:id="@+id/riskContainer"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:padding="8dp"
-        app:layout_constraintTop_toBottomOf="@id/descriptionTextView"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent">
-
-        <TextView
-            android:id="@+id/riskLabelTextView"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="risc"
-            android:textSize="16sp"
-            app:layout_constraintStart_toStartOf="parent"
-            app:layout_constraintTop_toTopOf="parent"
-            app:layout_constraintBottom_toBottomOf="parent" />
-
-        <TextView
-            android:id="@+id/riskValueTextView"
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_marginStart="8dp"
-            android:layout_marginEnd="8dp"
-            android:background="#CCFFCC"
-            android:gravity="center"
-            android:padding="4dp"
-            android:text="minim"
-            android:textSize="16sp"
-            app:layout_constraintStart_toEndOf="@id/riskLabelTextView"
-            app:layout_constraintEnd_toEndOf="parent"
-            app:layout_constraintTop_toTopOf="parent"
-            app:layout_constraintBottom_toBottomOf="parent" />
-    </androidx.constraintlayout.widget.ConstraintLayout>
-
-    <VideoView
-        android:id="@+id/videoView"
-        android:layout_width="0dp"
-        android:layout_height="0dp"
-        android:layout_marginTop="16dp"
-        app:layout_constraintDimensionRatio="4:5"
-        app:layout_constraintTop_toBottomOf="@id/riskContainer"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintBottom_toBottomOf="parent" />
-</androidx.constraintlayout.widget.ConstraintLayout>
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:padding="16dp"
+    tools:context=".activities.BtConnectedActivity">
+
+    <TextView
+        android:id="@+id/descriptionTextView"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:gravity="center"
+        android:text="Mihaita sta pe scaun"
+        android:textSize="18sp"
+        android:textStyle="bold"
+        android:padding="8dp"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <androidx.constraintlayout.widget.ConstraintLayout
+        android:id="@+id/riskContainer"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:padding="8dp"
+        app:layout_constraintTop_toBottomOf="@id/descriptionTextView"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent">
+
+        <TextView
+            android:id="@+id/riskLabelTextView"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="risc"
+            android:textSize="16sp"
+            app:layout_constraintStart_toStartOf="parent"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toBottomOf="parent" />
+
+        <TextView
+            android:id="@+id/riskValueTextView"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:layout_marginEnd="8dp"
+            android:background="#CCFFCC"
+            android:gravity="center"
+            android:padding="4dp"
+            android:text="minim"
+            android:textSize="16sp"
+            app:layout_constraintStart_toEndOf="@id/riskLabelTextView"
+            app:layout_constraintEnd_toEndOf="parent"
+            app:layout_constraintTop_toTopOf="parent"
+            app:layout_constraintBottom_toBottomOf="parent" />
+    </androidx.constraintlayout.widget.ConstraintLayout>
+
+    <VideoView
+        android:id="@+id/videoView"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        android:layout_marginTop="16dp"
+        app:layout_constraintDimensionRatio="4:5"
+        app:layout_constraintTop_toBottomOf="@id/riskContainer"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintBottom_toBottomOf="parent" />
+</androidx.constraintlayout.widget.ConstraintLayout>
diff --git a/InnovaMotionApp/app/src/main/res/layout/bt_settings_activity.xml b/InnovaMotionApp/app/src/main/res/layout/bt_settings_activity.xml
index 98b74f9..b06ce44 100644
--- a/InnovaMotionApp/app/src/main/res/layout/bt_settings_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/bt_settings_activity.xml
@@ -1,82 +1,82 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:fillViewport="true">
-
-<androidx.constraintlayout.widget.ConstraintLayout
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    tools:context=".activities.BtSettingsActivity"
-    android:padding="16dp">
-
-    <!-- Sign out button in top-right corner -->
-    <com.google.android.material.button.MaterialButton
-        android:id="@+id/sign_out_button"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:text="@string/sign_out"
-        android:textSize="12sp"
-        app:icon="@android:drawable/ic_menu_close_clear_cancel"
-        app:iconSize="16dp"
-        style="@style/Theme.InnovaMotionApp.Button.Secondary"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-    <LinearLayout
-        android:id="@+id/mainContainer"
-        android:layout_width="0dp"
-        android:layout_height="0dp"
-        android:orientation="vertical"
-        android:gravity="center_horizontal"
-        android:padding="8dp"
-        android:layout_marginTop="8dp"
-        app:layout_constraintTop_toBottomOf="@id/sign_out_button"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent">
-
-        <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:orientation="horizontal"
-            android:gravity="center_vertical"
-            android:layout_marginBottom="16dp">
-
-            <TextView
-                android:id="@+id/textView2"
-                android:layout_width="0dp"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"
-                android:text="Numele copilului:"
-                android:textSize="18sp" />
-
-            <EditText
-                android:id="@+id/inputChildName"
-                android:layout_width="0dp"
-                android:layout_height="wrap_content"
-                android:layout_weight="1"
-                android:hint="Popescu Mihaita"
-                android:inputType="textPersonName" />
-        </LinearLayout>
-
-        <Button
-            android:id="@+id/btConnection"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:enabled="false"
-            android:text="Conectare"
-            android:layout_gravity="center_horizontal"
-            android:layout_marginBottom="16dp" />
-
-        <ListView
-            android:id="@+id/deviceListRecyclerView"
-            android:layout_width="match_parent"
-            android:layout_height="0dp"
-            android:layout_weight="1" />
-    </LinearLayout>
-</androidx.constraintlayout.widget.ConstraintLayout>
-
-</ScrollView>
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fillViewport="true">
+
+<androidx.constraintlayout.widget.ConstraintLayout
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    tools:context=".activities.BtSettingsActivity"
+    android:padding="16dp">
+
+    <!-- Sign out button in top-right corner -->
+    <com.google.android.material.button.MaterialButton
+        android:id="@+id/sign_out_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/sign_out"
+        android:textSize="12sp"
+        app:icon="@android:drawable/ic_menu_close_clear_cancel"
+        app:iconSize="16dp"
+        style="@style/Theme.InnovaMotionApp.Button.Secondary"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <LinearLayout
+        android:id="@+id/mainContainer"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        android:orientation="vertical"
+        android:gravity="center_horizontal"
+        android:padding="8dp"
+        android:layout_marginTop="8dp"
+        app:layout_constraintTop_toBottomOf="@id/sign_out_button"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent">
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="horizontal"
+            android:gravity="center_vertical"
+            android:layout_marginBottom="16dp">
+
+            <TextView
+                android:id="@+id/textView2"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:text="Numele copilului:"
+                android:textSize="18sp" />
+
+            <EditText
+                android:id="@+id/inputChildName"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_weight="1"
+                android:hint="Popescu Mihaita"
+                android:inputType="textPersonName" />
+        </LinearLayout>
+
+        <Button
+            android:id="@+id/btConnection"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:enabled="false"
+            android:text="Conectare"
+            android:layout_gravity="center_horizontal"
+            android:layout_marginBottom="16dp" />
+
+        <ListView
+            android:id="@+id/deviceListRecyclerView"
+            android:layout_width="match_parent"
+            android:layout_height="0dp"
+            android:layout_weight="1" />
+    </LinearLayout>
+</androidx.constraintlayout.widget.ConstraintLayout>
+
+</ScrollView>
diff --git a/InnovaMotionApp/app/src/main/res/layout/content_main.xml b/InnovaMotionApp/app/src/main/res/layout/content_main.xml
index e416e1c..d80d2bb 100644
--- a/InnovaMotionApp/app/src/main/res/layout/content_main.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/content_main.xml
@@ -1,19 +1,19 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    app:layout_behavior="@string/appbar_scrolling_view_behavior">
-
-    <fragment
-        android:id="@+id/nav_host_fragment_content_main"
-        android:name="androidx.navigation.fragment.NavHostFragment"
-        android:layout_width="0dp"
-        android:layout_height="0dp"
-        app:defaultNavHost="true"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toTopOf="parent"
-        app:navGraph="@navigation/nav_graph" />
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    app:layout_behavior="@string/appbar_scrolling_view_behavior">
+
+    <fragment
+        android:id="@+id/nav_host_fragment_content_main"
+        android:name="androidx.navigation.fragment.NavHostFragment"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        app:defaultNavHost="true"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toTopOf="parent"
+        app:navGraph="@navigation/nav_graph" />
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/layout/energy_consumption_activity.xml b/InnovaMotionApp/app/src/main/res/layout/energy_consumption_activity.xml
index 45150e6..38390bd 100644
--- a/InnovaMotionApp/app/src/main/res/layout/energy_consumption_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/energy_consumption_activity.xml
@@ -1,60 +1,60 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:padding="16dp"
-    tools:context=".activities.EnergyConsumptionActivity">
-
-    <!-- Title -->
-    <TextView
-        android:id="@+id/textView3"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:text="Activitati"
-        android:textSize="20sp"
-        android:gravity="center"
-        android:textStyle="bold"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-    <!-- Scrollable content -->
-    <ScrollView
-        android:id="@+id/scrollView"
-        android:layout_width="0dp"
-        android:layout_height="0dp"
-        android:fillViewport="true"
-        android:overScrollMode="ifContentScrolls"
-        app:layout_constraintTop_toBottomOf="@id/textView3"
-        app:layout_constraintBottom_toTopOf="@id/selectedDateRange"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        android:layout_marginTop="12dp"
-        android:layout_marginBottom="12dp">
-
-        <LinearLayout
-            android:id="@+id/parentLayout"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical"
-            android:padding="8dp" />
-    </ScrollView>
-
-    <!-- Date range display -->
-    <TextView
-        android:id="@+id/selectedDateRange"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:text="12/01/2025 12:00:12 - 12/01/2025 15:48:37"
-        android:textAlignment="center"
-        android:textSize="14sp"
-        android:paddingTop="8dp"
-        android:paddingBottom="8dp"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-</androidx.constraintlayout.widget.ConstraintLayout>
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:padding="16dp"
+    tools:context=".activities.EnergyConsumptionActivity">
+
+    <!-- Title -->
+    <TextView
+        android:id="@+id/textView3"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:text="Activitati"
+        android:textSize="20sp"
+        android:gravity="center"
+        android:textStyle="bold"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <!-- Scrollable content -->
+    <ScrollView
+        android:id="@+id/scrollView"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        android:fillViewport="true"
+        android:overScrollMode="ifContentScrolls"
+        app:layout_constraintTop_toBottomOf="@id/textView3"
+        app:layout_constraintBottom_toTopOf="@id/selectedDateRange"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        android:layout_marginTop="12dp"
+        android:layout_marginBottom="12dp">
+
+        <LinearLayout
+            android:id="@+id/parentLayout"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:padding="8dp" />
+    </ScrollView>
+
+    <!-- Date range display -->
+    <TextView
+        android:id="@+id/selectedDateRange"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:text="12/01/2025 12:00:12 - 12/01/2025 15:48:37"
+        android:textAlignment="center"
+        android:textSize="14sp"
+        android:paddingTop="8dp"
+        android:paddingBottom="8dp"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+</androidx.constraintlayout.widget.ConstraintLayout>
diff --git a/InnovaMotionApp/app/src/main/res/layout/item_person_name.xml b/InnovaMotionApp/app/src/main/res/layout/item_person_name.xml
index 5647790..31361d3 100644
--- a/InnovaMotionApp/app/src/main/res/layout/item_person_name.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/item_person_name.xml
@@ -48,6 +48,18 @@
             android:ellipsize="end"
             android:layout_marginTop="2dp" />
 
+        <!-- Supervisor Assignment (visible when assigned) -->
+        <TextView
+            android:id="@+id/supervisorText"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="11sp"
+            android:textColor="?attr/colorPrimary"
+            android:maxLines="1"
+            android:ellipsize="end"
+            android:layout_marginTop="2dp"
+            android:visibility="gone" />
+
     </LinearLayout>
 
     <!-- Edit Button -->
diff --git a/InnovaMotionApp/app/src/main/res/layout/main_activity.xml b/InnovaMotionApp/app/src/main/res/layout/main_activity.xml
index 45e56eb..347c124 100644
--- a/InnovaMotionApp/app/src/main/res/layout/main_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/main_activity.xml
@@ -1,92 +1,92 @@
-<?xml version="1.0" encoding="utf-8"?>
-<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:fillViewport="true">
-
-<androidx.constraintlayout.widget.ConstraintLayout
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    tools:context=".activities.MainActivity">
-
-    <!-- Sign out button in top-right corner -->
-    <com.google.android.material.button.MaterialButton
-        android:id="@+id/sign_out_button"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_margin="16dp"
-        android:text="@string/sign_out"
-        android:textSize="12sp"
-        app:icon="@android:drawable/ic_menu_close_clear_cancel"
-        app:iconSize="16dp"
-        style="@style/Theme.InnovaMotionApp.Button.Secondary"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-    <!-- App title -->
-    <TextView
-        android:id="@+id/app_title"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        
-        android:text="@string/app_name"
-        android:textSize="28sp"
-        android:textStyle="bold"
-        android:textColor="?attr/colorOnBackground"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintVertical_bias="0.2" />
-
-    <com.google.android.material.button.MaterialButton
-        android:id="@+id/button1"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:onClick="LaunchMonitoring"
-        android:layout_marginTop="16dp"
-        android:text="Monitorizare"
-        style="@style/Theme.InnovaMotionApp.Button"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toBottomOf="@id/app_title" />
-
-    <com.google.android.material.button.MaterialButton
-        android:id="@+id/button2"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="16dp"
-        android:text="Afisare statistica"
-        android:onClick="LaunchStatistics"
-        style="@style/Theme.InnovaMotionApp.Button"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toBottomOf="@id/button1" />
-
-    <com.google.android.material.button.MaterialButton
-        android:id="@+id/button3"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="16dp"
-        android:text="Afisare activitati"
-        android:onClick="LaunchTimelapse"
-        style="@style/Theme.InnovaMotionApp.Button"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toBottomOf="@id/button2" />
-    <com.google.android.material.button.MaterialButton
-        android:id="@+id/button4"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="16dp"
-        android:text="Consum energetic"
-        android:onClick="LaunchEnergyConsumption"
-        style="@style/Theme.InnovaMotionApp.Button"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toBottomOf="@id/button3" />
-</androidx.constraintlayout.widget.ConstraintLayout>
-
+<?xml version="1.0" encoding="utf-8"?>
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:fillViewport="true">
+
+<androidx.constraintlayout.widget.ConstraintLayout
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    tools:context=".activities.MainActivity">
+
+    <!-- Sign out button in top-right corner -->
+    <com.google.android.material.button.MaterialButton
+        android:id="@+id/sign_out_button"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="16dp"
+        android:text="@string/sign_out"
+        android:textSize="12sp"
+        app:icon="@android:drawable/ic_menu_close_clear_cancel"
+        app:iconSize="16dp"
+        style="@style/Theme.InnovaMotionApp.Button.Secondary"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <!-- App title -->
+    <TextView
+        android:id="@+id/app_title"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        
+        android:text="@string/app_name"
+        android:textSize="28sp"
+        android:textStyle="bold"
+        android:textColor="?attr/colorOnBackground"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintVertical_bias="0.2" />
+
+    <com.google.android.material.button.MaterialButton
+        android:id="@+id/button1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:onClick="LaunchMonitoring"
+        android:layout_marginTop="16dp"
+        android:text="Monitorizare"
+        style="@style/Theme.InnovaMotionApp.Button"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@id/app_title" />
+
+    <com.google.android.material.button.MaterialButton
+        android:id="@+id/button2"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp"
+        android:text="Afisare statistica"
+        android:onClick="LaunchStatistics"
+        style="@style/Theme.InnovaMotionApp.Button"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@id/button1" />
+
+    <com.google.android.material.button.MaterialButton
+        android:id="@+id/button3"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp"
+        android:text="Afisare activitati"
+        android:onClick="LaunchTimelapse"
+        style="@style/Theme.InnovaMotionApp.Button"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@id/button2" />
+    <com.google.android.material.button.MaterialButton
+        android:id="@+id/button4"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp"
+        android:text="Consum energetic"
+        android:onClick="LaunchEnergyConsumption"
+        style="@style/Theme.InnovaMotionApp.Button"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@id/button3" />
+</androidx.constraintlayout.widget.ConstraintLayout>
+
 </ScrollView>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/layout/nearby_device_layout.xml b/InnovaMotionApp/app/src/main/res/layout/nearby_device_layout.xml
index c6fe5cb..1dda681 100644
--- a/InnovaMotionApp/app/src/main/res/layout/nearby_device_layout.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/nearby_device_layout.xml
@@ -1,33 +1,33 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    android:id="@+id/scanDeviceContainer"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:background="?android:attr/selectableItemBackground"
-    android:clickable="true"
-    android:focusable="true"
-    android:orientation="vertical"
-    android:padding="10dp"
-    android:translationZ="90dp">
-
-    <TextView
-        android:id="@+id/tvDeviceName"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:clickable="false"
-        android:focusable="false"
-        android:text="test_devName"
-        android:textSize="20sp" />
-
-    <TextView
-        android:id="@+id/tvDeviceAddress"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:clickable="false"
-        android:focusable="false"
-        android:text="test_devAddress"
-        android:textSize="20sp" />
-
-
-</LinearLayout>
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/scanDeviceContainer"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="?android:attr/selectableItemBackground"
+    android:clickable="true"
+    android:focusable="true"
+    android:orientation="vertical"
+    android:padding="10dp"
+    android:translationZ="90dp">
+
+    <TextView
+        android:id="@+id/tvDeviceName"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:clickable="false"
+        android:focusable="false"
+        android:text="test_devName"
+        android:textSize="20sp" />
+
+    <TextView
+        android:id="@+id/tvDeviceAddress"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:clickable="false"
+        android:focusable="false"
+        android:text="test_devAddress"
+        android:textSize="20sp" />
+
+
+</LinearLayout>
diff --git a/InnovaMotionApp/app/src/main/res/layout/photo_item.xml b/InnovaMotionApp/app/src/main/res/layout/photo_item.xml
index 86ca6ac..fb5f129 100644
--- a/InnovaMotionApp/app/src/main/res/layout/photo_item.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/photo_item.xml
@@ -1,13 +1,13 @@
-<?xml version="1.0" encoding="utf-8"?>
-<FrameLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-
-    <ImageView
-        android:id="@+id/photoImageView"
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:scaleType="centerCrop"
-        android:adjustViewBounds="true" />
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <ImageView
+        android:id="@+id/photoImageView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:scaleType="centerCrop"
+        android:adjustViewBounds="true" />
 </FrameLayout>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/layout/start_activity.xml b/InnovaMotionApp/app/src/main/res/layout/start_activity.xml
index 9b44bd3..ff20f70 100644
--- a/InnovaMotionApp/app/src/main/res/layout/start_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/start_activity.xml
@@ -1,44 +1,44 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:id="@+id/main"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    tools:context=".activities.StartActivity">
-
-    <TextView
-        android:id="@+id/textView"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:text="Innova Motion App"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintVertical_bias="0.183" />
-
-    <Button
-        android:id="@+id/LaunchMainActivity"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:onClick="mainActivity"
-        android:text="Mon_Pedo"
-        app:layout_constraintBottom_toTopOf="@+id/loginActivity"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toBottomOf="@+id/textView"
-        app:layout_constraintVertical_bias="0.74" />
-
-    <Button
-        android:id="@+id/loginActivity"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:text="LOGIN"
-        app:layout_constraintTop_toBottomOf="@id/LaunchMainActivity"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintVertical_bias="0.85" />
-
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/main"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".activities.StartActivity">
+
+    <TextView
+        android:id="@+id/textView"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="Innova Motion App"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintVertical_bias="0.183" />
+
+    <Button
+        android:id="@+id/LaunchMainActivity"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:onClick="mainActivity"
+        android:text="Mon_Pedo"
+        app:layout_constraintBottom_toTopOf="@+id/loginActivity"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@+id/textView"
+        app:layout_constraintVertical_bias="0.74" />
+
+    <Button
+        android:id="@+id/loginActivity"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="LOGIN"
+        app:layout_constraintTop_toBottomOf="@id/LaunchMainActivity"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintVertical_bias="0.85" />
+
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/layout/statistics_activity.xml b/InnovaMotionApp/app/src/main/res/layout/statistics_activity.xml
index 877f48c..1591000 100644
--- a/InnovaMotionApp/app/src/main/res/layout/statistics_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/statistics_activity.xml
@@ -1,61 +1,61 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:padding="16dp"
-    tools:context=".activities.StatisticsActivity">
-
-    <!-- Title -->
-    <TextView
-        android:id="@+id/textView3"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:text="Statistica pentru ultimul dispozitiv conectat"
-        android:textSize="18sp"
-        android:textStyle="bold"
-        android:textColor="?attr/colorOnBackground"
-        android:gravity="center"
-        android:padding="8dp"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-    <!-- Pie Chart Container -->
-    <com.github.mikephil.charting.charts.PieChart
-        android:id="@+id/pieChart"
-        android:layout_width="0dp"
-        android:layout_height="0dp"
-        android:minHeight="200dp"
-        app:layout_constraintTop_toBottomOf="@id/textView3"
-        app:layout_constraintBottom_toTopOf="@id/dateRangePickerButton"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        android:layout_marginVertical="16dp" />
-
-    <!-- Date Picker Button -->
-    <Button
-        android:id="@+id/dateRangePickerButton"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:text="Select Date Range"
-        app:layout_constraintBottom_toTopOf="@id/selectedDateRange"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-    <!-- Selected Date Range Display -->
-    <TextView
-        android:id="@+id/selectedDateRange"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:text="Selected Date Range"
-        android:textAlignment="center"
-        android:paddingTop="8dp"
-        android:paddingBottom="8dp"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-</androidx.constraintlayout.widget.ConstraintLayout>
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:padding="16dp"
+    tools:context=".activities.StatisticsActivity">
+
+    <!-- Title -->
+    <TextView
+        android:id="@+id/textView3"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:text="Statistica pentru ultimul dispozitiv conectat"
+        android:textSize="18sp"
+        android:textStyle="bold"
+        android:textColor="?attr/colorOnBackground"
+        android:gravity="center"
+        android:padding="8dp"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <!-- Pie Chart Container -->
+    <com.github.mikephil.charting.charts.PieChart
+        android:id="@+id/pieChart"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        android:minHeight="200dp"
+        app:layout_constraintTop_toBottomOf="@id/textView3"
+        app:layout_constraintBottom_toTopOf="@id/dateRangePickerButton"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        android:layout_marginVertical="16dp" />
+
+    <!-- Date Picker Button -->
+    <Button
+        android:id="@+id/dateRangePickerButton"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:text="Select Date Range"
+        app:layout_constraintBottom_toTopOf="@id/selectedDateRange"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+    <!-- Selected Date Range Display -->
+    <TextView
+        android:id="@+id/selectedDateRange"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:text="Selected Date Range"
+        android:textAlignment="center"
+        android:paddingTop="8dp"
+        android:paddingBottom="8dp"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+</androidx.constraintlayout.widget.ConstraintLayout>
diff --git a/InnovaMotionApp/app/src/main/res/layout/timelaps_activity.xml b/InnovaMotionApp/app/src/main/res/layout/timelaps_activity.xml
index 436903c..bd707b1 100644
--- a/InnovaMotionApp/app/src/main/res/layout/timelaps_activity.xml
+++ b/InnovaMotionApp/app/src/main/res/layout/timelaps_activity.xml
@@ -1,124 +1,124 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:padding="16dp"
-    tools:context=".activities.TimeLapseActivity">
-
-    <!-- Title -->
-    <TextView
-        android:id="@+id/textView3"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:text="Activitati"
-        android:textSize="18sp"
-        android:textStyle="bold"
-        android:gravity="center"
-        app:layout_constraintTop_toTopOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"/>
-
-    <!-- Time Label -->
-    <TextView
-        android:id="@+id/photoTime"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:text="Time: 00:00"
-        android:textSize="16sp"
-        app:layout_constraintTop_toBottomOf="@id/textView3"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        android:layout_marginTop="12dp" />
-
-    <!-- ImageView -->
-    <ImageView
-        android:id="@+id/imageView"
-        android:layout_width="0dp"
-        android:layout_height="0dp"
-        android:scaleType="fitCenter"
-        android:contentDescription="Displayed Image"
-        app:layout_constraintTop_toBottomOf="@id/photoTime"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintDimensionRatio="H,16:9"
-        app:layout_constraintHeight_default="percent"
-        app:layout_constraintHeight_percent="0.35"
-        android:layout_marginTop="8dp" />
-
-    <!-- SeekBar for timeline -->
-    <SeekBar
-        android:id="@+id/seekBar"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="8dp"
-        app:layout_constraintTop_toBottomOf="@id/imageView"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"/>
-
-    <!-- Speed Label -->
-    <TextView
-        android:id="@+id/speedLabel"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:text="Speed: 5"
-        app:layout_constraintTop_toBottomOf="@id/seekBar"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        android:layout_marginTop="8dp"/>
-
-    <!-- Speed SeekBar -->
-    <SeekBar
-        android:id="@+id/speedSeekBar"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        app:layout_constraintTop_toBottomOf="@id/speedLabel"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        android:layout_marginTop="4dp"/>
-
-    <!-- Start & Stop Buttons -->
-    <LinearLayout
-        android:id="@+id/buttonRow"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:orientation="horizontal"
-        android:layout_marginTop="12dp"
-        app:layout_constraintTop_toBottomOf="@id/speedSeekBar"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent">
-
-        <Button
-            android:id="@+id/startButton"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Start"/>
-
-        <Space
-            android:layout_width="32dp"
-            android:layout_height="wrap_content"/>
-
-        <Button
-            android:id="@+id/stopButton"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:enabled="false"
-            android:text="Stop"/>
-    </LinearLayout>
-
-    <!-- Date Range -->
-    <TextView
-        android:id="@+id/selectedDateRange"
-        android:layout_width="0dp"
-        android:layout_height="wrap_content"
-        android:text="12/01/2025 12:00:12 - 12/01/2025 15:48:37"
-        android:textAlignment="center"
-        android:paddingTop="12dp"
-        app:layout_constraintTop_toBottomOf="@id/buttonRow"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintEnd_toEndOf="parent" />
-
-</androidx.constraintlayout.widget.ConstraintLayout>
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:padding="16dp"
+    tools:context=".activities.TimeLapseActivity">
+
+    <!-- Title -->
+    <TextView
+        android:id="@+id/textView3"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:text="Activitati"
+        android:textSize="18sp"
+        android:textStyle="bold"
+        android:gravity="center"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"/>
+
+    <!-- Time Label -->
+    <TextView
+        android:id="@+id/photoTime"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="Time: 00:00"
+        android:textSize="16sp"
+        app:layout_constraintTop_toBottomOf="@id/textView3"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        android:layout_marginTop="12dp" />
+
+    <!-- ImageView -->
+    <ImageView
+        android:id="@+id/imageView"
+        android:layout_width="0dp"
+        android:layout_height="0dp"
+        android:scaleType="fitCenter"
+        android:contentDescription="Displayed Image"
+        app:layout_constraintTop_toBottomOf="@id/photoTime"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintDimensionRatio="H,16:9"
+        app:layout_constraintHeight_default="percent"
+        app:layout_constraintHeight_percent="0.35"
+        android:layout_marginTop="8dp" />
+
+    <!-- SeekBar for timeline -->
+    <SeekBar
+        android:id="@+id/seekBar"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="8dp"
+        app:layout_constraintTop_toBottomOf="@id/imageView"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"/>
+
+    <!-- Speed Label -->
+    <TextView
+        android:id="@+id/speedLabel"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="Speed: 5"
+        app:layout_constraintTop_toBottomOf="@id/seekBar"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        android:layout_marginTop="8dp"/>
+
+    <!-- Speed SeekBar -->
+    <SeekBar
+        android:id="@+id/speedSeekBar"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toBottomOf="@id/speedLabel"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        android:layout_marginTop="4dp"/>
+
+    <!-- Start & Stop Buttons -->
+    <LinearLayout
+        android:id="@+id/buttonRow"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:layout_marginTop="12dp"
+        app:layout_constraintTop_toBottomOf="@id/speedSeekBar"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent">
+
+        <Button
+            android:id="@+id/startButton"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="Start"/>
+
+        <Space
+            android:layout_width="32dp"
+            android:layout_height="wrap_content"/>
+
+        <Button
+            android:id="@+id/stopButton"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:enabled="false"
+            android:text="Stop"/>
+    </LinearLayout>
+
+    <!-- Date Range -->
+    <TextView
+        android:id="@+id/selectedDateRange"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:text="12/01/2025 12:00:12 - 12/01/2025 15:48:37"
+        android:textAlignment="center"
+        android:paddingTop="12dp"
+        app:layout_constraintTop_toBottomOf="@id/buttonRow"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent" />
+
+</androidx.constraintlayout.widget.ConstraintLayout>
diff --git a/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher.xml b/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher.xml
index 6f3b755..3766e68 100644
--- a/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher.xml
+++ b/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher.xml
@@ -1,6 +1,6 @@
-<?xml version="1.0" encoding="utf-8"?>
-<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
-    <background android:drawable="@drawable/ic_launcher_background" />
-    <foreground android:drawable="@drawable/ic_launcher_foreground" />
-    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
 </adaptive-icon>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml b/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
index 6f3b755..3766e68 100644
--- a/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
+++ b/InnovaMotionApp/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
@@ -1,6 +1,6 @@
-<?xml version="1.0" encoding="utf-8"?>
-<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
-    <background android:drawable="@drawable/ic_launcher_background" />
-    <foreground android:drawable="@drawable/ic_launcher_foreground" />
-    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
 </adaptive-icon>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/navigation/nav_graph.xml b/InnovaMotionApp/app/src/main/res/navigation/nav_graph.xml
index b33ad2f..dcc210c 100644
--- a/InnovaMotionApp/app/src/main/res/navigation/nav_graph.xml
+++ b/InnovaMotionApp/app/src/main/res/navigation/nav_graph.xml
@@ -1,28 +1,28 @@
-<?xml version="1.0" encoding="utf-8"?>
-<navigation xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:id="@+id/nav_graph"
-    app:startDestination="@id/FirstFragment">
-
-    <fragment
-        android:id="@+id/FirstFragment"
-        android:name="com.melisa.innovamotionapp.FirstFragment"
-        android:label="@string/first_fragment_label"
-        tools:layout="@layout/fragment_first">
-
-        <action
-            android:id="@+id/action_FirstFragment_to_SecondFragment"
-            app:destination="@id/SecondFragment" />
-    </fragment>
-    <fragment
-        android:id="@+id/SecondFragment"
-        android:name="com.melisa.innovamotionapp.SecondFragment"
-        android:label="@string/second_fragment_label"
-        tools:layout="@layout/fragment_second">
-
-        <action
-            android:id="@+id/action_SecondFragment_to_FirstFragment"
-            app:destination="@id/FirstFragment" />
-    </fragment>
+<?xml version="1.0" encoding="utf-8"?>
+<navigation xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/nav_graph"
+    app:startDestination="@id/FirstFragment">
+
+    <fragment
+        android:id="@+id/FirstFragment"
+        android:name="com.melisa.innovamotionapp.FirstFragment"
+        android:label="@string/first_fragment_label"
+        tools:layout="@layout/fragment_first">
+
+        <action
+            android:id="@+id/action_FirstFragment_to_SecondFragment"
+            app:destination="@id/SecondFragment" />
+    </fragment>
+    <fragment
+        android:id="@+id/SecondFragment"
+        android:name="com.melisa.innovamotionapp.SecondFragment"
+        android:label="@string/second_fragment_label"
+        tools:layout="@layout/fragment_second">
+
+        <action
+            android:id="@+id/action_SecondFragment_to_FirstFragment"
+            app:destination="@id/FirstFragment" />
+    </fragment>
 </navigation>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values-land/dimens.xml b/InnovaMotionApp/app/src/main/res/values-land/dimens.xml
index a405d47..9f7d96c 100644
--- a/InnovaMotionApp/app/src/main/res/values-land/dimens.xml
+++ b/InnovaMotionApp/app/src/main/res/values-land/dimens.xml
@@ -1,4 +1,4 @@
-<resources>
-    <dimen name="fab_margin">48dp</dimen>
-    <dimen name="activity_horizontal_margin">48dp</dimen>
+<resources>
+    <dimen name="fab_margin">48dp</dimen>
+    <dimen name="activity_horizontal_margin">48dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values-night/themes.xml b/InnovaMotionApp/app/src/main/res/values-night/themes.xml
index f535ed3..5592cf0 100644
--- a/InnovaMotionApp/app/src/main/res/values-night/themes.xml
+++ b/InnovaMotionApp/app/src/main/res/values-night/themes.xml
@@ -1,53 +1,53 @@
-<resources xmlns:tools="http://schemas.android.com/tools">
-    <!-- Base application theme for Dark Mode -->
-    <style name="Base.Theme.InnovaMotionApp" parent="Theme.Material3.DayNight.NoActionBar">
-        <!-- Primary Brand Colors -->
-        <item name="colorPrimary">@color/md_theme_dark_primary</item>
-        <item name="colorOnPrimary">@color/md_theme_dark_onPrimary</item>
-        <item name="colorPrimaryContainer">@color/md_theme_dark_primaryContainer</item>
-        <item name="colorOnPrimaryContainer">@color/md_theme_dark_onPrimaryContainer</item>
-        
-        <!-- Secondary Colors -->
-        <item name="colorSecondary">@color/md_theme_dark_secondary</item>
-        <item name="colorOnSecondary">@color/md_theme_dark_onSecondary</item>
-        <item name="colorSecondaryContainer">@color/md_theme_dark_secondaryContainer</item>
-        <item name="colorOnSecondaryContainer">@color/md_theme_dark_onSecondaryContainer</item>
-        
-        <!-- Tertiary Colors -->
-        <item name="colorTertiary">@color/md_theme_dark_tertiary</item>
-        <item name="colorOnTertiary">@color/md_theme_dark_onTertiary</item>
-        <item name="colorTertiaryContainer">@color/md_theme_dark_tertiaryContainer</item>
-        <item name="colorOnTertiaryContainer">@color/md_theme_dark_onTertiaryContainer</item>
-        
-        <!-- Error Colors -->
-        <item name="colorError">@color/md_theme_dark_error</item>
-        <item name="colorOnError">@color/md_theme_dark_onError</item>
-        <item name="colorErrorContainer">@color/md_theme_dark_errorContainer</item>
-        <item name="colorOnErrorContainer">@color/md_theme_dark_onErrorContainer</item>
-        
-        <!-- Background & Surface -->
-        <item name="android:colorBackground">@color/md_theme_dark_background</item>
-        <item name="colorOnBackground">@color/md_theme_dark_onBackground</item>
-        <item name="colorSurface">@color/md_theme_dark_surface</item>
-        <item name="colorOnSurface">@color/md_theme_dark_onSurface</item>
-        <item name="colorSurfaceVariant">@color/md_theme_dark_surfaceVariant</item>
-        <item name="colorOnSurfaceVariant">@color/md_theme_dark_onSurfaceVariant</item>
-        
-        <!-- Outline & Other -->
-        <item name="colorOutline">@color/md_theme_dark_outline</item>
-        <item name="colorOutlineVariant">@color/md_theme_dark_outlineVariant</item>
-        <item name="colorSurfaceInverse">@color/md_theme_dark_inverseSurface</item>
-        <item name="colorOnSurfaceInverse">@color/md_theme_dark_inverseOnSurface</item>
-        <item name="colorPrimaryInverse">@color/md_theme_dark_inversePrimary</item>
-        
-        <!-- Status Bar -->
-        <item name="android:statusBarColor">@color/md_theme_dark_surface</item>
-        <item name="android:windowLightStatusBar">false</item>
-        <item name="android:navigationBarColor">@color/md_theme_dark_surface</item>
-        <item name="android:windowLightNavigationBar">false</item>
-        
-        <!-- Custom Status Colors -->
-        <item name="colorSuccess">@color/md_theme_dark_success</item>
-        <item name="colorWarning">@color/md_theme_dark_warning</item>
-    </style>
+<resources xmlns:tools="http://schemas.android.com/tools">
+    <!-- Base application theme for Dark Mode -->
+    <style name="Base.Theme.InnovaMotionApp" parent="Theme.Material3.DayNight.NoActionBar">
+        <!-- Primary Brand Colors -->
+        <item name="colorPrimary">@color/md_theme_dark_primary</item>
+        <item name="colorOnPrimary">@color/md_theme_dark_onPrimary</item>
+        <item name="colorPrimaryContainer">@color/md_theme_dark_primaryContainer</item>
+        <item name="colorOnPrimaryContainer">@color/md_theme_dark_onPrimaryContainer</item>
+        
+        <!-- Secondary Colors -->
+        <item name="colorSecondary">@color/md_theme_dark_secondary</item>
+        <item name="colorOnSecondary">@color/md_theme_dark_onSecondary</item>
+        <item name="colorSecondaryContainer">@color/md_theme_dark_secondaryContainer</item>
+        <item name="colorOnSecondaryContainer">@color/md_theme_dark_onSecondaryContainer</item>
+        
+        <!-- Tertiary Colors -->
+        <item name="colorTertiary">@color/md_theme_dark_tertiary</item>
+        <item name="colorOnTertiary">@color/md_theme_dark_onTertiary</item>
+        <item name="colorTertiaryContainer">@color/md_theme_dark_tertiaryContainer</item>
+        <item name="colorOnTertiaryContainer">@color/md_theme_dark_onTertiaryContainer</item>
+        
+        <!-- Error Colors -->
+        <item name="colorError">@color/md_theme_dark_error</item>
+        <item name="colorOnError">@color/md_theme_dark_onError</item>
+        <item name="colorErrorContainer">@color/md_theme_dark_errorContainer</item>
+        <item name="colorOnErrorContainer">@color/md_theme_dark_onErrorContainer</item>
+        
+        <!-- Background & Surface -->
+        <item name="android:colorBackground">@color/md_theme_dark_background</item>
+        <item name="colorOnBackground">@color/md_theme_dark_onBackground</item>
+        <item name="colorSurface">@color/md_theme_dark_surface</item>
+        <item name="colorOnSurface">@color/md_theme_dark_onSurface</item>
+        <item name="colorSurfaceVariant">@color/md_theme_dark_surfaceVariant</item>
+        <item name="colorOnSurfaceVariant">@color/md_theme_dark_onSurfaceVariant</item>
+        
+        <!-- Outline & Other -->
+        <item name="colorOutline">@color/md_theme_dark_outline</item>
+        <item name="colorOutlineVariant">@color/md_theme_dark_outlineVariant</item>
+        <item name="colorSurfaceInverse">@color/md_theme_dark_inverseSurface</item>
+        <item name="colorOnSurfaceInverse">@color/md_theme_dark_inverseOnSurface</item>
+        <item name="colorPrimaryInverse">@color/md_theme_dark_inversePrimary</item>
+        
+        <!-- Status Bar -->
+        <item name="android:statusBarColor">@color/md_theme_dark_surface</item>
+        <item name="android:windowLightStatusBar">false</item>
+        <item name="android:navigationBarColor">@color/md_theme_dark_surface</item>
+        <item name="android:windowLightNavigationBar">false</item>
+        
+        <!-- Custom Status Colors -->
+        <item name="colorSuccess">@color/md_theme_dark_success</item>
+        <item name="colorWarning">@color/md_theme_dark_warning</item>
+    </style>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values-v23/themes.xml b/InnovaMotionApp/app/src/main/res/values-v23/themes.xml
index 3ca2ecd..2e29778 100644
--- a/InnovaMotionApp/app/src/main/res/values-v23/themes.xml
+++ b/InnovaMotionApp/app/src/main/res/values-v23/themes.xml
@@ -1,9 +1,9 @@
-<resources xmlns:tools="http://schemas.android.com/tools">
-
-    <style name="Theme.InnovaMotionApp" parent="Base.Theme.InnovaMotionApp">
-        <!-- Transparent system bars for edge-to-edge. -->
-        <item name="android:navigationBarColor">@android:color/transparent</item>
-        <item name="android:statusBarColor">@android:color/transparent</item>
-        <item name="android:windowLightStatusBar">?attr/isLightTheme</item>
-    </style>
+<resources xmlns:tools="http://schemas.android.com/tools">
+
+    <style name="Theme.InnovaMotionApp" parent="Base.Theme.InnovaMotionApp">
+        <!-- Transparent system bars for edge-to-edge. -->
+        <item name="android:navigationBarColor">@android:color/transparent</item>
+        <item name="android:statusBarColor">@android:color/transparent</item>
+        <item name="android:windowLightStatusBar">?attr/isLightTheme</item>
+    </style>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values-w1240dp/dimens.xml b/InnovaMotionApp/app/src/main/res/values-w1240dp/dimens.xml
index cdf3842..6805570 100644
--- a/InnovaMotionApp/app/src/main/res/values-w1240dp/dimens.xml
+++ b/InnovaMotionApp/app/src/main/res/values-w1240dp/dimens.xml
@@ -1,4 +1,4 @@
-<resources>
-    <dimen name="fab_margin">200dp</dimen>
-    <dimen name="activity_horizontal_margin">200dp</dimen>
+<resources>
+    <dimen name="fab_margin">200dp</dimen>
+    <dimen name="activity_horizontal_margin">200dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values-w600dp/dimens.xml b/InnovaMotionApp/app/src/main/res/values-w600dp/dimens.xml
index a405d47..9f7d96c 100644
--- a/InnovaMotionApp/app/src/main/res/values-w600dp/dimens.xml
+++ b/InnovaMotionApp/app/src/main/res/values-w600dp/dimens.xml
@@ -1,4 +1,4 @@
-<resources>
-    <dimen name="fab_margin">48dp</dimen>
-    <dimen name="activity_horizontal_margin">48dp</dimen>
+<resources>
+    <dimen name="fab_margin">48dp</dimen>
+    <dimen name="activity_horizontal_margin">48dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values/attrs.xml b/InnovaMotionApp/app/src/main/res/values/attrs.xml
index 5da6b20..7867a39 100644
--- a/InnovaMotionApp/app/src/main/res/values/attrs.xml
+++ b/InnovaMotionApp/app/src/main/res/values/attrs.xml
@@ -1,6 +1,6 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <!-- Custom theme attributes for status colors -->
-    <attr name="colorSuccess" format="color" />
-    <attr name="colorWarning" format="color" />
-</resources>
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <!-- Custom theme attributes for status colors -->
+    <attr name="colorSuccess" format="color" />
+    <attr name="colorWarning" format="color" />
+</resources>
diff --git a/InnovaMotionApp/app/src/main/res/values/colors.xml b/InnovaMotionApp/app/src/main/res/values/colors.xml
index 147db69..64d501d 100644
--- a/InnovaMotionApp/app/src/main/res/values/colors.xml
+++ b/InnovaMotionApp/app/src/main/res/values/colors.xml
@@ -1,107 +1,107 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <!-- System Colors -->
-    <color name="black">#FF000000</color>
-    <color name="white">#FFFFFFFF</color>
-    
-    <!-- Light Theme - Brand Colors -->
-    <color name="md_theme_light_primary">#318779</color>
-    <color name="md_theme_light_onPrimary">#FFFFFF</color>
-    <color name="md_theme_light_primaryContainer">#B2DFDB</color>
-    <color name="md_theme_light_onPrimaryContainer">#00251E</color>
-    
-    <color name="md_theme_light_secondary">#607D8B</color>
-    <color name="md_theme_light_onSecondary">#FFFFFF</color>
-    <color name="md_theme_light_secondaryContainer">#CFD8DC</color>
-    <color name="md_theme_light_onSecondaryContainer">#1C313A</color>
-    
-    <color name="md_theme_light_tertiary">#4CAF50</color>
-    <color name="md_theme_light_onTertiary">#FFFFFF</color>
-    <color name="md_theme_light_tertiaryContainer">#C8E6C9</color>
-    <color name="md_theme_light_onTertiaryContainer">#1B5E20</color>
-    
-    <color name="md_theme_light_error">#D32F2F</color>
-    <color name="md_theme_light_onError">#FFFFFF</color>
-    <color name="md_theme_light_errorContainer">#FFCDD2</color>
-    <color name="md_theme_light_onErrorContainer">#B71C1C</color>
-    
-    <color name="md_theme_light_background">#FFFFFF</color>
-    <color name="md_theme_light_onBackground">#1C1C1C</color>
-    <color name="md_theme_light_surface">#D2EAE5</color>
-    <color name="md_theme_light_onSurface">#1E1E1E</color>
-    <color name="md_theme_light_surfaceVariant">#E8F5E8</color>
-    <color name="md_theme_light_onSurfaceVariant">#44524A</color>
-    
-    <color name="md_theme_light_outline">#74796F</color>
-    <color name="md_theme_light_outlineVariant">#C4C9C0</color>
-    <color name="md_theme_light_scrim">#000000</color>
-    <color name="md_theme_light_inverseSurface">#2F312E</color>
-    <color name="md_theme_light_inverseOnSurface">#F0F1EC</color>
-    <color name="md_theme_light_inversePrimary">#A0CCB8</color>
-    
-    <!-- Status Colors Light -->
-    <color name="md_theme_light_success">#4CAF50</color>
-    <color name="md_theme_light_warning">#F9A825</color>
-    
-    <!-- Dark Theme - Brand Colors -->
-    <color name="md_theme_dark_primary">#4BB6A7</color>
-    <color name="md_theme_dark_onPrimary">#0E0E0E</color>
-    <color name="md_theme_dark_primaryContainer">#00695C</color>
-    <color name="md_theme_dark_onPrimaryContainer">#B2DFDB</color>
-    
-    <color name="md_theme_dark_secondary">#90A4AE</color>
-    <color name="md_theme_dark_onSecondary">#0E0E0E</color>
-    <color name="md_theme_dark_secondaryContainer">#455A64</color>
-    <color name="md_theme_dark_onSecondaryContainer">#CFD8DC</color>
-    
-    <color name="md_theme_dark_tertiary">#81C784</color>
-    <color name="md_theme_dark_onTertiary">#0E0E0E</color>
-    <color name="md_theme_dark_tertiaryContainer">#2E7D32</color>
-    <color name="md_theme_dark_onTertiaryContainer">#C8E6C9</color>
-    
-    <color name="md_theme_dark_error">#FF6F6F</color>
-    <color name="md_theme_dark_onError">#0E0E0E</color>
-    <color name="md_theme_dark_errorContainer">#C62828</color>
-    <color name="md_theme_dark_onErrorContainer">#FFCDD2</color>
-    
-    <color name="md_theme_dark_background">#121212</color>
-    <color name="md_theme_dark_onBackground">#E8EAE9</color>
-    <color name="md_theme_dark_surface">#1B1B1B</color>
-    <color name="md_theme_dark_onSurface">#CFD8DC</color>
-    <color name="md_theme_dark_surfaceVariant">#2E2E2E</color>
-    <color name="md_theme_dark_onSurfaceVariant">#C4C9C0</color>
-    
-    <color name="md_theme_dark_outline">#8E918C</color>
-    <color name="md_theme_dark_outlineVariant">#44524A</color>
-    <color name="md_theme_dark_scrim">#000000</color>
-    <color name="md_theme_dark_inverseSurface">#E1E3DE</color>
-    <color name="md_theme_dark_inverseOnSurface">#2F312E</color>
-    <color name="md_theme_dark_inversePrimary">#318779</color>
-    
-    <!-- Status Colors Dark -->
-    <color name="md_theme_dark_success">#81C784</color>
-    <color name="md_theme_dark_warning">#FFD54F</color>
-    
-    <!-- Legacy Colors (for backward compatibility - will be phased out) -->
-    <color name="primary_color">#318779</color>
-    <color name="primary_dark">#00695C</color>
-    <color name="accent_color">#4BB6A7</color>
-    <color name="login_background">#FFFFFF</color>
-    <color name="primary_text">#1C1C1C</color>
-    <color name="secondary_text">#757575</color>
-    <color name="divider_color">#E0E0E0</color>
-    <color name="google_text_color">#757575</color>
-    <color name="google_stroke_color">#DADCE0</color>
-
-    <!-- Message Log UI Colors -->
-    <color name="fall_alert_background">#FFEBEE</color>
-    <color name="fall_alert_text">#C62828</color>
-    <color name="card_background">#FFFFFF</color>
-    <color name="card_text_primary">#1C1C1C</color>
-    <color name="chip_background">#E0E0E0</color>
-
-    <!-- Supervisor Dashboard Status Colors -->
-    <color name="status_active">#4CAF50</color>
-    <color name="status_stale">#FFC107</color>
-    <color name="status_alert">#F44336</color>
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <!-- System Colors -->
+    <color name="black">#FF000000</color>
+    <color name="white">#FFFFFFFF</color>
+    
+    <!-- Light Theme - Brand Colors -->
+    <color name="md_theme_light_primary">#318779</color>
+    <color name="md_theme_light_onPrimary">#FFFFFF</color>
+    <color name="md_theme_light_primaryContainer">#B2DFDB</color>
+    <color name="md_theme_light_onPrimaryContainer">#00251E</color>
+    
+    <color name="md_theme_light_secondary">#607D8B</color>
+    <color name="md_theme_light_onSecondary">#FFFFFF</color>
+    <color name="md_theme_light_secondaryContainer">#CFD8DC</color>
+    <color name="md_theme_light_onSecondaryContainer">#1C313A</color>
+    
+    <color name="md_theme_light_tertiary">#4CAF50</color>
+    <color name="md_theme_light_onTertiary">#FFFFFF</color>
+    <color name="md_theme_light_tertiaryContainer">#C8E6C9</color>
+    <color name="md_theme_light_onTertiaryContainer">#1B5E20</color>
+    
+    <color name="md_theme_light_error">#D32F2F</color>
+    <color name="md_theme_light_onError">#FFFFFF</color>
+    <color name="md_theme_light_errorContainer">#FFCDD2</color>
+    <color name="md_theme_light_onErrorContainer">#B71C1C</color>
+    
+    <color name="md_theme_light_background">#FFFFFF</color>
+    <color name="md_theme_light_onBackground">#1C1C1C</color>
+    <color name="md_theme_light_surface">#D2EAE5</color>
+    <color name="md_theme_light_onSurface">#1E1E1E</color>
+    <color name="md_theme_light_surfaceVariant">#E8F5E8</color>
+    <color name="md_theme_light_onSurfaceVariant">#44524A</color>
+    
+    <color name="md_theme_light_outline">#74796F</color>
+    <color name="md_theme_light_outlineVariant">#C4C9C0</color>
+    <color name="md_theme_light_scrim">#000000</color>
+    <color name="md_theme_light_inverseSurface">#2F312E</color>
+    <color name="md_theme_light_inverseOnSurface">#F0F1EC</color>
+    <color name="md_theme_light_inversePrimary">#A0CCB8</color>
+    
+    <!-- Status Colors Light -->
+    <color name="md_theme_light_success">#4CAF50</color>
+    <color name="md_theme_light_warning">#F9A825</color>
+    
+    <!-- Dark Theme - Brand Colors -->
+    <color name="md_theme_dark_primary">#4BB6A7</color>
+    <color name="md_theme_dark_onPrimary">#0E0E0E</color>
+    <color name="md_theme_dark_primaryContainer">#00695C</color>
+    <color name="md_theme_dark_onPrimaryContainer">#B2DFDB</color>
+    
+    <color name="md_theme_dark_secondary">#90A4AE</color>
+    <color name="md_theme_dark_onSecondary">#0E0E0E</color>
+    <color name="md_theme_dark_secondaryContainer">#455A64</color>
+    <color name="md_theme_dark_onSecondaryContainer">#CFD8DC</color>
+    
+    <color name="md_theme_dark_tertiary">#81C784</color>
+    <color name="md_theme_dark_onTertiary">#0E0E0E</color>
+    <color name="md_theme_dark_tertiaryContainer">#2E7D32</color>
+    <color name="md_theme_dark_onTertiaryContainer">#C8E6C9</color>
+    
+    <color name="md_theme_dark_error">#FF6F6F</color>
+    <color name="md_theme_dark_onError">#0E0E0E</color>
+    <color name="md_theme_dark_errorContainer">#C62828</color>
+    <color name="md_theme_dark_onErrorContainer">#FFCDD2</color>
+    
+    <color name="md_theme_dark_background">#121212</color>
+    <color name="md_theme_dark_onBackground">#E8EAE9</color>
+    <color name="md_theme_dark_surface">#1B1B1B</color>
+    <color name="md_theme_dark_onSurface">#CFD8DC</color>
+    <color name="md_theme_dark_surfaceVariant">#2E2E2E</color>
+    <color name="md_theme_dark_onSurfaceVariant">#C4C9C0</color>
+    
+    <color name="md_theme_dark_outline">#8E918C</color>
+    <color name="md_theme_dark_outlineVariant">#44524A</color>
+    <color name="md_theme_dark_scrim">#000000</color>
+    <color name="md_theme_dark_inverseSurface">#E1E3DE</color>
+    <color name="md_theme_dark_inverseOnSurface">#2F312E</color>
+    <color name="md_theme_dark_inversePrimary">#318779</color>
+    
+    <!-- Status Colors Dark -->
+    <color name="md_theme_dark_success">#81C784</color>
+    <color name="md_theme_dark_warning">#FFD54F</color>
+    
+    <!-- Legacy Colors (for backward compatibility - will be phased out) -->
+    <color name="primary_color">#318779</color>
+    <color name="primary_dark">#00695C</color>
+    <color name="accent_color">#4BB6A7</color>
+    <color name="login_background">#FFFFFF</color>
+    <color name="primary_text">#1C1C1C</color>
+    <color name="secondary_text">#757575</color>
+    <color name="divider_color">#E0E0E0</color>
+    <color name="google_text_color">#757575</color>
+    <color name="google_stroke_color">#DADCE0</color>
+
+    <!-- Message Log UI Colors -->
+    <color name="fall_alert_background">#FFEBEE</color>
+    <color name="fall_alert_text">#C62828</color>
+    <color name="card_background">#FFFFFF</color>
+    <color name="card_text_primary">#1C1C1C</color>
+    <color name="chip_background">#E0E0E0</color>
+
+    <!-- Supervisor Dashboard Status Colors -->
+    <color name="status_active">#4CAF50</color>
+    <color name="status_stale">#FFC107</color>
+    <color name="status_alert">#F44336</color>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values/dimens.xml b/InnovaMotionApp/app/src/main/res/values/dimens.xml
index b8c47cb..75c9565 100644
--- a/InnovaMotionApp/app/src/main/res/values/dimens.xml
+++ b/InnovaMotionApp/app/src/main/res/values/dimens.xml
@@ -1,6 +1,6 @@
-<resources>
-    <dimen name="fab_margin">16dp</dimen>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
+<resources>
+    <dimen name="fab_margin">16dp</dimen>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values/strings.xml b/InnovaMotionApp/app/src/main/res/values/strings.xml
index c1202d2..4cf84d1 100644
--- a/InnovaMotionApp/app/src/main/res/values/strings.xml
+++ b/InnovaMotionApp/app/src/main/res/values/strings.xml
@@ -186,4 +186,18 @@
     <string name="syncing_to_firestore">Syncing to Firestoreâ€¦</string>
     <string name="firestore_sync_complete">Synced %1$d readings to Firestore</string>
     <string name="firestore_sync_error">Firestore sync failed: %1$s</string>
+
+    <!-- Sensor Settings / Supervisor Assignment -->
+    <string name="sensor_settings_title">Sensor Settings</string>
+    <string name="supervisor_email_hint">Supervisor Email</string>
+    <string name="supervisor_assigned">Assigned to: %1$s</string>
+    <string name="supervisor_not_assigned">No supervisor assigned</string>
+    <string name="assign_supervisor">Assign Supervisor</string>
+    <string name="unassign_supervisor">Unassign</string>
+    <string name="supervisor_assignment_success">Supervisor assigned successfully</string>
+    <string name="supervisor_assignment_error">Failed to assign supervisor: %1$s</string>
+    <string name="supervisor_unassigned_success">Supervisor unassigned</string>
+    <string name="no_supervisor_found">No supervisor found with that email</string>
+    <string name="searching_supervisors">Searching supervisorsâ€¦</string>
+    <string name="supervisor_label">Supervisor:</string>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/values/themes.xml b/InnovaMotionApp/app/src/main/res/values/themes.xml
index 399f8b6..9514faf 100644
--- a/InnovaMotionApp/app/src/main/res/values/themes.xml
+++ b/InnovaMotionApp/app/src/main/res/values/themes.xml
@@ -1,97 +1,97 @@
-<resources xmlns:tools="http://schemas.android.com/tools">
-    <!-- Base application theme for Light Mode -->
-    <style name="Base.Theme.InnovaMotionApp" parent="Theme.Material3.DayNight.NoActionBar">
-        <!-- Primary Brand Colors -->
-        <item name="colorPrimary">@color/md_theme_light_primary</item>
-        <item name="colorOnPrimary">@color/md_theme_light_onPrimary</item>
-        <item name="colorPrimaryContainer">@color/md_theme_light_primaryContainer</item>
-        <item name="colorOnPrimaryContainer">@color/md_theme_light_onPrimaryContainer</item>
-        
-        <!-- Secondary Colors -->
-        <item name="colorSecondary">@color/md_theme_light_secondary</item>
-        <item name="colorOnSecondary">@color/md_theme_light_onSecondary</item>
-        <item name="colorSecondaryContainer">@color/md_theme_light_secondaryContainer</item>
-        <item name="colorOnSecondaryContainer">@color/md_theme_light_onSecondaryContainer</item>
-        
-        <!-- Tertiary Colors -->
-        <item name="colorTertiary">@color/md_theme_light_tertiary</item>
-        <item name="colorOnTertiary">@color/md_theme_light_onTertiary</item>
-        <item name="colorTertiaryContainer">@color/md_theme_light_tertiaryContainer</item>
-        <item name="colorOnTertiaryContainer">@color/md_theme_light_onTertiaryContainer</item>
-        
-        <!-- Error Colors -->
-        <item name="colorError">@color/md_theme_light_error</item>
-        <item name="colorOnError">@color/md_theme_light_onError</item>
-        <item name="colorErrorContainer">@color/md_theme_light_errorContainer</item>
-        <item name="colorOnErrorContainer">@color/md_theme_light_onErrorContainer</item>
-        
-        <!-- Background & Surface -->
-        <item name="android:colorBackground">@color/md_theme_light_background</item>
-        <item name="colorOnBackground">@color/md_theme_light_onBackground</item>
-        <item name="colorSurface">@color/md_theme_light_surface</item>
-        <item name="colorOnSurface">@color/md_theme_light_onSurface</item>
-        <item name="colorSurfaceVariant">@color/md_theme_light_surfaceVariant</item>
-        <item name="colorOnSurfaceVariant">@color/md_theme_light_onSurfaceVariant</item>
-        
-        <!-- Outline & Other -->
-        <item name="colorOutline">@color/md_theme_light_outline</item>
-        <item name="colorOutlineVariant">@color/md_theme_light_outlineVariant</item>
-        <item name="colorSurfaceInverse">@color/md_theme_light_inverseSurface</item>
-        <item name="colorOnSurfaceInverse">@color/md_theme_light_inverseOnSurface</item>
-        <item name="colorPrimaryInverse">@color/md_theme_light_inversePrimary</item>
-        
-        <!-- Status Bar -->
-        <item name="android:statusBarColor">@color/md_theme_light_primary</item>
-        <item name="android:windowLightStatusBar">false</item>
-        <item name="android:navigationBarColor">@color/md_theme_light_surface</item>
-        <item name="android:windowLightNavigationBar">true</item>
-        
-        <!-- Custom Status Colors -->
-        <item name="colorSuccess">@color/md_theme_light_success</item>
-        <item name="colorWarning">@color/md_theme_light_warning</item>
-    </style>
-
-    <!-- Main theme that extends base theme -->
-    <style name="Theme.InnovaMotionApp" parent="Base.Theme.InnovaMotionApp" />
-    
-    <!-- Button Styles -->
-    <style name="Theme.InnovaMotionApp.Button" parent="Widget.Material3.Button">
-        <item name="backgroundTint">?attr/colorPrimary</item>
-        <item name="android:textColor">?attr/colorOnPrimary</item>
-        <item name="cornerRadius">12dp</item>
-        <item name="android:minHeight">48dp</item>
-        <item name="android:textSize">16sp</item>
-        <item name="android:textStyle">bold</item>
-    </style>
-    
-    <style name="Theme.InnovaMotionApp.Button.Secondary" parent="Widget.Material3.Button.OutlinedButton">
-        <item name="strokeColor">?attr/colorSecondary</item>
-        <item name="android:textColor">?attr/colorSecondary</item>
-        <item name="cornerRadius">12dp</item>
-        <item name="android:minHeight">48dp</item>
-        <item name="android:textSize">16sp</item>
-    </style>
-    
-    <!-- Card Styles -->
-    <style name="Theme.InnovaMotionApp.Card" parent="Widget.Material3.CardView.Elevated">
-        <item name="cardBackgroundColor">?attr/colorSurface</item>
-        <item name="cardCornerRadius">16dp</item>
-        <item name="cardElevation">8dp</item>
-        <item name="contentPadding">24dp</item>
-    </style>
-    
-    <!-- Text Input Styles -->
-    <style name="Theme.InnovaMotionApp.TextInputLayout" parent="Widget.Material3.TextInputLayout.OutlinedBox">
-        <item name="boxStrokeColor">?attr/colorPrimary</item>
-        <item name="hintTextColor">?attr/colorOnSurfaceVariant</item>
-        <item name="boxCornerRadiusTopStart">12dp</item>
-        <item name="boxCornerRadiusTopEnd">12dp</item>
-        <item name="boxCornerRadiusBottomStart">12dp</item>
-        <item name="boxCornerRadiusBottomEnd">12dp</item>
-    </style>
-    
-    <!-- Progress Bar Style -->
-    <style name="Theme.InnovaMotionApp.ProgressBar" parent="Widget.Material3.CircularProgressIndicator">
-        <item name="android:indeterminateTint">?attr/colorPrimary</item>
-    </style>
+<resources xmlns:tools="http://schemas.android.com/tools">
+    <!-- Base application theme for Light Mode -->
+    <style name="Base.Theme.InnovaMotionApp" parent="Theme.Material3.DayNight.NoActionBar">
+        <!-- Primary Brand Colors -->
+        <item name="colorPrimary">@color/md_theme_light_primary</item>
+        <item name="colorOnPrimary">@color/md_theme_light_onPrimary</item>
+        <item name="colorPrimaryContainer">@color/md_theme_light_primaryContainer</item>
+        <item name="colorOnPrimaryContainer">@color/md_theme_light_onPrimaryContainer</item>
+        
+        <!-- Secondary Colors -->
+        <item name="colorSecondary">@color/md_theme_light_secondary</item>
+        <item name="colorOnSecondary">@color/md_theme_light_onSecondary</item>
+        <item name="colorSecondaryContainer">@color/md_theme_light_secondaryContainer</item>
+        <item name="colorOnSecondaryContainer">@color/md_theme_light_onSecondaryContainer</item>
+        
+        <!-- Tertiary Colors -->
+        <item name="colorTertiary">@color/md_theme_light_tertiary</item>
+        <item name="colorOnTertiary">@color/md_theme_light_onTertiary</item>
+        <item name="colorTertiaryContainer">@color/md_theme_light_tertiaryContainer</item>
+        <item name="colorOnTertiaryContainer">@color/md_theme_light_onTertiaryContainer</item>
+        
+        <!-- Error Colors -->
+        <item name="colorError">@color/md_theme_light_error</item>
+        <item name="colorOnError">@color/md_theme_light_onError</item>
+        <item name="colorErrorContainer">@color/md_theme_light_errorContainer</item>
+        <item name="colorOnErrorContainer">@color/md_theme_light_onErrorContainer</item>
+        
+        <!-- Background & Surface -->
+        <item name="android:colorBackground">@color/md_theme_light_background</item>
+        <item name="colorOnBackground">@color/md_theme_light_onBackground</item>
+        <item name="colorSurface">@color/md_theme_light_surface</item>
+        <item name="colorOnSurface">@color/md_theme_light_onSurface</item>
+        <item name="colorSurfaceVariant">@color/md_theme_light_surfaceVariant</item>
+        <item name="colorOnSurfaceVariant">@color/md_theme_light_onSurfaceVariant</item>
+        
+        <!-- Outline & Other -->
+        <item name="colorOutline">@color/md_theme_light_outline</item>
+        <item name="colorOutlineVariant">@color/md_theme_light_outlineVariant</item>
+        <item name="colorSurfaceInverse">@color/md_theme_light_inverseSurface</item>
+        <item name="colorOnSurfaceInverse">@color/md_theme_light_inverseOnSurface</item>
+        <item name="colorPrimaryInverse">@color/md_theme_light_inversePrimary</item>
+        
+        <!-- Status Bar -->
+        <item name="android:statusBarColor">@color/md_theme_light_primary</item>
+        <item name="android:windowLightStatusBar">false</item>
+        <item name="android:navigationBarColor">@color/md_theme_light_surface</item>
+        <item name="android:windowLightNavigationBar">true</item>
+        
+        <!-- Custom Status Colors -->
+        <item name="colorSuccess">@color/md_theme_light_success</item>
+        <item name="colorWarning">@color/md_theme_light_warning</item>
+    </style>
+
+    <!-- Main theme that extends base theme -->
+    <style name="Theme.InnovaMotionApp" parent="Base.Theme.InnovaMotionApp" />
+    
+    <!-- Button Styles -->
+    <style name="Theme.InnovaMotionApp.Button" parent="Widget.Material3.Button">
+        <item name="backgroundTint">?attr/colorPrimary</item>
+        <item name="android:textColor">?attr/colorOnPrimary</item>
+        <item name="cornerRadius">12dp</item>
+        <item name="android:minHeight">48dp</item>
+        <item name="android:textSize">16sp</item>
+        <item name="android:textStyle">bold</item>
+    </style>
+    
+    <style name="Theme.InnovaMotionApp.Button.Secondary" parent="Widget.Material3.Button.OutlinedButton">
+        <item name="strokeColor">?attr/colorSecondary</item>
+        <item name="android:textColor">?attr/colorSecondary</item>
+        <item name="cornerRadius">12dp</item>
+        <item name="android:minHeight">48dp</item>
+        <item name="android:textSize">16sp</item>
+    </style>
+    
+    <!-- Card Styles -->
+    <style name="Theme.InnovaMotionApp.Card" parent="Widget.Material3.CardView.Elevated">
+        <item name="cardBackgroundColor">?attr/colorSurface</item>
+        <item name="cardCornerRadius">16dp</item>
+        <item name="cardElevation">8dp</item>
+        <item name="contentPadding">24dp</item>
+    </style>
+    
+    <!-- Text Input Styles -->
+    <style name="Theme.InnovaMotionApp.TextInputLayout" parent="Widget.Material3.TextInputLayout.OutlinedBox">
+        <item name="boxStrokeColor">?attr/colorPrimary</item>
+        <item name="hintTextColor">?attr/colorOnSurfaceVariant</item>
+        <item name="boxCornerRadiusTopStart">12dp</item>
+        <item name="boxCornerRadiusTopEnd">12dp</item>
+        <item name="boxCornerRadiusBottomStart">12dp</item>
+        <item name="boxCornerRadiusBottomEnd">12dp</item>
+    </style>
+    
+    <!-- Progress Bar Style -->
+    <style name="Theme.InnovaMotionApp.ProgressBar" parent="Widget.Material3.CircularProgressIndicator">
+        <item name="android:indeterminateTint">?attr/colorPrimary</item>
+    </style>
 </resources>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/xml/backup_rules.xml b/InnovaMotionApp/app/src/main/res/xml/backup_rules.xml
index fa0f996..07e7d14 100644
--- a/InnovaMotionApp/app/src/main/res/xml/backup_rules.xml
+++ b/InnovaMotionApp/app/src/main/res/xml/backup_rules.xml
@@ -1,13 +1,13 @@
-<?xml version="1.0" encoding="utf-8"?><!--
-   Sample backup rules file; uncomment and customize as necessary.
-   See https://developer.android.com/guide/topics/data/autobackup
-   for details.
-   Note: This file is ignored for devices older that API 31
-   See https://developer.android.com/about/versions/12/backup-restore
--->
-<full-backup-content>
-    <!--
-   <include domain="sharedpref" path="."/>
-   <exclude domain="sharedpref" path="device.xml"/>
--->
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample backup rules file; uncomment and customize as necessary.
+   See https://developer.android.com/guide/topics/data/autobackup
+   for details.
+   Note: This file is ignored for devices older that API 31
+   See https://developer.android.com/about/versions/12/backup-restore
+-->
+<full-backup-content>
+    <!--
+   <include domain="sharedpref" path="."/>
+   <exclude domain="sharedpref" path="device.xml"/>
+-->
 </full-backup-content>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/main/res/xml/data_extraction_rules.xml b/InnovaMotionApp/app/src/main/res/xml/data_extraction_rules.xml
index 9ee9997..0ee2a78 100644
--- a/InnovaMotionApp/app/src/main/res/xml/data_extraction_rules.xml
+++ b/InnovaMotionApp/app/src/main/res/xml/data_extraction_rules.xml
@@ -1,19 +1,19 @@
-<?xml version="1.0" encoding="utf-8"?><!--
-   Sample data extraction rules file; uncomment and customize as necessary.
-   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
-   for details.
--->
-<data-extraction-rules>
-    <cloud-backup>
-        <!-- TODO: Use <include> and <exclude> to control what is backed up.
-        <include .../>
-        <exclude .../>
-        -->
-    </cloud-backup>
-    <!--
-    <device-transfer>
-        <include .../>
-        <exclude .../>
-    </device-transfer>
-    -->
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample data extraction rules file; uncomment and customize as necessary.
+   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
+   for details.
+-->
+<data-extraction-rules>
+    <cloud-backup>
+        <!-- TODO: Use <include> and <exclude> to control what is backed up.
+        <include .../>
+        <exclude .../>
+        -->
+    </cloud-backup>
+    <!--
+    <device-transfer>
+        <include .../>
+        <exclude .../>
+    </device-transfer>
+    -->
 </data-extraction-rules>
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ExampleUnitTest.java b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ExampleUnitTest.java
index 6374360..e515af7 100644
--- a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ExampleUnitTest.java
+++ b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ExampleUnitTest.java
@@ -1,17 +1,17 @@
-package com.melisa.innovamotionapp;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-
-/**
- * Example local unit test, which will execute on the development machine (host).
- *
- * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
- */
-public class ExampleUnitTest {
-    @Test
-    public void addition_isCorrect() {
-        assertEquals(4, 2 + 2);
-    }
+package com.melisa.innovamotionapp;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() {
+        assertEquals(4, 2 + 2);
+    }
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/PacketParserTest.java b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/PacketParserTest.java
index ed0a109..b59baeb 100644
--- a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/PacketParserTest.java
+++ b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/PacketParserTest.java
@@ -1,407 +1,407 @@
-package com.melisa.innovamotionapp.bluetooth;
-
-import static org.junit.Assert.*;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.List;
-
-/**
- * Comprehensive unit tests for PacketParser.
- * 
- * Tests cover:
- * - Normal packet parsing
- * - Empty packets
- * - Malformed lines (no semicolon, empty parts)
- * - Large packets
- * - Buffer overflow protection
- * - Multiple consecutive packets
- * - Edge cases (whitespace, multiple delimiters, etc.)
- */
-public class PacketParserTest {
-    
-    private PacketParser parser;
-    
-    @Before
-    public void setUp() {
-        parser = new PacketParser();
-    }
-    
-    // ========== Normal Packet Parsing ==========
-    
-    @Test
-    public void testSingleReadingPacket() {
-        // Feed a single reading then END_PACKET
-        assertNull(parser.feedLine("sensor001;0xAB3311"));
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        assertEquals("sensor001", result.get(0).getSensorId());
-        assertEquals("0xAB3311", result.get(0).getHexCode());
-    }
-    
-    @Test
-    public void testMultipleReadingsPacket() {
-        // Feed multiple readings then END_PACKET
-        assertNull(parser.feedLine("sensor001;0xAB3311"));
-        assertNull(parser.feedLine("sensor002;0xEF0112"));
-        assertNull(parser.feedLine("sensor003;0xBA3311"));
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(3, result.size());
-        assertEquals("sensor001", result.get(0).getSensorId());
-        assertEquals("sensor002", result.get(1).getSensorId());
-        assertEquals("sensor003", result.get(2).getSensorId());
-        assertEquals("0xAB3311", result.get(0).getHexCode());
-        assertEquals("0xEF0112", result.get(1).getHexCode());
-        assertEquals("0xBA3311", result.get(2).getHexCode());
-    }
-    
-    @Test
-    public void testDuplicateSensorInPacket() {
-        // Same sensor can appear multiple times per spec
-        assertNull(parser.feedLine("sensor001;0xAB3311"));
-        assertNull(parser.feedLine("sensor002;0xEF0112"));
-        assertNull(parser.feedLine("sensor001;0xBA3311")); // sensor001 again
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(3, result.size());
-        assertEquals("sensor001", result.get(0).getSensorId());
-        assertEquals("sensor001", result.get(2).getSensorId());
-        assertEquals("0xAB3311", result.get(0).getHexCode());
-        assertEquals("0xBA3311", result.get(2).getHexCode());
-    }
-    
-    @Test
-    public void testUuidSensorId() {
-        // UUID format sensor IDs should work
-        String uuid = "5d6d75ee-b6c8-42d4-a233-b13d137fea38";
-        assertNull(parser.feedLine(uuid + ";0xAB3311"));
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        assertEquals(uuid, result.get(0).getSensorId());
-    }
-    
-    // ========== Empty Packets ==========
-    
-    @Test
-    public void testEmptyPacket() {
-        // Just END_PACKET with no readings
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertTrue(result.isEmpty());
-    }
-    
-    @Test
-    public void testEmptyPacketAfterEmptyLines() {
-        // Empty lines followed by END_PACKET
-        assertNull(parser.feedLine(""));
-        assertNull(parser.feedLine("   "));
-        assertNull(parser.feedLine("\t"));
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertTrue(result.isEmpty());
-    }
-    
-    // ========== Malformed Lines ==========
-    
-    @Test
-    public void testMalformedLineNoDelimiter() {
-        // Line without semicolon should be skipped
-        assertNull(parser.feedLine("sensor001_0xAB3311")); // No semicolon
-        assertNull(parser.feedLine("sensor002;0xEF0112")); // Valid
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size()); // Only the valid one
-        assertEquals("sensor002", result.get(0).getSensorId());
-    }
-    
-    @Test
-    public void testMalformedLineEmptySensorId() {
-        // Empty sensor ID should be skipped
-        assertNull(parser.feedLine(";0xAB3311")); // Empty sensorId
-        assertNull(parser.feedLine("sensor001;0xEF0112")); // Valid
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        assertEquals("sensor001", result.get(0).getSensorId());
-    }
-    
-    @Test
-    public void testMalformedLineEmptyHexCode() {
-        // Empty hex code should be skipped
-        assertNull(parser.feedLine("sensor001;")); // Empty hexCode
-        assertNull(parser.feedLine("sensor002;0xEF0112")); // Valid
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        assertEquals("sensor002", result.get(0).getSensorId());
-    }
-    
-    @Test
-    public void testMalformedLineBothEmpty() {
-        // Both parts empty should be skipped
-        assertNull(parser.feedLine(";")); // Both empty
-        assertNull(parser.feedLine("sensor001;0xEF0112")); // Valid
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-    }
-    
-    @Test
-    public void testLineWithMultipleDelimiters() {
-        // Multiple delimiters - should use first two parts
-        assertNull(parser.feedLine("sensor001;0xAB3311;extra_stuff"));
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        assertEquals("sensor001", result.get(0).getSensorId());
-        assertEquals("0xAB3311", result.get(0).getHexCode());
-    }
-    
-    @Test
-    public void testMixedValidInvalidLines() {
-        // Mix of valid and invalid lines
-        assertNull(parser.feedLine("sensor001;0xAB3311")); // Valid
-        assertNull(parser.feedLine("invalid_no_semicolon")); // Invalid
-        assertNull(parser.feedLine("sensor002;0xEF0112")); // Valid
-        assertNull(parser.feedLine(";empty_sensor")); // Invalid
-        assertNull(parser.feedLine("sensor003;0xBA3311")); // Valid
-        assertNull(parser.feedLine("no_hex;")); // Invalid
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(3, result.size());
-    }
-    
-    // ========== Whitespace Handling ==========
-    
-    @Test
-    public void testWhitespaceAroundDelimiter() {
-        // Whitespace around parts should be trimmed
-        assertNull(parser.feedLine("  sensor001  ;  0xAB3311  "));
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        assertEquals("sensor001", result.get(0).getSensorId());
-        assertEquals("0xAB3311", result.get(0).getHexCode());
-    }
-    
-    @Test
-    public void testWhitespaceAroundEndPacket() {
-        // Whitespace around END_PACKET should work
-        assertNull(parser.feedLine("sensor001;0xAB3311"));
-        
-        List<ParsedReading> result = parser.feedLine("  END_PACKET  ");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-    }
-    
-    // ========== Large Packets ==========
-    
-    @Test
-    public void testLargePacket() {
-        // Test with 100+ readings
-        int numReadings = 150;
-        for (int i = 0; i < numReadings; i++) {
-            assertNull(parser.feedLine("sensor" + String.format("%03d", i) + ";0xAB3311"));
-        }
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(numReadings, result.size());
-    }
-    
-    // ========== Buffer Overflow Protection ==========
-    
-    @Test
-    public void testBufferOverflowProtection() {
-        // Create parser with small max buffer
-        PacketParser smallParser = new PacketParser(5);
-        
-        // Feed more than max without END_PACKET
-        for (int i = 0; i < 6; i++) {
-            assertNull(smallParser.feedLine("sensor" + i + ";0xAB3311"));
-        }
-        
-        // At this point, buffer should have been cleared and only last reading should be there
-        // (First 5 readings, then on 6th, buffer cleared before adding)
-        
-        // The last reading (sensor5) should be in buffer
-        List<ParsedReading> result = smallParser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        // After clearing, only the reading that triggered overflow clearing is added
-        assertEquals(1, result.size());
-        assertEquals("sensor5", result.get(0).getSensorId());
-    }
-    
-    @Test
-    public void testCustomMaxBufferSize() {
-        PacketParser customParser = new PacketParser(10);
-        assertEquals(10, customParser.getMaxBufferSize());
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testInvalidMaxBufferSize() {
-        new PacketParser(0);
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testNegativeMaxBufferSize() {
-        new PacketParser(-5);
-    }
-    
-    // ========== Multiple Consecutive Packets ==========
-    
-    @Test
-    public void testMultipleConsecutivePackets() {
-        // First packet
-        assertNull(parser.feedLine("sensor001;0xAB3311"));
-        assertNull(parser.feedLine("sensor002;0xEF0112"));
-        List<ParsedReading> result1 = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result1);
-        assertEquals(2, result1.size());
-        
-        // Buffer should be empty now
-        assertTrue(parser.isBufferEmpty());
-        
-        // Second packet
-        assertNull(parser.feedLine("sensor003;0xBA3311"));
-        List<ParsedReading> result2 = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result2);
-        assertEquals(1, result2.size());
-        assertEquals("sensor003", result2.get(0).getSensorId());
-        
-        // Third packet (empty)
-        List<ParsedReading> result3 = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result3);
-        assertTrue(result3.isEmpty());
-    }
-    
-    // ========== Reset Functionality ==========
-    
-    @Test
-    public void testReset() {
-        assertNull(parser.feedLine("sensor001;0xAB3311"));
-        assertNull(parser.feedLine("sensor002;0xEF0112"));
-        assertEquals(2, parser.getBufferSize());
-        
-        parser.reset();
-        
-        assertEquals(0, parser.getBufferSize());
-        assertTrue(parser.isBufferEmpty());
-        
-        // New packet after reset
-        assertNull(parser.feedLine("sensor003;0xBA3311"));
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        assertEquals("sensor003", result.get(0).getSensorId());
-    }
-    
-    // ========== Null Handling ==========
-    
-    @Test
-    public void testNullLine() {
-        assertNull(parser.feedLine(null));
-        assertEquals(0, parser.getBufferSize());
-    }
-    
-    // ========== Buffer State Methods ==========
-    
-    @Test
-    public void testGetBufferSize() {
-        assertEquals(0, parser.getBufferSize());
-        
-        parser.feedLine("sensor001;0xAB3311");
-        assertEquals(1, parser.getBufferSize());
-        
-        parser.feedLine("sensor002;0xEF0112");
-        assertEquals(2, parser.getBufferSize());
-        
-        parser.feedLine("END_PACKET");
-        assertEquals(0, parser.getBufferSize());
-    }
-    
-    @Test
-    public void testIsBufferEmpty() {
-        assertTrue(parser.isBufferEmpty());
-        
-        parser.feedLine("sensor001;0xAB3311");
-        assertFalse(parser.isBufferEmpty());
-        
-        parser.feedLine("END_PACKET");
-        assertTrue(parser.isBufferEmpty());
-    }
-    
-    @Test
-    public void testGetBufferContents() {
-        parser.feedLine("sensor001;0xAB3311");
-        parser.feedLine("sensor002;0xEF0112");
-        
-        List<ParsedReading> contents = parser.getBufferContents();
-        
-        assertEquals(2, contents.size());
-        assertEquals("sensor001", contents.get(0).getSensorId());
-        assertEquals("sensor002", contents.get(1).getSensorId());
-        
-        // Verify it's a copy (modifications don't affect internal buffer)
-        try {
-            contents.clear();
-        } catch (UnsupportedOperationException e) {
-            // Expected - unmodifiable list
-        }
-        assertEquals(2, parser.getBufferSize());
-    }
-    
-    // ========== Timestamp Testing ==========
-    
-    @Test
-    public void testTimestampIsSet() {
-        long before = System.currentTimeMillis();
-        parser.feedLine("sensor001;0xAB3311");
-        long after = System.currentTimeMillis();
-        
-        List<ParsedReading> result = parser.feedLine("END_PACKET");
-        
-        assertNotNull(result);
-        assertEquals(1, result.size());
-        
-        long timestamp = result.get(0).getReceivedTimestamp();
-        assertTrue("Timestamp should be >= before", timestamp >= before);
-        assertTrue("Timestamp should be <= after", timestamp <= after);
-    }
-}
+package com.melisa.innovamotionapp.bluetooth;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.List;
+
+/**
+ * Comprehensive unit tests for PacketParser.
+ * 
+ * Tests cover:
+ * - Normal packet parsing
+ * - Empty packets
+ * - Malformed lines (no semicolon, empty parts)
+ * - Large packets
+ * - Buffer overflow protection
+ * - Multiple consecutive packets
+ * - Edge cases (whitespace, multiple delimiters, etc.)
+ */
+public class PacketParserTest {
+    
+    private PacketParser parser;
+    
+    @Before
+    public void setUp() {
+        parser = new PacketParser();
+    }
+    
+    // ========== Normal Packet Parsing ==========
+    
+    @Test
+    public void testSingleReadingPacket() {
+        // Feed a single reading then END_PACKET
+        assertNull(parser.feedLine("sensor001;0xAB3311"));
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        assertEquals("sensor001", result.get(0).getSensorId());
+        assertEquals("0xAB3311", result.get(0).getHexCode());
+    }
+    
+    @Test
+    public void testMultipleReadingsPacket() {
+        // Feed multiple readings then END_PACKET
+        assertNull(parser.feedLine("sensor001;0xAB3311"));
+        assertNull(parser.feedLine("sensor002;0xEF0112"));
+        assertNull(parser.feedLine("sensor003;0xBA3311"));
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(3, result.size());
+        assertEquals("sensor001", result.get(0).getSensorId());
+        assertEquals("sensor002", result.get(1).getSensorId());
+        assertEquals("sensor003", result.get(2).getSensorId());
+        assertEquals("0xAB3311", result.get(0).getHexCode());
+        assertEquals("0xEF0112", result.get(1).getHexCode());
+        assertEquals("0xBA3311", result.get(2).getHexCode());
+    }
+    
+    @Test
+    public void testDuplicateSensorInPacket() {
+        // Same sensor can appear multiple times per spec
+        assertNull(parser.feedLine("sensor001;0xAB3311"));
+        assertNull(parser.feedLine("sensor002;0xEF0112"));
+        assertNull(parser.feedLine("sensor001;0xBA3311")); // sensor001 again
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(3, result.size());
+        assertEquals("sensor001", result.get(0).getSensorId());
+        assertEquals("sensor001", result.get(2).getSensorId());
+        assertEquals("0xAB3311", result.get(0).getHexCode());
+        assertEquals("0xBA3311", result.get(2).getHexCode());
+    }
+    
+    @Test
+    public void testUuidSensorId() {
+        // UUID format sensor IDs should work
+        String uuid = "5d6d75ee-b6c8-42d4-a233-b13d137fea38";
+        assertNull(parser.feedLine(uuid + ";0xAB3311"));
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        assertEquals(uuid, result.get(0).getSensorId());
+    }
+    
+    // ========== Empty Packets ==========
+    
+    @Test
+    public void testEmptyPacket() {
+        // Just END_PACKET with no readings
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertTrue(result.isEmpty());
+    }
+    
+    @Test
+    public void testEmptyPacketAfterEmptyLines() {
+        // Empty lines followed by END_PACKET
+        assertNull(parser.feedLine(""));
+        assertNull(parser.feedLine("   "));
+        assertNull(parser.feedLine("\t"));
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertTrue(result.isEmpty());
+    }
+    
+    // ========== Malformed Lines ==========
+    
+    @Test
+    public void testMalformedLineNoDelimiter() {
+        // Line without semicolon should be skipped
+        assertNull(parser.feedLine("sensor001_0xAB3311")); // No semicolon
+        assertNull(parser.feedLine("sensor002;0xEF0112")); // Valid
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size()); // Only the valid one
+        assertEquals("sensor002", result.get(0).getSensorId());
+    }
+    
+    @Test
+    public void testMalformedLineEmptySensorId() {
+        // Empty sensor ID should be skipped
+        assertNull(parser.feedLine(";0xAB3311")); // Empty sensorId
+        assertNull(parser.feedLine("sensor001;0xEF0112")); // Valid
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        assertEquals("sensor001", result.get(0).getSensorId());
+    }
+    
+    @Test
+    public void testMalformedLineEmptyHexCode() {
+        // Empty hex code should be skipped
+        assertNull(parser.feedLine("sensor001;")); // Empty hexCode
+        assertNull(parser.feedLine("sensor002;0xEF0112")); // Valid
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        assertEquals("sensor002", result.get(0).getSensorId());
+    }
+    
+    @Test
+    public void testMalformedLineBothEmpty() {
+        // Both parts empty should be skipped
+        assertNull(parser.feedLine(";")); // Both empty
+        assertNull(parser.feedLine("sensor001;0xEF0112")); // Valid
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+    }
+    
+    @Test
+    public void testLineWithMultipleDelimiters() {
+        // Multiple delimiters - should use first two parts
+        assertNull(parser.feedLine("sensor001;0xAB3311;extra_stuff"));
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        assertEquals("sensor001", result.get(0).getSensorId());
+        assertEquals("0xAB3311", result.get(0).getHexCode());
+    }
+    
+    @Test
+    public void testMixedValidInvalidLines() {
+        // Mix of valid and invalid lines
+        assertNull(parser.feedLine("sensor001;0xAB3311")); // Valid
+        assertNull(parser.feedLine("invalid_no_semicolon")); // Invalid
+        assertNull(parser.feedLine("sensor002;0xEF0112")); // Valid
+        assertNull(parser.feedLine(";empty_sensor")); // Invalid
+        assertNull(parser.feedLine("sensor003;0xBA3311")); // Valid
+        assertNull(parser.feedLine("no_hex;")); // Invalid
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(3, result.size());
+    }
+    
+    // ========== Whitespace Handling ==========
+    
+    @Test
+    public void testWhitespaceAroundDelimiter() {
+        // Whitespace around parts should be trimmed
+        assertNull(parser.feedLine("  sensor001  ;  0xAB3311  "));
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        assertEquals("sensor001", result.get(0).getSensorId());
+        assertEquals("0xAB3311", result.get(0).getHexCode());
+    }
+    
+    @Test
+    public void testWhitespaceAroundEndPacket() {
+        // Whitespace around END_PACKET should work
+        assertNull(parser.feedLine("sensor001;0xAB3311"));
+        
+        List<ParsedReading> result = parser.feedLine("  END_PACKET  ");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+    }
+    
+    // ========== Large Packets ==========
+    
+    @Test
+    public void testLargePacket() {
+        // Test with 100+ readings
+        int numReadings = 150;
+        for (int i = 0; i < numReadings; i++) {
+            assertNull(parser.feedLine("sensor" + String.format("%03d", i) + ";0xAB3311"));
+        }
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(numReadings, result.size());
+    }
+    
+    // ========== Buffer Overflow Protection ==========
+    
+    @Test
+    public void testBufferOverflowProtection() {
+        // Create parser with small max buffer
+        PacketParser smallParser = new PacketParser(5);
+        
+        // Feed more than max without END_PACKET
+        for (int i = 0; i < 6; i++) {
+            assertNull(smallParser.feedLine("sensor" + i + ";0xAB3311"));
+        }
+        
+        // At this point, buffer should have been cleared and only last reading should be there
+        // (First 5 readings, then on 6th, buffer cleared before adding)
+        
+        // The last reading (sensor5) should be in buffer
+        List<ParsedReading> result = smallParser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        // After clearing, only the reading that triggered overflow clearing is added
+        assertEquals(1, result.size());
+        assertEquals("sensor5", result.get(0).getSensorId());
+    }
+    
+    @Test
+    public void testCustomMaxBufferSize() {
+        PacketParser customParser = new PacketParser(10);
+        assertEquals(10, customParser.getMaxBufferSize());
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidMaxBufferSize() {
+        new PacketParser(0);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testNegativeMaxBufferSize() {
+        new PacketParser(-5);
+    }
+    
+    // ========== Multiple Consecutive Packets ==========
+    
+    @Test
+    public void testMultipleConsecutivePackets() {
+        // First packet
+        assertNull(parser.feedLine("sensor001;0xAB3311"));
+        assertNull(parser.feedLine("sensor002;0xEF0112"));
+        List<ParsedReading> result1 = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result1);
+        assertEquals(2, result1.size());
+        
+        // Buffer should be empty now
+        assertTrue(parser.isBufferEmpty());
+        
+        // Second packet
+        assertNull(parser.feedLine("sensor003;0xBA3311"));
+        List<ParsedReading> result2 = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result2);
+        assertEquals(1, result2.size());
+        assertEquals("sensor003", result2.get(0).getSensorId());
+        
+        // Third packet (empty)
+        List<ParsedReading> result3 = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result3);
+        assertTrue(result3.isEmpty());
+    }
+    
+    // ========== Reset Functionality ==========
+    
+    @Test
+    public void testReset() {
+        assertNull(parser.feedLine("sensor001;0xAB3311"));
+        assertNull(parser.feedLine("sensor002;0xEF0112"));
+        assertEquals(2, parser.getBufferSize());
+        
+        parser.reset();
+        
+        assertEquals(0, parser.getBufferSize());
+        assertTrue(parser.isBufferEmpty());
+        
+        // New packet after reset
+        assertNull(parser.feedLine("sensor003;0xBA3311"));
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        assertEquals("sensor003", result.get(0).getSensorId());
+    }
+    
+    // ========== Null Handling ==========
+    
+    @Test
+    public void testNullLine() {
+        assertNull(parser.feedLine(null));
+        assertEquals(0, parser.getBufferSize());
+    }
+    
+    // ========== Buffer State Methods ==========
+    
+    @Test
+    public void testGetBufferSize() {
+        assertEquals(0, parser.getBufferSize());
+        
+        parser.feedLine("sensor001;0xAB3311");
+        assertEquals(1, parser.getBufferSize());
+        
+        parser.feedLine("sensor002;0xEF0112");
+        assertEquals(2, parser.getBufferSize());
+        
+        parser.feedLine("END_PACKET");
+        assertEquals(0, parser.getBufferSize());
+    }
+    
+    @Test
+    public void testIsBufferEmpty() {
+        assertTrue(parser.isBufferEmpty());
+        
+        parser.feedLine("sensor001;0xAB3311");
+        assertFalse(parser.isBufferEmpty());
+        
+        parser.feedLine("END_PACKET");
+        assertTrue(parser.isBufferEmpty());
+    }
+    
+    @Test
+    public void testGetBufferContents() {
+        parser.feedLine("sensor001;0xAB3311");
+        parser.feedLine("sensor002;0xEF0112");
+        
+        List<ParsedReading> contents = parser.getBufferContents();
+        
+        assertEquals(2, contents.size());
+        assertEquals("sensor001", contents.get(0).getSensorId());
+        assertEquals("sensor002", contents.get(1).getSensorId());
+        
+        // Verify it's a copy (modifications don't affect internal buffer)
+        try {
+            contents.clear();
+        } catch (UnsupportedOperationException e) {
+            // Expected - unmodifiable list
+        }
+        assertEquals(2, parser.getBufferSize());
+    }
+    
+    // ========== Timestamp Testing ==========
+    
+    @Test
+    public void testTimestampIsSet() {
+        long before = System.currentTimeMillis();
+        parser.feedLine("sensor001;0xAB3311");
+        long after = System.currentTimeMillis();
+        
+        List<ParsedReading> result = parser.feedLine("END_PACKET");
+        
+        assertNotNull(result);
+        assertEquals(1, result.size());
+        
+        long timestamp = result.get(0).getReceivedTimestamp();
+        assertTrue("Timestamp should be >= before", timestamp >= before);
+        assertTrue("Timestamp should be <= after", timestamp <= after);
+    }
+}
diff --git a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/ParsedReadingTest.java b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/ParsedReadingTest.java
index 0f71e5e..fcadc8c 100644
--- a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/ParsedReadingTest.java
+++ b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/bluetooth/ParsedReadingTest.java
@@ -1,127 +1,127 @@
-package com.melisa.innovamotionapp.bluetooth;
-
-import static org.junit.Assert.*;
-
-import org.junit.Test;
-
-/**
- * Unit tests for ParsedReading data class.
- */
-public class ParsedReadingTest {
-    
-    @Test
-    public void testConstructorWithTimestamp() {
-        long timestamp = 1234567890L;
-        ParsedReading reading = new ParsedReading("sensor001", "0xAB3311", timestamp);
-        
-        assertEquals("sensor001", reading.getSensorId());
-        assertEquals("0xAB3311", reading.getHexCode());
-        assertEquals(timestamp, reading.getReceivedTimestamp());
-    }
-    
-    @Test
-    public void testConstructorWithoutTimestamp() {
-        long before = System.currentTimeMillis();
-        ParsedReading reading = new ParsedReading("sensor001", "0xAB3311");
-        long after = System.currentTimeMillis();
-        
-        assertEquals("sensor001", reading.getSensorId());
-        assertEquals("0xAB3311", reading.getHexCode());
-        assertTrue(reading.getReceivedTimestamp() >= before);
-        assertTrue(reading.getReceivedTimestamp() <= after);
-    }
-    
-    @Test
-    public void testTrimming() {
-        ParsedReading reading = new ParsedReading("  sensor001  ", "  0xAB3311  ", 0);
-        
-        assertEquals("sensor001", reading.getSensorId());
-        assertEquals("0xAB3311", reading.getHexCode());
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testNullSensorId() {
-        new ParsedReading(null, "0xAB3311", 0);
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testEmptySensorId() {
-        new ParsedReading("", "0xAB3311", 0);
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testWhitespaceSensorId() {
-        new ParsedReading("   ", "0xAB3311", 0);
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testNullHexCode() {
-        new ParsedReading("sensor001", null, 0);
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testEmptyHexCode() {
-        new ParsedReading("sensor001", "", 0);
-    }
-    
-    @Test(expected = IllegalArgumentException.class)
-    public void testWhitespaceHexCode() {
-        new ParsedReading("sensor001", "   ", 0);
-    }
-    
-    @Test
-    public void testEquals() {
-        ParsedReading reading1 = new ParsedReading("sensor001", "0xAB3311", 1000L);
-        ParsedReading reading2 = new ParsedReading("sensor001", "0xAB3311", 1000L);
-        ParsedReading reading3 = new ParsedReading("sensor002", "0xAB3311", 1000L);
-        ParsedReading reading4 = new ParsedReading("sensor001", "0xEF0112", 1000L);
-        ParsedReading reading5 = new ParsedReading("sensor001", "0xAB3311", 2000L);
-        
-        assertEquals(reading1, reading2);
-        assertNotEquals(reading1, reading3); // Different sensorId
-        assertNotEquals(reading1, reading4); // Different hexCode
-        assertNotEquals(reading1, reading5); // Different timestamp
-        assertNotEquals(reading1, null);
-        assertNotEquals(reading1, "string");
-    }
-    
-    @Test
-    public void testHashCode() {
-        ParsedReading reading1 = new ParsedReading("sensor001", "0xAB3311", 1000L);
-        ParsedReading reading2 = new ParsedReading("sensor001", "0xAB3311", 1000L);
-        
-        assertEquals(reading1.hashCode(), reading2.hashCode());
-    }
-    
-    @Test
-    public void testToString() {
-        ParsedReading reading = new ParsedReading("sensor001", "0xAB3311", 1000L);
-        String str = reading.toString();
-        
-        assertTrue(str.contains("sensor001"));
-        assertTrue(str.contains("0xAB3311"));
-        assertTrue(str.contains("1000"));
-    }
-    
-    @Test
-    public void testUuidSensorId() {
-        String uuid = "5d6d75ee-b6c8-42d4-a233-b13d137fea38";
-        ParsedReading reading = new ParsedReading(uuid, "0xAB3311", 0);
-        
-        assertEquals(uuid, reading.getSensorId());
-    }
-    
-    @Test
-    public void testVariousHexCodeFormats() {
-        // Different valid hex code formats
-        ParsedReading r1 = new ParsedReading("s1", "0xAB3311", 0);
-        ParsedReading r2 = new ParsedReading("s2", "0XAB3311", 0);
-        ParsedReading r3 = new ParsedReading("s3", "ab3311", 0);
-        ParsedReading r4 = new ParsedReading("s4", "AB3311", 0);
-        
-        assertEquals("0xAB3311", r1.getHexCode());
-        assertEquals("0XAB3311", r2.getHexCode());
-        assertEquals("ab3311", r3.getHexCode());
-        assertEquals("AB3311", r4.getHexCode());
-    }
-}
+package com.melisa.innovamotionapp.bluetooth;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+/**
+ * Unit tests for ParsedReading data class.
+ */
+public class ParsedReadingTest {
+    
+    @Test
+    public void testConstructorWithTimestamp() {
+        long timestamp = 1234567890L;
+        ParsedReading reading = new ParsedReading("sensor001", "0xAB3311", timestamp);
+        
+        assertEquals("sensor001", reading.getSensorId());
+        assertEquals("0xAB3311", reading.getHexCode());
+        assertEquals(timestamp, reading.getReceivedTimestamp());
+    }
+    
+    @Test
+    public void testConstructorWithoutTimestamp() {
+        long before = System.currentTimeMillis();
+        ParsedReading reading = new ParsedReading("sensor001", "0xAB3311");
+        long after = System.currentTimeMillis();
+        
+        assertEquals("sensor001", reading.getSensorId());
+        assertEquals("0xAB3311", reading.getHexCode());
+        assertTrue(reading.getReceivedTimestamp() >= before);
+        assertTrue(reading.getReceivedTimestamp() <= after);
+    }
+    
+    @Test
+    public void testTrimming() {
+        ParsedReading reading = new ParsedReading("  sensor001  ", "  0xAB3311  ", 0);
+        
+        assertEquals("sensor001", reading.getSensorId());
+        assertEquals("0xAB3311", reading.getHexCode());
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testNullSensorId() {
+        new ParsedReading(null, "0xAB3311", 0);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testEmptySensorId() {
+        new ParsedReading("", "0xAB3311", 0);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testWhitespaceSensorId() {
+        new ParsedReading("   ", "0xAB3311", 0);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testNullHexCode() {
+        new ParsedReading("sensor001", null, 0);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testEmptyHexCode() {
+        new ParsedReading("sensor001", "", 0);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void testWhitespaceHexCode() {
+        new ParsedReading("sensor001", "   ", 0);
+    }
+    
+    @Test
+    public void testEquals() {
+        ParsedReading reading1 = new ParsedReading("sensor001", "0xAB3311", 1000L);
+        ParsedReading reading2 = new ParsedReading("sensor001", "0xAB3311", 1000L);
+        ParsedReading reading3 = new ParsedReading("sensor002", "0xAB3311", 1000L);
+        ParsedReading reading4 = new ParsedReading("sensor001", "0xEF0112", 1000L);
+        ParsedReading reading5 = new ParsedReading("sensor001", "0xAB3311", 2000L);
+        
+        assertEquals(reading1, reading2);
+        assertNotEquals(reading1, reading3); // Different sensorId
+        assertNotEquals(reading1, reading4); // Different hexCode
+        assertNotEquals(reading1, reading5); // Different timestamp
+        assertNotEquals(reading1, null);
+        assertNotEquals(reading1, "string");
+    }
+    
+    @Test
+    public void testHashCode() {
+        ParsedReading reading1 = new ParsedReading("sensor001", "0xAB3311", 1000L);
+        ParsedReading reading2 = new ParsedReading("sensor001", "0xAB3311", 1000L);
+        
+        assertEquals(reading1.hashCode(), reading2.hashCode());
+    }
+    
+    @Test
+    public void testToString() {
+        ParsedReading reading = new ParsedReading("sensor001", "0xAB3311", 1000L);
+        String str = reading.toString();
+        
+        assertTrue(str.contains("sensor001"));
+        assertTrue(str.contains("0xAB3311"));
+        assertTrue(str.contains("1000"));
+    }
+    
+    @Test
+    public void testUuidSensorId() {
+        String uuid = "5d6d75ee-b6c8-42d4-a233-b13d137fea38";
+        ParsedReading reading = new ParsedReading(uuid, "0xAB3311", 0);
+        
+        assertEquals(uuid, reading.getSensorId());
+    }
+    
+    @Test
+    public void testVariousHexCodeFormats() {
+        // Different valid hex code formats
+        ParsedReading r1 = new ParsedReading("s1", "0xAB3311", 0);
+        ParsedReading r2 = new ParsedReading("s2", "0XAB3311", 0);
+        ParsedReading r3 = new ParsedReading("s3", "ab3311", 0);
+        ParsedReading r4 = new ParsedReading("s4", "AB3311", 0);
+        
+        assertEquals("0xAB3311", r1.getHexCode());
+        assertEquals("0XAB3311", r2.getHexCode());
+        assertEquals("ab3311", r3.getHexCode());
+        assertEquals("AB3311", r4.getHexCode());
+    }
+}
diff --git a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModelTest.java b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModelTest.java
index 4114055..11417d9 100644
--- a/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModelTest.java
+++ b/InnovaMotionApp/app/src/test/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModelTest.java
@@ -182,4 +182,49 @@ public class PersonNamesViewModelTest {
     private boolean areContentsTheSame(String sensorId1, String name1, String sensorId2, String name2) {
         return sensorId1.equals(sensorId2) && name1.equals(name2);
     }
+
+    // ========== Supervisor Assignment Map Tests ==========
+    
+    @Test
+    public void supervisorMap_getSupervisor_returnsEmail() {
+        java.util.Map<String, String> map = new java.util.HashMap<>();
+        map.put("sensor001", "supervisor@example.com");
+        
+        String result = map.get("sensor001");
+        
+        assertEquals("supervisor@example.com", result);
+    }
+    
+    @Test
+    public void supervisorMap_getSupervisor_notAssigned_returnsNull() {
+        java.util.Map<String, String> map = new java.util.HashMap<>();
+        
+        String result = map.get("sensor001");
+        
+        assertNull(result);
+    }
+    
+    @Test
+    public void supervisorMap_updateEntry_replacesOldValue() {
+        java.util.Map<String, String> map = new java.util.HashMap<>();
+        map.put("sensor001", "old@example.com");
+        
+        // Simulate update
+        map.put("sensor001", "new@example.com");
+        
+        assertEquals("new@example.com", map.get("sensor001"));
+        assertEquals(1, map.size());
+    }
+    
+    @Test
+    public void supervisorMap_removeEntry_setsToNull() {
+        java.util.Map<String, String> map = new java.util.HashMap<>();
+        map.put("sensor001", "supervisor@example.com");
+        
+        // Simulate unassign
+        map.remove("sensor001");
+        
+        assertNull(map.get("sensor001"));
+        assertEquals(0, map.size());
+    }
 }
diff --git a/InnovaMotionApp/build.gradle.kts b/InnovaMotionApp/build.gradle.kts
index c4f8066..eab457a 100644
--- a/InnovaMotionApp/build.gradle.kts
+++ b/InnovaMotionApp/build.gradle.kts
@@ -1,5 +1,5 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-plugins {
-    alias(libs.plugins.android.application) apply false
-    alias(libs.plugins.google.gms.google.services) apply false
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+plugins {
+    alias(libs.plugins.android.application) apply false
+    alias(libs.plugins.google.gms.google.services) apply false
 }
\ No newline at end of file
diff --git a/InnovaMotionApp/docs/Detailed Flow Narratives.md b/InnovaMotionApp/docs/Detailed Flow Narratives.md
index b078466..6c6b821 100644
--- a/InnovaMotionApp/docs/Detailed Flow Narratives.md	
+++ b/InnovaMotionApp/docs/Detailed Flow Narratives.md	
@@ -1,508 +1,508 @@
-
-## ğŸ“– Detailed Flow Narratives
-
-### 1. Entry Flow: LoginActivity â†’ MainActivity
-
-#### Starting Point: `LoginActivity.java`
-
-**User Journey**:
-1. **App launches** â†’ `LoginActivity.onCreate()` initializes Firebase Auth, CredentialManager, and UI components.
-2. **User clicks "Sign in with Google"** â†’ `signInWithGoogle()` is called.
-
-**What Happens** (step-by-step):
-
-##### Step 1: Google Sign-In
-- **Thread**: Background (async callback via CredentialManager)
-- **Actions**:
-  - `CredentialManager` requests Google ID token
-  - If successful, `handleSignInResult()` extracts the token â†’ calls `authenticateWithFirebase(idToken)`
-  - Firebase Auth signs in with the Google credential
-- **Outcomes**:
-  - **Success**: Firebase Auth completes, `mAuth.getCurrentUser()` is now non-null â†’ proceed to Step 2
-  - **Failure**: Show error toast (e.g., "Sign-in failed"), stay on `LoginActivity`
-
-##### Step 2: Check User in Firestore
-- **Thread**: Background (Firestore async)
-- **Actions**:
-  - `checkUserInFirestore(user)` queries `db.collection("users").document(user.getUid())`
-- **Outcomes**:
-  - **User document exists**: Continue to Step 3 (show role selection UI)
-  - **User document does NOT exist**: Call `createUserProfile(user)` â†’ save basic profile (UID, email, displayName) to Firestore â†’ then proceed to Step 3
-  - **Firestore error** (e.g., permission denied): Show error toast, possibly sign out user
-
-##### Step 3: Show Role Selection UI
-- **Thread**: UI thread
-- **Actions**:
-  - `showRoleSelectionUI(user)` hides sign-in button, shows "Welcome [name]" + role radio buttons
-  - **Pre-fill logic** (`fetchAndPreFillUserPreferences`):
-    - **Thread**: Background (Firestore get)
-    - If user doc has `role = "supervisor"` + `supervisedEmail`: Pre-fill email field, check "Supervisor" radio
-    - If user doc has `role = "supervised"`: Check "Supervised" radio, hide email field
-    - If neither: Default to "Supervised" checked
-- **User Interaction**:
-  - User can **change** the pre-filled selection
-  - If "Supervisor" selected: Email field becomes visible, shows autocomplete suggestions (queries Firestore for users with `role = "supervised"`)
-  - Autocomplete search: **Background thread** (Firestore query), debounced by 300ms
-
-##### Step 4: User Clicks "Continue" (`onProceed()`)
-
-**Validation** (UI thread):
-- **Common**: Role must be selected (one radio button checked)
-- **Supervisor-specific**:
-  - Email field must not be empty
-  - Email must match Gmail format (`^[A-Za-z0-9+_.-]+@gmail\\.com$`)
-  - If validation fails: Show inline error, stay on screen
-
-**If Validation Passes**:
-- **Thread**: Background (Firestore update)
-- **Actions**:
-  - `saveUserRole(user, role, supervisedEmail)` updates Firestore:
-    - `role`: "supervised" or "supervisor"
-    - `lastSelectedRole`: Same as `role` (for future pre-filling)
-    - `supervisedEmail`: Set if supervisor, null otherwise
-    - `lastSignIn`: Current timestamp
-- **Outcomes**:
-  - **Success**: Proceed to Step 5
-  - **Failure**: Show error toast, re-enable buttons, stay on screen
-
-##### Step 5: Initialize SessionGate
-- **Thread**: UI thread (singleton init), then background (session loading)
-- **Actions**:
-  - `SessionGate.getInstance(context)` creates the singleton (if not exists)
-  - SessionGate's constructor sets up a Firebase Auth state listener (background callback)
-  - Listener detects authenticated user â†’ calls `handleUserAuthenticated(user)`
-
-##### Step 6: Load User Session
-- **Thread**: Background (Firestore get + query)
-- **Actions** (`UserSession.loadUserSession()`):
-  1. Fetch user doc from `users` collection
-  2. Extract `role` field
-  3. **If supervisor**:
-     - Try to get `supervisedUserIds` array (list of UIDs)
-     - If array is empty/null, try `supervisedEmail` field â†’ query `users` collection for matching email â†’ resolve to UID
-     - Cache `supervisedUserIds = ["childUid1", "childUid2", ...]`
-  4. **If supervised**:
-     - Cache `supervisedUserIds = []` (empty list)
-- **Outcomes**:
-  - **Success**: `onSessionLoaded(userId, role, supervisedUserIds)` callback â†’ proceed to Step 7
-  - **Failure**: `onSessionLoadError(error)` â†’ session not ready, but app continues (user may see degraded experience)
-
-##### Step 7: Run Post-Auth Bootstrap
-- **Thread**: Background (executorService)
-- **Actions** (`SessionGate.runPostAuthBootstrap()`):
-
-**Path A: Supervised User** (`runSupervisedPipeline()`):
-1. Call `FirestoreSyncService.backfillLocalFromCloudForCurrentUser()`
-   - **Thread**: Background
-   - **Actions**:
-     - Query Firestore `bluetooth_messages` collection: `where userId = currentUserId AND timestamp > localMaxTimestamp`
-     - Convert Firestore docs to `ReceivedBtDataEntity`
-     - Insert into Room database (local SQLite)
-   - **Why**: Restore historical data if user reinstalled app or cleared data
-2. Backfill completes â†’ log success/failure
-3. Proceed to Step 8
-
-**Path B: Supervisor User** (`runSupervisorPipeline()`):
-1. Call `FirestoreSyncService.purgeAndBackfillForSupervisor(supervisedUserIds)`
-   - **Thread**: Background
-   - **Actions**:
-     a. **Purge old data**: Delete all Room rows where `owner_user_id NOT IN supervisedUserIds`
-        - **Why**: Clean up data from previously supervised users who are no longer monitored
-     b. **Backfill for each supervised UID**:
-        - For each `childUid` in `supervisedUserIds`:
-          - Query Firestore `bluetooth_messages`: `where userId = childUid AND timestamp > localMaxTimestamp`
-          - Insert into Room with `owner_user_id = childUid`
-        - **Why**: Download supervised users' data to local Room so supervisor can view offline
-     c. **Start real-time mirrors**:
-        - For each `childUid`, attach a Firestore snapshot listener: `collection("bluetooth_messages").whereEqualTo("userId", childUid).orderBy("timestamp")`
-        - **Why**: Automatically download new messages as supervised users upload them
-2. Backfill completes â†’ mirrors active â†’ log success
-3. Proceed to Step 8
-
-##### Step 8: Navigate to MainActivity
-- **Thread**: UI thread
-- **Actions**:
-  - `navigateToMainActivity()` creates an `Intent` with flags `FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK`
-  - **Why flags**: Clear entire back stack so user can't navigate back to LoginActivity
-  - `startActivity(intent)` â†’ `finish()` (LoginActivity destroyed)
-- **Outcome**: User now sees `MainActivity.java`
-
----
-
-### 2. MainActivity â†’ Launch Monitoring
-
-**User Action**: User clicks "Launch Monitoring" button in `MainActivity`
-
-**What Happens**:
-
-##### Step 1: Check Session Readiness
-- **Thread**: UI thread (SessionGate check)
-- **Actions**:
-  - `SessionGate.getInstance(this).waitForSessionReady(callback)`
-  - **If session is ready**: Callback `onSessionReady(userId, role, supervisedUserIds)` fires â†’ proceed to Step 2
-  - **If session is NOT ready**: Callback `onSessionError(error)` fires â†’ fallback to supervised flow (route to `BtSettingsActivity`)
-
-##### Step 2: Route Based on Role
-
-**Path A: Supervised User**:
-- **Target**: `BtSettingsActivity.java`
-- **Why**: Supervised user needs to scan for and connect to a Bluetooth device
-- **Navigation**: `Intent` to `BtSettingsActivity`
-
-**Path B: Supervisor User**:
-- **Target**: `BtConnectedActivity.java` (skip Bluetooth setup entirely)
-- **Why**: Supervisor views data from Room database (no physical device needed)
-- **Navigation**: `Intent` to `BtConnectedActivity` with flags `FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_SINGLE_TOP`
-
----
-
-### 3. Bluetooth Message Pipeline (Supervised User)
-
-**Assumption**: User has successfully connected a Bluetooth device via `BtSettingsActivity` â†’ `DeviceCommunicationService` is running as a foreground service.
-
-#### Stage 1: Bluetooth Connection (`DeviceCommunicationThread.java`)
-
-**Thread**: Background (dedicated Bluetooth thread)
-
-**Lifecycle**:
-1. **Connect**: `socket.connect()` â†’ `onConnectionEstablished(device)` callback
-   - Update foreground notification: "Connected to [Device Name]"
-   - Set global flag `isConnectedDevice = true`
-2. **Receive Data**: `BufferedReader.readLine()` in infinite loop
-   - Each line (terminated by `\n` or `\r\n`) triggers `onDataReceived(device, receivedData)` callback
-   - **Threading**: Still on Bluetooth thread
-3. **Disconnect**: On error or stream close â†’ `onConnectionDisconnected()` callback
-   - Retry connection up to 2 times
-   - If max retries exceeded: Stop service
-
-#### Stage 2: Message Received â†’ Add to Batch Queue
-
-**File**: `DeviceCommunicationService.java`, method: `onDataReceived()`
-
-**Thread**: Background (Bluetooth callback thread)
-
-**Actions**:
-1. **Parse message**: Extract raw hex string (e.g., `"0xAB3311"`)
-2. **Create entity**:
-   ```
-   ReceivedBtDataEntity(
-     deviceAddress = device.getAddress(),
-     timestamp = System.currentTimeMillis(),
-     receivedMsg = receivedData,
-     owner_user_id = currentUserId // if supervised
-   )
-   ```
-3. **Add to batch queue**:
-   - `synchronized (lock) { temporaryReceivedBtDataListToSave.add(entity); }`
-   - **Why synchronized**: Batch-saving thread accesses the same list concurrently
-4. **Side effects**:
-   - Parse posture type (via `PostureFactory.createPosture(receivedData)`)
-   - Update `GlobalData.setReceivedPosture(posture)` â†’ triggers LiveData observers in UI
-   - If posture is "falling", show local notification
-
-**Open Question**: What happens if the batch queue grows faster than 500ms can drain it? (e.g., device sends 100 messages in 100ms)  
-**Assumption**: Queue keeps growing until next batch cycle; no explicit size limit observed in code.
-
-#### Stage 3: Batch-Saving Thread (Every 500ms)
-
-**File**: `DeviceCommunicationService.java`, background thread started in `onCreate()`
-
-**Thread**: Background (dedicated thread with `while` loop)
-
-**Timing**: `Constants.COUNTDOWN_TIMER_IN_MILLISECONDS_FOR_MESSAGE_SAVE = 500` ms
-
-**Actions** (per cycle):
-1. **Sleep**: `Thread.sleep(500)`
-2. **Copy and clear queue**:
-   ```
-   synchronized (lock) {
-     currentBatch = new ArrayList<>(temporaryReceivedBtDataListToSave);
-     temporaryReceivedBtDataListToSave.clear();
-   }
-   ```
-3. **If batch is not empty**:
-   - **Save to Room**: `database.receivedBtDataDao().insertAll(currentBatch)`
-     - **Threading**: Synchronous Room insert (blocks this thread, but it's already background)
-     - **Strategy**: `@Insert(onConflict = OnConflictStrategy.IGNORE)` â†’ duplicates are silently skipped
-   - **Sync each message to Firestore**:
-     - Loop over `currentBatch`
-     - For each entity: `firestoreSyncService.syncNewMessage(entity, callback)`
-       - **Threading**: Spawns new background task on `executorService`
-       - **Callback**: Logs success/error (non-blocking)
-4. **If batch is empty**: No-op, wait for next cycle
-
-**Outcome**: All messages are **guaranteed to be saved to Room** (local persistence). Firebase upload is **best-effort** (may fail if offline).
-
-#### Stage 4: Sync to Firebase (`FirestoreSyncService.java`, method: `syncNewMessage()`)
-
-**Thread**: Background (executorService)
-
-**Preconditions** (checked in order):
-1. User is authenticated? **No** â†’ callback `onError("User not authenticated")`
-2. UserSession is loaded? **No** â†’ callback `onError("User session not loaded")`
-3. User is supervised? **No** â†’ callback `onSuccess("User is not supervised, no sync needed")` (supervisors don't upload)
-4. Network is connected? **No** â†’ callback `onSuccess("Message saved locally, will sync when online")`
-
-**If all preconditions pass**:
-- **Actions**:
-  1. Convert `ReceivedBtDataEntity` to `FirestoreDataModel`
-  2. Generate document ID: `"<userId>_<timestamp>_<deviceAddress>"`
-  3. Call `firestore.collection("bluetooth_messages").document(documentId).set(firestoreModel)`
-     - **Threading**: Firestore async operation (callback on background thread)
-- **Outcomes**:
-  - **Success**: Callback `onSuccess("Message synced successfully")`
-  - **Failure**: Callback `onError("Failed to sync to Firestore: [error]")` â†’ message stays in Room for later retry
-
-#### Stage 5: Offline â†’ Online Transition (Retry Logic)
-
-**Trigger**: `NetworkConnectivityMonitor` detects connectivity restored
-
-**Actions**:
-- `FirestoreSyncService.handleConnectivityRestored()` (background thread)
-- **If user is supervised**:
-  - Call `syncLocalDataToFirestore()`
-    - Query Room for all local messages
-    - Check which docs already exist in Firestore (batch query)
-    - Upload only missing messages (batch write, max 500 per batch)
-- **If user is supervisor**:
-  - Call `startSupervisorMirrors()` (re-attach listeners if they were stopped)
-
-**Outcome**: Local Room database eventually syncs with Firestore when network is stable.
-
----
-
-### 4. Supervisor Real-Time Mirror Pipeline
-
-**Context**: After supervisor completes login and backfill, real-time mirrors are active for each supervised user.
-
-#### Stage 1: Mirror Listener Attached
-
-**File**: `FirestoreSyncService.java`, method: `startSupervisorMirror()`
-
-**Thread**: Background (Firestore snapshot listener callback)
-
-**Actions**:
-1. Attach Firestore snapshot listener for each supervised UID:
-   - Query: `collection("bluetooth_messages").whereEqualTo("userId", supervisedUserId).orderBy("timestamp")`
-   - Listener fires on **every change** (new message added, existing message modified)
-2. Store listener registration in `mirrorByUid` map for cleanup later
-3. **Deduplication**: Check if mirror already active for this UID (skip if already listening)
-
-**Trigger**: New message uploaded by supervised user â†’ Firestore sends snapshot update â†’ listener callback fires
-
-#### Stage 2: Process Document Changes (`handleSupervisorDocumentChanges()`)
-
-**File**: `FirestoreSyncService.java`, method: `handleSupervisorDocumentChanges()`
-
-**Thread**: Background (executorService)
-
-**This is the critical function that processes real-time updates from supervised users.**
-
-**Actions** (for each document change):
-
-##### Step 1: Filter Document Changes
-- Loop through all `documentChanges` in the snapshot
-- Process only `ADDED` or `MODIFIED` types (ignore `REMOVED`)
-- **Why**: We want new messages and updates, but deletions are rare/unsupported
-
-##### Step 2: Convert Firestore Doc to Entity
-- Parse Firestore document into `FirestoreDataModel`
-- Extract: `deviceAddress`, `timestamp`, `receivedMsg`, `userId`
-
-##### Step 3: Deduplication Check
-- **Critical**: Query Room database to check if message already exists locally
-- Call: `dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg)`
-- **Returns**: `0` if not exists, `1` if exists
-- **Why**: Firestore listeners can fire multiple times for the same doc (e.g., on reconnect, cache vs server updates)
-
-##### Step 4: Create Room Entity with Owner Mapping
-- **Only if message doesn't exist** (dedup check passed):
-  ```
-  ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
-    deviceAddress,
-    timestamp,
-    receivedMsg,
-    supervisedUserId  // <- CRITICAL: owner_user_id set to supervised user's UID
-  )
-  ```
-- Add entity to `entitiesToInsert` list
-- **Why owner mapping matters**: Supervisor's Room database contains messages from **multiple** supervised users. Each row must be tagged with `owner_user_id` so queries can filter by supervised user.
-
-##### Step 5: Fall Detection and Notification (if applicable)
-
-**Condition**: Message is recent (within 24 hours) AND looks like a fall
-
-**Actions**:
-1. **Parse posture type**: `PostureFactory.createPosture(receivedMsg)`
-2. **Check if fall**: `if (posture instanceof FallingPosture)`
-3. **If fall detected**:
-   - **Fetch supervised user's email** (async Firestore query to `users` collection)
-     - **Thread**: Background (Firestore get callback)
-     - **Success**: Use email in notification text (e.g., "child@gmail.com has fallen")
-     - **Failure**: Fallback to UID in notification text
-   - **Show notification** on supervisor's device:
-     - `AlertNotifications.notifyFall(context, who, body)`
-     - **Threading**: Notification shown on UI thread via system notification manager
-     - **Why**: Alert supervisor immediately so they can check on supervised user
-
-**Fall Detection Logic**:
-- Recent threshold: `RECENT_MS = 60_000 * 1 * 60 * 24` (24 hours)
-  - **Why 24 hours?**: Supervisor may be offline when fall occurs; notification still shown when they come back online if within 24h
-- Only notify if `(now - timestamp) <= RECENT_MS` AND message is a fall posture
-- **Threading note**: Firestore email lookup and notification happen **asynchronously** (don't block the mirror pipeline)
-
-##### Step 6: Batch Insert into Room
-- After processing all document changes, insert all new entities:
-  - `dao.insertAll(entitiesToInsert)`
-  - **Strategy**: `@Insert(onConflict = OnConflictStrategy.IGNORE)` (duplicates silently skipped)
-- **Verification logging**: Query Room to confirm inserts: `dao.dbgCountForOwner(supervisedUserId)`
-
-**Outcome**: 
-- Supervisor's Room database now contains the new messages (tagged with `owner_user_id`)
-- If any falls detected, supervisor receives local notification
-- `BtConnectedActivity` (if open) observes Room LiveData â†’ UI updates automatically to show latest posture
-
-#### Stage 3: UI Update (if BtConnectedActivity is open)
-
-**File**: `BtConnectedActivity.java`, observes `SupervisorFeedViewModel.getLatestPosture()`
-
-**Thread**: UI thread (LiveData observer)
-
-**Actions**:
-1. `SupervisorFeedViewModel` queries Room for latest message (filtered by target supervised user)
-2. LiveData emits new `Posture` object
-3. `BtConnectedActivity.displayPostureData()` updates UI:
-   - Shows posture description (e.g., "Falling detected")
-   - Updates risk level text
-   - Plays/stops video animation
-
-**Why this matters**: Supervisor sees **real-time updates** without refreshing the screen. As supervised user's device uploads messages, supervisor's device automatically downloads and displays them.
-
----
-
-### 5. Supervisor Mirror Lifecycle Management
-
-#### Mirror Start Conditions
-- **Trigger 1**: After backfill completes during login (via `purgeAndBackfillForSupervisor()`)
-- **Trigger 2**: When network connectivity is restored (via `handleConnectivityRestored()`)
-
-#### Mirror Stop Conditions
-- **Trigger 1**: User signs out (`SessionGate.handleUserSignedOut()` â†’ `stopAllMirrors()`)
-- **Trigger 2**: Network connectivity lost (listener automatically pauses, stopped explicitly by `stopAllMirrors()`)
-- **Trigger 3**: App is destroyed/closed
-
-#### Cleanup
-**File**: `FirestoreSyncService.java`, method: `stopAllMirrors()`
-
-**Actions**:
-1. Loop through all active listeners in `mirrorByUid` map
-2. Call `listener.remove()` for each (detaches Firestore listener)
-3. Clear `mirrorByUid` map and `startingUids` set
-4. Set `isSupervisorSyncActive = false`
-
-**Why proper cleanup matters**: Prevents memory leaks and ensures old listeners don't fire after role change or sign-out.
-
----
-
-## ğŸ” Decision Points & Branches Summary
-
-### Key Decision Point 1: User Role Selection
-**Location**: `LoginActivity.onProceed()`
-
-| Condition | Path | Actions | Next State |
-|-----------|------|---------|------------|
-| Role = supervised | Supervised flow | Save role â†’ Load session â†’ Backfill own data â†’ Navigate to MainActivity | User can connect Bluetooth device |
-| Role = supervisor + valid email | Supervisor flow | Save role + email â†’ Load session â†’ Resolve email to UID â†’ Purge old data â†’ Backfill supervised users' data â†’ Start mirrors â†’ Navigate to MainActivity | User can monitor supervised users |
-| Role = supervisor + invalid email | Error | Show inline error | Stay on LoginActivity |
-
-### Key Decision Point 2: Launch Monitoring from MainActivity
-**Location**: `MainActivity.LaunchMonitoring()`
-
-| User Role | SessionGate Ready? | Destination | Reason |
-|-----------|-------------------|-------------|--------|
-| Supervised | Yes | BtSettingsActivity | Scan for Bluetooth device |
-| Supervised | No | BtSettingsActivity | Fallback (session error) |
-| Supervisor | Yes | BtConnectedActivity | View Room data (no BT needed) |
-| Supervisor | No | BtSettingsActivity | Fallback (session error) |
-
-### Key Decision Point 3: Sync Message to Firestore
-**Location**: `FirestoreSyncService.syncNewMessage()`
-
-| Condition | Action | Outcome |
-|-----------|--------|---------|
-| User authenticated + supervised + online | Upload to Firestore | Message in cloud + local |
-| User supervised + offline | Skip upload | Message in local Room only (retry later) |
-| User is supervisor | Skip upload | Supervisor doesn't upload their own messages |
-| User not authenticated | Skip upload | Message in local Room only |
-
-### Key Decision Point 4: Supervisor Mirror Document Processing
-**Location**: `FirestoreSyncService.handleSupervisorDocumentChanges()`
-
-| Stage | Condition | True Outcome | False Outcome | Side Effects | Threading |
-|-------|-----------|--------------|---------------|--------------|-----------|
-| Filter Changes | Change type is ADDED or MODIFIED? | Process document | Skip document | None | Background (executorService) |
-| Deduplication | Message already exists in Room? | Skip insert | Continue to create entity | None | Background (Room query) |
-| Fall Detection | Message is recent AND posture is FallingPosture? | Fetch supervised user email â†’ Show notification | No notification | Local notification shown to supervisor | Background (Firestore get) + UI thread (notification) |
-| Email Fetch (if fall) | Supervised user doc has email field? | Use email in notification text | Use UID in notification text | None | Background (Firestore get callback) |
-| Insert to Room | Batch insert succeeds? | New messages available to supervisor | Log error | Room database updated, LiveData observers notified | Background (Room insert) |
-
----
-
-## âš™ï¸ Threading Summary
-
-| Component | Thread Type | Why |
-|-----------|-------------|-----|
-| `LoginActivity.signInWithGoogle()` | Background (CredentialManager callback) | Network call to Google Auth |
-| `LoginActivity.checkUserInFirestore()` | Background (Firestore async) | Network call to Firebase |
-| `LoginActivity.fetchAndPreFillUserPreferences()` | Background (Firestore async) | Network call to Firebase |
-| `SessionGate.handleUserAuthenticated()` | Background (executorService) | Loads session + starts backfill |
-| `UserSession.loadUserSession()` | Background (executorService) | Queries Firestore for user profile |
-| `FirestoreSyncService.backfillLocalFromCloudForCurrentUser()` | Background (executorService) | Downloads historical data |
-| `FirestoreSyncService.purgeAndBackfillForSupervisor()` | Background (executorService) | Purges Room + downloads supervised users' data |
-| `FirestoreSyncService.startSupervisorMirror()` | Background (Firestore snapshot listener) | Real-time sync |
-| `DeviceCommunicationThread` | Background (dedicated thread) | Bluetooth I/O (blocking socket operations) |
-| `DeviceCommunicationService` batch-saving thread | Background (dedicated thread with sleep loop) | Periodic Room inserts + Firestore uploads |
-| `FirestoreSyncService.syncNewMessage()` | Background (executorService) | Non-blocking Firestore upload |
-| `FirestoreSyncService.handleSupervisorDocumentChanges()` | Background (executorService) + async callbacks | Processes Firestore snapshot changes, checks duplicates, detects falls, inserts to Room |
-
-**Rule of thumb**: All Firestore, Room, and Bluetooth operations happen on **background threads**. Only UI updates (show/hide buttons, navigation) happen on **UI thread** (via `runOnUiThread()`).
-
----
-
-## ğŸš¨ Open Questions & Assumptions
-
-### Open Questions
-
-1. **Batch queue overflow**: If Bluetooth device sends > 500 messages in 500ms, does the queue grow unbounded? Is there a max size or backpressure mechanism?
-   - **Code location**: `DeviceCommunicationService.temporaryReceivedBtDataListToSave` (no size check observed)
-
-2. **Supervisor mirror lifecycle**: If a supervisor signs out and signs back in with a different supervised email, are old mirrors properly cleaned up?
-   - **Observed**: `SessionGate.handleUserSignedOut()` calls `stopAllMirrors()` and `clearLocalData()` (seems safe)
-
-3. **Network retry strategy**: When offline messages are retried via `syncLocalDataToFirestore()`, is there exponential backoff or rate limiting?
-   - **Code location**: `FirestoreSyncService.syncLocalDataToFirestore()` (no backoff observed, appears to be one-shot batch upload)
-
-4. **Room database migration**: What happens if the Room schema changes between app versions?
-   - **Not covered in current files** (would need to check `InnovaDatabase.java` migrations)
-
-5. **Fall notification timing**: If supervisor is offline and multiple falls occur within 24 hours, will they receive multiple notifications when they come back online?
-   - **Code location**: `FirestoreSyncService.handleSupervisorDocumentChanges()` line 1127
-   - **Observed behavior**: Each fall message within 24h window triggers notification check (potential for notification spam)
-   - **Suggestion**: Consider tracking "already notified" falls to prevent duplicate alerts
-
-### Assumptions
-
-- **Assumption 1**: Firebase Auth tokens are cached offline, so `FirebaseAuth.getCurrentUser()` returns non-null even without network (after initial sign-in).
-  - **Evidence**: Code comment in `DeviceCommunicationService` line 188: "Firebase caches UID offline"
-
-- **Assumption 2**: The 500ms batch timer starts when `DeviceCommunicationService.onCreate()` is called (when service is bound/started).
-  - **Evidence**: Thread creation in `onCreate()` (line 57)
-
-- **Assumption 3**: Supervised users' messages are uploaded to Firestore with `userId = currentUserId`, allowing supervisors to query by `whereEqualTo("userId", supervisedUserId)`.
-  - **Evidence**: `FirestoreDataModel` constructor (line 204-209) and mirror query (line 1029)
-
-- **Assumption 4**: The supervised email autocomplete popup shows **all** users with `role = "supervised"`, not just users the current supervisor is authorized to monitor.
-  - **Evidence**: Query in `searchSupervisedUsers()` (line 676-678) has no additional filters
-
----
-
+
+## ğŸ“– Detailed Flow Narratives
+
+### 1. Entry Flow: LoginActivity â†’ MainActivity
+
+#### Starting Point: `LoginActivity.java`
+
+**User Journey**:
+1. **App launches** â†’ `LoginActivity.onCreate()` initializes Firebase Auth, CredentialManager, and UI components.
+2. **User clicks "Sign in with Google"** â†’ `signInWithGoogle()` is called.
+
+**What Happens** (step-by-step):
+
+##### Step 1: Google Sign-In
+- **Thread**: Background (async callback via CredentialManager)
+- **Actions**:
+  - `CredentialManager` requests Google ID token
+  - If successful, `handleSignInResult()` extracts the token â†’ calls `authenticateWithFirebase(idToken)`
+  - Firebase Auth signs in with the Google credential
+- **Outcomes**:
+  - **Success**: Firebase Auth completes, `mAuth.getCurrentUser()` is now non-null â†’ proceed to Step 2
+  - **Failure**: Show error toast (e.g., "Sign-in failed"), stay on `LoginActivity`
+
+##### Step 2: Check User in Firestore
+- **Thread**: Background (Firestore async)
+- **Actions**:
+  - `checkUserInFirestore(user)` queries `db.collection("users").document(user.getUid())`
+- **Outcomes**:
+  - **User document exists**: Continue to Step 3 (show role selection UI)
+  - **User document does NOT exist**: Call `createUserProfile(user)` â†’ save basic profile (UID, email, displayName) to Firestore â†’ then proceed to Step 3
+  - **Firestore error** (e.g., permission denied): Show error toast, possibly sign out user
+
+##### Step 3: Show Role Selection UI
+- **Thread**: UI thread
+- **Actions**:
+  - `showRoleSelectionUI(user)` hides sign-in button, shows "Welcome [name]" + role radio buttons
+  - **Pre-fill logic** (`fetchAndPreFillUserPreferences`):
+    - **Thread**: Background (Firestore get)
+    - If user doc has `role = "supervisor"` + `supervisedEmail`: Pre-fill email field, check "Supervisor" radio
+    - If user doc has `role = "supervised"`: Check "Supervised" radio, hide email field
+    - If neither: Default to "Supervised" checked
+- **User Interaction**:
+  - User can **change** the pre-filled selection
+  - If "Supervisor" selected: Email field becomes visible, shows autocomplete suggestions (queries Firestore for users with `role = "supervised"`)
+  - Autocomplete search: **Background thread** (Firestore query), debounced by 300ms
+
+##### Step 4: User Clicks "Continue" (`onProceed()`)
+
+**Validation** (UI thread):
+- **Common**: Role must be selected (one radio button checked)
+- **Supervisor-specific**:
+  - Email field must not be empty
+  - Email must match Gmail format (`^[A-Za-z0-9+_.-]+@gmail\\.com$`)
+  - If validation fails: Show inline error, stay on screen
+
+**If Validation Passes**:
+- **Thread**: Background (Firestore update)
+- **Actions**:
+  - `saveUserRole(user, role, supervisedEmail)` updates Firestore:
+    - `role`: "supervised" or "supervisor"
+    - `lastSelectedRole`: Same as `role` (for future pre-filling)
+    - `supervisedEmail`: Set if supervisor, null otherwise
+    - `lastSignIn`: Current timestamp
+- **Outcomes**:
+  - **Success**: Proceed to Step 5
+  - **Failure**: Show error toast, re-enable buttons, stay on screen
+
+##### Step 5: Initialize SessionGate
+- **Thread**: UI thread (singleton init), then background (session loading)
+- **Actions**:
+  - `SessionGate.getInstance(context)` creates the singleton (if not exists)
+  - SessionGate's constructor sets up a Firebase Auth state listener (background callback)
+  - Listener detects authenticated user â†’ calls `handleUserAuthenticated(user)`
+
+##### Step 6: Load User Session
+- **Thread**: Background (Firestore get + query)
+- **Actions** (`UserSession.loadUserSession()`):
+  1. Fetch user doc from `users` collection
+  2. Extract `role` field
+  3. **If supervisor**:
+     - Try to get `supervisedUserIds` array (list of UIDs)
+     - If array is empty/null, try `supervisedEmail` field â†’ query `users` collection for matching email â†’ resolve to UID
+     - Cache `supervisedUserIds = ["childUid1", "childUid2", ...]`
+  4. **If supervised**:
+     - Cache `supervisedUserIds = []` (empty list)
+- **Outcomes**:
+  - **Success**: `onSessionLoaded(userId, role, supervisedUserIds)` callback â†’ proceed to Step 7
+  - **Failure**: `onSessionLoadError(error)` â†’ session not ready, but app continues (user may see degraded experience)
+
+##### Step 7: Run Post-Auth Bootstrap
+- **Thread**: Background (executorService)
+- **Actions** (`SessionGate.runPostAuthBootstrap()`):
+
+**Path A: Supervised User** (`runSupervisedPipeline()`):
+1. Call `FirestoreSyncService.backfillLocalFromCloudForCurrentUser()`
+   - **Thread**: Background
+   - **Actions**:
+     - Query Firestore `bluetooth_messages` collection: `where userId = currentUserId AND timestamp > localMaxTimestamp`
+     - Convert Firestore docs to `ReceivedBtDataEntity`
+     - Insert into Room database (local SQLite)
+   - **Why**: Restore historical data if user reinstalled app or cleared data
+2. Backfill completes â†’ log success/failure
+3. Proceed to Step 8
+
+**Path B: Supervisor User** (`runSupervisorPipeline()`):
+1. Call `FirestoreSyncService.purgeAndBackfillForSupervisor(supervisedUserIds)`
+   - **Thread**: Background
+   - **Actions**:
+     a. **Purge old data**: Delete all Room rows where `owner_user_id NOT IN supervisedUserIds`
+        - **Why**: Clean up data from previously supervised users who are no longer monitored
+     b. **Backfill for each supervised UID**:
+        - For each `childUid` in `supervisedUserIds`:
+          - Query Firestore `bluetooth_messages`: `where userId = childUid AND timestamp > localMaxTimestamp`
+          - Insert into Room with `owner_user_id = childUid`
+        - **Why**: Download supervised users' data to local Room so supervisor can view offline
+     c. **Start real-time mirrors**:
+        - For each `childUid`, attach a Firestore snapshot listener: `collection("bluetooth_messages").whereEqualTo("userId", childUid).orderBy("timestamp")`
+        - **Why**: Automatically download new messages as supervised users upload them
+2. Backfill completes â†’ mirrors active â†’ log success
+3. Proceed to Step 8
+
+##### Step 8: Navigate to MainActivity
+- **Thread**: UI thread
+- **Actions**:
+  - `navigateToMainActivity()` creates an `Intent` with flags `FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK`
+  - **Why flags**: Clear entire back stack so user can't navigate back to LoginActivity
+  - `startActivity(intent)` â†’ `finish()` (LoginActivity destroyed)
+- **Outcome**: User now sees `MainActivity.java`
+
+---
+
+### 2. MainActivity â†’ Launch Monitoring
+
+**User Action**: User clicks "Launch Monitoring" button in `MainActivity`
+
+**What Happens**:
+
+##### Step 1: Check Session Readiness
+- **Thread**: UI thread (SessionGate check)
+- **Actions**:
+  - `SessionGate.getInstance(this).waitForSessionReady(callback)`
+  - **If session is ready**: Callback `onSessionReady(userId, role, supervisedUserIds)` fires â†’ proceed to Step 2
+  - **If session is NOT ready**: Callback `onSessionError(error)` fires â†’ fallback to supervised flow (route to `BtSettingsActivity`)
+
+##### Step 2: Route Based on Role
+
+**Path A: Supervised User**:
+- **Target**: `BtSettingsActivity.java`
+- **Why**: Supervised user needs to scan for and connect to a Bluetooth device
+- **Navigation**: `Intent` to `BtSettingsActivity`
+
+**Path B: Supervisor User**:
+- **Target**: `BtConnectedActivity.java` (skip Bluetooth setup entirely)
+- **Why**: Supervisor views data from Room database (no physical device needed)
+- **Navigation**: `Intent` to `BtConnectedActivity` with flags `FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_SINGLE_TOP`
+
+---
+
+### 3. Bluetooth Message Pipeline (Supervised User)
+
+**Assumption**: User has successfully connected a Bluetooth device via `BtSettingsActivity` â†’ `DeviceCommunicationService` is running as a foreground service.
+
+#### Stage 1: Bluetooth Connection (`DeviceCommunicationThread.java`)
+
+**Thread**: Background (dedicated Bluetooth thread)
+
+**Lifecycle**:
+1. **Connect**: `socket.connect()` â†’ `onConnectionEstablished(device)` callback
+   - Update foreground notification: "Connected to [Device Name]"
+   - Set global flag `isConnectedDevice = true`
+2. **Receive Data**: `BufferedReader.readLine()` in infinite loop
+   - Each line (terminated by `\n` or `\r\n`) triggers `onDataReceived(device, receivedData)` callback
+   - **Threading**: Still on Bluetooth thread
+3. **Disconnect**: On error or stream close â†’ `onConnectionDisconnected()` callback
+   - Retry connection up to 2 times
+   - If max retries exceeded: Stop service
+
+#### Stage 2: Message Received â†’ Add to Batch Queue
+
+**File**: `DeviceCommunicationService.java`, method: `onDataReceived()`
+
+**Thread**: Background (Bluetooth callback thread)
+
+**Actions**:
+1. **Parse message**: Extract raw hex string (e.g., `"0xAB3311"`)
+2. **Create entity**:
+   ```
+   ReceivedBtDataEntity(
+     deviceAddress = device.getAddress(),
+     timestamp = System.currentTimeMillis(),
+     receivedMsg = receivedData,
+     owner_user_id = currentUserId // if supervised
+   )
+   ```
+3. **Add to batch queue**:
+   - `synchronized (lock) { temporaryReceivedBtDataListToSave.add(entity); }`
+   - **Why synchronized**: Batch-saving thread accesses the same list concurrently
+4. **Side effects**:
+   - Parse posture type (via `PostureFactory.createPosture(receivedData)`)
+   - Update `GlobalData.setReceivedPosture(posture)` â†’ triggers LiveData observers in UI
+   - If posture is "falling", show local notification
+
+**Open Question**: What happens if the batch queue grows faster than 500ms can drain it? (e.g., device sends 100 messages in 100ms)  
+**Assumption**: Queue keeps growing until next batch cycle; no explicit size limit observed in code.
+
+#### Stage 3: Batch-Saving Thread (Every 500ms)
+
+**File**: `DeviceCommunicationService.java`, background thread started in `onCreate()`
+
+**Thread**: Background (dedicated thread with `while` loop)
+
+**Timing**: `Constants.COUNTDOWN_TIMER_IN_MILLISECONDS_FOR_MESSAGE_SAVE = 500` ms
+
+**Actions** (per cycle):
+1. **Sleep**: `Thread.sleep(500)`
+2. **Copy and clear queue**:
+   ```
+   synchronized (lock) {
+     currentBatch = new ArrayList<>(temporaryReceivedBtDataListToSave);
+     temporaryReceivedBtDataListToSave.clear();
+   }
+   ```
+3. **If batch is not empty**:
+   - **Save to Room**: `database.receivedBtDataDao().insertAll(currentBatch)`
+     - **Threading**: Synchronous Room insert (blocks this thread, but it's already background)
+     - **Strategy**: `@Insert(onConflict = OnConflictStrategy.IGNORE)` â†’ duplicates are silently skipped
+   - **Sync each message to Firestore**:
+     - Loop over `currentBatch`
+     - For each entity: `firestoreSyncService.syncNewMessage(entity, callback)`
+       - **Threading**: Spawns new background task on `executorService`
+       - **Callback**: Logs success/error (non-blocking)
+4. **If batch is empty**: No-op, wait for next cycle
+
+**Outcome**: All messages are **guaranteed to be saved to Room** (local persistence). Firebase upload is **best-effort** (may fail if offline).
+
+#### Stage 4: Sync to Firebase (`FirestoreSyncService.java`, method: `syncNewMessage()`)
+
+**Thread**: Background (executorService)
+
+**Preconditions** (checked in order):
+1. User is authenticated? **No** â†’ callback `onError("User not authenticated")`
+2. UserSession is loaded? **No** â†’ callback `onError("User session not loaded")`
+3. User is supervised? **No** â†’ callback `onSuccess("User is not supervised, no sync needed")` (supervisors don't upload)
+4. Network is connected? **No** â†’ callback `onSuccess("Message saved locally, will sync when online")`
+
+**If all preconditions pass**:
+- **Actions**:
+  1. Convert `ReceivedBtDataEntity` to `FirestoreDataModel`
+  2. Generate document ID: `"<userId>_<timestamp>_<deviceAddress>"`
+  3. Call `firestore.collection("bluetooth_messages").document(documentId).set(firestoreModel)`
+     - **Threading**: Firestore async operation (callback on background thread)
+- **Outcomes**:
+  - **Success**: Callback `onSuccess("Message synced successfully")`
+  - **Failure**: Callback `onError("Failed to sync to Firestore: [error]")` â†’ message stays in Room for later retry
+
+#### Stage 5: Offline â†’ Online Transition (Retry Logic)
+
+**Trigger**: `NetworkConnectivityMonitor` detects connectivity restored
+
+**Actions**:
+- `FirestoreSyncService.handleConnectivityRestored()` (background thread)
+- **If user is supervised**:
+  - Call `syncLocalDataToFirestore()`
+    - Query Room for all local messages
+    - Check which docs already exist in Firestore (batch query)
+    - Upload only missing messages (batch write, max 500 per batch)
+- **If user is supervisor**:
+  - Call `startSupervisorMirrors()` (re-attach listeners if they were stopped)
+
+**Outcome**: Local Room database eventually syncs with Firestore when network is stable.
+
+---
+
+### 4. Supervisor Real-Time Mirror Pipeline
+
+**Context**: After supervisor completes login and backfill, real-time mirrors are active for each supervised user.
+
+#### Stage 1: Mirror Listener Attached
+
+**File**: `FirestoreSyncService.java`, method: `startSupervisorMirror()`
+
+**Thread**: Background (Firestore snapshot listener callback)
+
+**Actions**:
+1. Attach Firestore snapshot listener for each supervised UID:
+   - Query: `collection("bluetooth_messages").whereEqualTo("userId", supervisedUserId).orderBy("timestamp")`
+   - Listener fires on **every change** (new message added, existing message modified)
+2. Store listener registration in `mirrorByUid` map for cleanup later
+3. **Deduplication**: Check if mirror already active for this UID (skip if already listening)
+
+**Trigger**: New message uploaded by supervised user â†’ Firestore sends snapshot update â†’ listener callback fires
+
+#### Stage 2: Process Document Changes (`handleSupervisorDocumentChanges()`)
+
+**File**: `FirestoreSyncService.java`, method: `handleSupervisorDocumentChanges()`
+
+**Thread**: Background (executorService)
+
+**This is the critical function that processes real-time updates from supervised users.**
+
+**Actions** (for each document change):
+
+##### Step 1: Filter Document Changes
+- Loop through all `documentChanges` in the snapshot
+- Process only `ADDED` or `MODIFIED` types (ignore `REMOVED`)
+- **Why**: We want new messages and updates, but deletions are rare/unsupported
+
+##### Step 2: Convert Firestore Doc to Entity
+- Parse Firestore document into `FirestoreDataModel`
+- Extract: `deviceAddress`, `timestamp`, `receivedMsg`, `userId`
+
+##### Step 3: Deduplication Check
+- **Critical**: Query Room database to check if message already exists locally
+- Call: `dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg)`
+- **Returns**: `0` if not exists, `1` if exists
+- **Why**: Firestore listeners can fire multiple times for the same doc (e.g., on reconnect, cache vs server updates)
+
+##### Step 4: Create Room Entity with Owner Mapping
+- **Only if message doesn't exist** (dedup check passed):
+  ```
+  ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
+    deviceAddress,
+    timestamp,
+    receivedMsg,
+    supervisedUserId  // <- CRITICAL: owner_user_id set to supervised user's UID
+  )
+  ```
+- Add entity to `entitiesToInsert` list
+- **Why owner mapping matters**: Supervisor's Room database contains messages from **multiple** supervised users. Each row must be tagged with `owner_user_id` so queries can filter by supervised user.
+
+##### Step 5: Fall Detection and Notification (if applicable)
+
+**Condition**: Message is recent (within 24 hours) AND looks like a fall
+
+**Actions**:
+1. **Parse posture type**: `PostureFactory.createPosture(receivedMsg)`
+2. **Check if fall**: `if (posture instanceof FallingPosture)`
+3. **If fall detected**:
+   - **Fetch supervised user's email** (async Firestore query to `users` collection)
+     - **Thread**: Background (Firestore get callback)
+     - **Success**: Use email in notification text (e.g., "child@gmail.com has fallen")
+     - **Failure**: Fallback to UID in notification text
+   - **Show notification** on supervisor's device:
+     - `AlertNotifications.notifyFall(context, who, body)`
+     - **Threading**: Notification shown on UI thread via system notification manager
+     - **Why**: Alert supervisor immediately so they can check on supervised user
+
+**Fall Detection Logic**:
+- Recent threshold: `RECENT_MS = 60_000 * 1 * 60 * 24` (24 hours)
+  - **Why 24 hours?**: Supervisor may be offline when fall occurs; notification still shown when they come back online if within 24h
+- Only notify if `(now - timestamp) <= RECENT_MS` AND message is a fall posture
+- **Threading note**: Firestore email lookup and notification happen **asynchronously** (don't block the mirror pipeline)
+
+##### Step 6: Batch Insert into Room
+- After processing all document changes, insert all new entities:
+  - `dao.insertAll(entitiesToInsert)`
+  - **Strategy**: `@Insert(onConflict = OnConflictStrategy.IGNORE)` (duplicates silently skipped)
+- **Verification logging**: Query Room to confirm inserts: `dao.dbgCountForOwner(supervisedUserId)`
+
+**Outcome**: 
+- Supervisor's Room database now contains the new messages (tagged with `owner_user_id`)
+- If any falls detected, supervisor receives local notification
+- `BtConnectedActivity` (if open) observes Room LiveData â†’ UI updates automatically to show latest posture
+
+#### Stage 3: UI Update (if BtConnectedActivity is open)
+
+**File**: `BtConnectedActivity.java`, observes `SupervisorFeedViewModel.getLatestPosture()`
+
+**Thread**: UI thread (LiveData observer)
+
+**Actions**:
+1. `SupervisorFeedViewModel` queries Room for latest message (filtered by target supervised user)
+2. LiveData emits new `Posture` object
+3. `BtConnectedActivity.displayPostureData()` updates UI:
+   - Shows posture description (e.g., "Falling detected")
+   - Updates risk level text
+   - Plays/stops video animation
+
+**Why this matters**: Supervisor sees **real-time updates** without refreshing the screen. As supervised user's device uploads messages, supervisor's device automatically downloads and displays them.
+
+---
+
+### 5. Supervisor Mirror Lifecycle Management
+
+#### Mirror Start Conditions
+- **Trigger 1**: After backfill completes during login (via `purgeAndBackfillForSupervisor()`)
+- **Trigger 2**: When network connectivity is restored (via `handleConnectivityRestored()`)
+
+#### Mirror Stop Conditions
+- **Trigger 1**: User signs out (`SessionGate.handleUserSignedOut()` â†’ `stopAllMirrors()`)
+- **Trigger 2**: Network connectivity lost (listener automatically pauses, stopped explicitly by `stopAllMirrors()`)
+- **Trigger 3**: App is destroyed/closed
+
+#### Cleanup
+**File**: `FirestoreSyncService.java`, method: `stopAllMirrors()`
+
+**Actions**:
+1. Loop through all active listeners in `mirrorByUid` map
+2. Call `listener.remove()` for each (detaches Firestore listener)
+3. Clear `mirrorByUid` map and `startingUids` set
+4. Set `isSupervisorSyncActive = false`
+
+**Why proper cleanup matters**: Prevents memory leaks and ensures old listeners don't fire after role change or sign-out.
+
+---
+
+## ğŸ” Decision Points & Branches Summary
+
+### Key Decision Point 1: User Role Selection
+**Location**: `LoginActivity.onProceed()`
+
+| Condition | Path | Actions | Next State |
+|-----------|------|---------|------------|
+| Role = supervised | Supervised flow | Save role â†’ Load session â†’ Backfill own data â†’ Navigate to MainActivity | User can connect Bluetooth device |
+| Role = supervisor + valid email | Supervisor flow | Save role + email â†’ Load session â†’ Resolve email to UID â†’ Purge old data â†’ Backfill supervised users' data â†’ Start mirrors â†’ Navigate to MainActivity | User can monitor supervised users |
+| Role = supervisor + invalid email | Error | Show inline error | Stay on LoginActivity |
+
+### Key Decision Point 2: Launch Monitoring from MainActivity
+**Location**: `MainActivity.LaunchMonitoring()`
+
+| User Role | SessionGate Ready? | Destination | Reason |
+|-----------|-------------------|-------------|--------|
+| Supervised | Yes | BtSettingsActivity | Scan for Bluetooth device |
+| Supervised | No | BtSettingsActivity | Fallback (session error) |
+| Supervisor | Yes | BtConnectedActivity | View Room data (no BT needed) |
+| Supervisor | No | BtSettingsActivity | Fallback (session error) |
+
+### Key Decision Point 3: Sync Message to Firestore
+**Location**: `FirestoreSyncService.syncNewMessage()`
+
+| Condition | Action | Outcome |
+|-----------|--------|---------|
+| User authenticated + supervised + online | Upload to Firestore | Message in cloud + local |
+| User supervised + offline | Skip upload | Message in local Room only (retry later) |
+| User is supervisor | Skip upload | Supervisor doesn't upload their own messages |
+| User not authenticated | Skip upload | Message in local Room only |
+
+### Key Decision Point 4: Supervisor Mirror Document Processing
+**Location**: `FirestoreSyncService.handleSupervisorDocumentChanges()`
+
+| Stage | Condition | True Outcome | False Outcome | Side Effects | Threading |
+|-------|-----------|--------------|---------------|--------------|-----------|
+| Filter Changes | Change type is ADDED or MODIFIED? | Process document | Skip document | None | Background (executorService) |
+| Deduplication | Message already exists in Room? | Skip insert | Continue to create entity | None | Background (Room query) |
+| Fall Detection | Message is recent AND posture is FallingPosture? | Fetch supervised user email â†’ Show notification | No notification | Local notification shown to supervisor | Background (Firestore get) + UI thread (notification) |
+| Email Fetch (if fall) | Supervised user doc has email field? | Use email in notification text | Use UID in notification text | None | Background (Firestore get callback) |
+| Insert to Room | Batch insert succeeds? | New messages available to supervisor | Log error | Room database updated, LiveData observers notified | Background (Room insert) |
+
+---
+
+## âš™ï¸ Threading Summary
+
+| Component | Thread Type | Why |
+|-----------|-------------|-----|
+| `LoginActivity.signInWithGoogle()` | Background (CredentialManager callback) | Network call to Google Auth |
+| `LoginActivity.checkUserInFirestore()` | Background (Firestore async) | Network call to Firebase |
+| `LoginActivity.fetchAndPreFillUserPreferences()` | Background (Firestore async) | Network call to Firebase |
+| `SessionGate.handleUserAuthenticated()` | Background (executorService) | Loads session + starts backfill |
+| `UserSession.loadUserSession()` | Background (executorService) | Queries Firestore for user profile |
+| `FirestoreSyncService.backfillLocalFromCloudForCurrentUser()` | Background (executorService) | Downloads historical data |
+| `FirestoreSyncService.purgeAndBackfillForSupervisor()` | Background (executorService) | Purges Room + downloads supervised users' data |
+| `FirestoreSyncService.startSupervisorMirror()` | Background (Firestore snapshot listener) | Real-time sync |
+| `DeviceCommunicationThread` | Background (dedicated thread) | Bluetooth I/O (blocking socket operations) |
+| `DeviceCommunicationService` batch-saving thread | Background (dedicated thread with sleep loop) | Periodic Room inserts + Firestore uploads |
+| `FirestoreSyncService.syncNewMessage()` | Background (executorService) | Non-blocking Firestore upload |
+| `FirestoreSyncService.handleSupervisorDocumentChanges()` | Background (executorService) + async callbacks | Processes Firestore snapshot changes, checks duplicates, detects falls, inserts to Room |
+
+**Rule of thumb**: All Firestore, Room, and Bluetooth operations happen on **background threads**. Only UI updates (show/hide buttons, navigation) happen on **UI thread** (via `runOnUiThread()`).
+
+---
+
+## ğŸš¨ Open Questions & Assumptions
+
+### Open Questions
+
+1. **Batch queue overflow**: If Bluetooth device sends > 500 messages in 500ms, does the queue grow unbounded? Is there a max size or backpressure mechanism?
+   - **Code location**: `DeviceCommunicationService.temporaryReceivedBtDataListToSave` (no size check observed)
+
+2. **Supervisor mirror lifecycle**: If a supervisor signs out and signs back in with a different supervised email, are old mirrors properly cleaned up?
+   - **Observed**: `SessionGate.handleUserSignedOut()` calls `stopAllMirrors()` and `clearLocalData()` (seems safe)
+
+3. **Network retry strategy**: When offline messages are retried via `syncLocalDataToFirestore()`, is there exponential backoff or rate limiting?
+   - **Code location**: `FirestoreSyncService.syncLocalDataToFirestore()` (no backoff observed, appears to be one-shot batch upload)
+
+4. **Room database migration**: What happens if the Room schema changes between app versions?
+   - **Not covered in current files** (would need to check `InnovaDatabase.java` migrations)
+
+5. **Fall notification timing**: If supervisor is offline and multiple falls occur within 24 hours, will they receive multiple notifications when they come back online?
+   - **Code location**: `FirestoreSyncService.handleSupervisorDocumentChanges()` line 1127
+   - **Observed behavior**: Each fall message within 24h window triggers notification check (potential for notification spam)
+   - **Suggestion**: Consider tracking "already notified" falls to prevent duplicate alerts
+
+### Assumptions
+
+- **Assumption 1**: Firebase Auth tokens are cached offline, so `FirebaseAuth.getCurrentUser()` returns non-null even without network (after initial sign-in).
+  - **Evidence**: Code comment in `DeviceCommunicationService` line 188: "Firebase caches UID offline"
+
+- **Assumption 2**: The 500ms batch timer starts when `DeviceCommunicationService.onCreate()` is called (when service is bound/started).
+  - **Evidence**: Thread creation in `onCreate()` (line 57)
+
+- **Assumption 3**: Supervised users' messages are uploaded to Firestore with `userId = currentUserId`, allowing supervisors to query by `whereEqualTo("userId", supervisedUserId)`.
+  - **Evidence**: `FirestoreDataModel` constructor (line 204-209) and mirror query (line 1029)
+
+- **Assumption 4**: The supervised email autocomplete popup shows **all** users with `role = "supervised"`, not just users the current supervisor is authorized to monitor.
+  - **Evidence**: Query in `searchSupervisedUsers()` (line 676-678) has no additional filters
+
+---
+
diff --git a/InnovaMotionApp/docs/File Reference Summary.md b/InnovaMotionApp/docs/File Reference Summary.md
index d61f100..61bacab 100644
--- a/InnovaMotionApp/docs/File Reference Summary.md	
+++ b/InnovaMotionApp/docs/File Reference Summary.md	
@@ -1,34 +1,34 @@
-## ğŸ“¦ File Reference Summary (No Code)
-
-### Core Flow Files
-
-| File | Responsibility |
-|------|---------------|
-| `LoginActivity.java` | Entry point, Google Auth, role selection, pre-fill preferences |
-| `MainActivity.java` | Home screen, launches monitoring based on role |
-| `SessionGate.java` | Orchestrates post-login bootstrap (loads session, starts backfill/mirrors) |
-| `UserSession.java` | Caches user role + supervised UIDs from Firestore |
-| `FirestoreSyncService.java` | All cloud â†” local sync (upload for supervised, download+mirror for supervisor). Key methods: `syncNewMessage()` (supervised upload), `startSupervisorMirror()` (attach real-time listener), `handleSupervisorDocumentChanges()` (process mirror updates, fall detection, Room inserts) |
-| `DeviceCommunicationService.java` | Foreground service managing Bluetooth + batch-saving thread (batchSaving "DeviceCommunicationService.java") |
-| `DeviceCommunicationThread.java` | Bluetooth socket connection + data reception loop |
-| `BtSettingsActivity.java` | Bluetooth device scanning + pairing (supervised users only) |
-| `BtConnectedActivity.java` | Live posture display (supervised: from Bluetooth, supervisor: from Room) |
-
-### Data Layer Files
-
-| File | Responsibility |
-|------|---------------|
-| `InnovaDatabase` (Room) | Local SQLite database, table: `ReceivedBtDataEntity` |
-| `ReceivedBtDataEntity` | Room entity (device address, timestamp, message, owner UID) |
-| `FirestoreDataModel` | Firestore document structure for `bluetooth_messages` collection |
-
-### Utility Files
-
-| File | Responsibility |
-|------|---------------|
-| `Constants.java` | Defines `COUNTDOWN_TIMER_IN_MILLISECONDS_FOR_MESSAGE_SAVE = 500` |
-| `GlobalData.java` | Singleton holding LiveData for UI (current posture, connection status) |
-| `NetworkConnectivityMonitor` | Listens for network changes, triggers retry logic |
-| `RoleProvider.java` | Helper to check current user role (supervised vs supervisor) |
-| `AlertNotifications.java` | Shows fall detection notifications (both supervised and supervisor devices) |
-| `PostureFactory.java` | Parses raw Bluetooth messages into `Posture` objects (FallingPosture, etc.) |
+## ğŸ“¦ File Reference Summary (No Code)
+
+### Core Flow Files
+
+| File | Responsibility |
+|------|---------------|
+| `LoginActivity.java` | Entry point, Google Auth, role selection, pre-fill preferences |
+| `MainActivity.java` | Home screen, launches monitoring based on role |
+| `SessionGate.java` | Orchestrates post-login bootstrap (loads session, starts backfill/mirrors) |
+| `UserSession.java` | Caches user role + supervised UIDs from Firestore |
+| `FirestoreSyncService.java` | All cloud â†” local sync (upload for supervised, download+mirror for supervisor). Key methods: `syncNewMessage()` (supervised upload), `startSupervisorMirror()` (attach real-time listener), `handleSupervisorDocumentChanges()` (process mirror updates, fall detection, Room inserts) |
+| `DeviceCommunicationService.java` | Foreground service managing Bluetooth + batch-saving thread (batchSaving "DeviceCommunicationService.java") |
+| `DeviceCommunicationThread.java` | Bluetooth socket connection + data reception loop |
+| `BtSettingsActivity.java` | Bluetooth device scanning + pairing (supervised users only) |
+| `BtConnectedActivity.java` | Live posture display (supervised: from Bluetooth, supervisor: from Room) |
+
+### Data Layer Files
+
+| File | Responsibility |
+|------|---------------|
+| `InnovaDatabase` (Room) | Local SQLite database, table: `ReceivedBtDataEntity` |
+| `ReceivedBtDataEntity` | Room entity (device address, timestamp, message, owner UID) |
+| `FirestoreDataModel` | Firestore document structure for `bluetooth_messages` collection |
+
+### Utility Files
+
+| File | Responsibility |
+|------|---------------|
+| `Constants.java` | Defines `COUNTDOWN_TIMER_IN_MILLISECONDS_FOR_MESSAGE_SAVE = 500` |
+| `GlobalData.java` | Singleton holding LiveData for UI (current posture, connection status) |
+| `NetworkConnectivityMonitor` | Listens for network changes, triggers retry logic |
+| `RoleProvider.java` | Helper to check current user role (supervised vs supervisor) |
+| `AlertNotifications.java` | Shows fall detection notifications (both supervised and supervisor devices) |
+| `PostureFactory.java` | Parses raw Bluetooth messages into `Posture` objects (FallingPosture, etc.) |
diff --git a/InnovaMotionApp/docs/High-Level Flowcharts/High-Level Flowcharts.md b/InnovaMotionApp/docs/High-Level Flowcharts/High-Level Flowcharts.md
index 54d0785..8ed3e2b 100644
--- a/InnovaMotionApp/docs/High-Level Flowcharts/High-Level Flowcharts.md	
+++ b/InnovaMotionApp/docs/High-Level Flowcharts/High-Level Flowcharts.md	
@@ -1,95 +1,95 @@
-
-## ğŸ”€ High-Level Flowcharts
-
-### Flow 1: Login â†’ MainActivity (Supervised User)
-
-```mermaid
-flowchart TD
-    Start([User opens app]) --> Login[LoginActivity.java]
-    Login --> SignIn[User clicks Google Sign-In button]
-    SignIn --> Auth{Firebase Auth<br/>Successful?}
-    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
-    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
-    
-    CheckFirestore --> UserExists{User doc<br/>exists?}
-    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
-    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
-    CreateProfile --> ShowRoleUI
-    
-    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervised]
-    WaitRole --> ClickProceed[User clicks Continue]
-    ClickProceed --> ValidateSupervised{Role validation<br/>passes?}
-    ValidateSupervised -->|No| ShowValidationError[Show error message]
-    ValidateSupervised -->|Yes| SaveRole[Save role to Firestore<br/>Background thread]
-    
-    SaveRole --> SaveSuccess{Save<br/>successful?}
-    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
-    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
-    
-    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
-    LoadSession --> SessionLoaded{Session<br/>loaded?}
-    SessionLoaded -->|No| SessionError[Log error, session not ready]
-    SessionLoaded -->|Yes| BootstrapSupervised[Run supervised pipeline]
-    
-    BootstrapSupervised --> BackfillSupervised[Backfill own data from cloud<br/>Background thread]
-    BackfillSupervised --> NavMain[Navigate to MainActivity]
-    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
-    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
-    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
-    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
-    CheckSession -->|Yes| RouteBT[Route to BtSettingsActivity]
-    
-    RouteBT --> BtSettings[BtSettingsActivity:<br/>Scan for devices]
-    BtSettings --> Connect[User selects device]
-    Connect --> BtConnected[DeviceCommunicationService starts<br/>BtConnectedActivity opens]
-    BtConnected --> End([Bluetooth pipeline active])
-```
-
-### Flow 2: Login â†’ MainActivity (Supervisor User)
-
-```mermaid
-flowchart TD
-    Start([User opens app]) --> Login[LoginActivity.java]
-    Login --> SignIn[User clicks Google Sign-In button]
-    SignIn --> Auth{Firebase Auth<br/>Successful?}
-    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
-    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
-    
-    CheckFirestore --> UserExists{User doc<br/>exists?}
-    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
-    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
-    CreateProfile --> ShowRoleUI
-    
-    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervisor<br/>email field shown]
-    WaitRole --> TypeEmail[User types/selects<br/>supervised email]
-    TypeEmail --> Autocomplete[Firestore query for<br/>supervised users<br/>Background thread]
-    Autocomplete --> ClickProceed[User clicks Continue]
-    
-    ClickProceed --> ValidateSupervisor{Email validation<br/>passes?}
-    ValidateSupervisor -->|No| ShowValidationError[Show error: email required/invalid]
-    ValidateSupervisor -->|Yes| SaveRole[Save role + supervisedEmail<br/>to Firestore<br/>Background thread]
-    
-    SaveRole --> SaveSuccess{Save<br/>successful?}
-    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
-    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
-    
-    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
-    LoadSession --> ResolveEmail[Resolve supervised email<br/>to UID<br/>Background thread]
-    ResolveEmail --> SessionLoaded{Session<br/>loaded?}
-    SessionLoaded -->|No| SessionError[Log error, session not ready]
-    SessionLoaded -->|Yes| BootstrapSupervisor[Run supervisor pipeline]
-    
-    BootstrapSupervisor --> PurgeOld[Delete old data<br/>not belonging to<br/>current supervised users]
-    PurgeOld --> BackfillEach[For each supervised UID:<br/>Backfill data from cloud<br/>Background thread]
-    BackfillEach --> StartMirrors[Start real-time mirrors<br/>for each supervised UID]
-    StartMirrors --> NavMain[Navigate to MainActivity]
-    
-    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
-    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
-    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
-    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
-    CheckSession -->|Yes| RouteDirect[Skip BT scanning<br/>Route to BtConnectedActivity]
-    
-    RouteDirect --> BtConnected[BtConnectedActivity:<br/>Shows latest posture<br/>from Room database]
-    BtConnected --> End([Monitoring active<br/>Real-time updates via mirrors])
-```
+
+## ğŸ”€ High-Level Flowcharts
+
+### Flow 1: Login â†’ MainActivity (Supervised User)
+
+```mermaid
+flowchart TD
+    Start([User opens app]) --> Login[LoginActivity.java]
+    Login --> SignIn[User clicks Google Sign-In button]
+    SignIn --> Auth{Firebase Auth<br/>Successful?}
+    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
+    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
+    
+    CheckFirestore --> UserExists{User doc<br/>exists?}
+    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
+    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
+    CreateProfile --> ShowRoleUI
+    
+    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervised]
+    WaitRole --> ClickProceed[User clicks Continue]
+    ClickProceed --> ValidateSupervised{Role validation<br/>passes?}
+    ValidateSupervised -->|No| ShowValidationError[Show error message]
+    ValidateSupervised -->|Yes| SaveRole[Save role to Firestore<br/>Background thread]
+    
+    SaveRole --> SaveSuccess{Save<br/>successful?}
+    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
+    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
+    
+    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
+    LoadSession --> SessionLoaded{Session<br/>loaded?}
+    SessionLoaded -->|No| SessionError[Log error, session not ready]
+    SessionLoaded -->|Yes| BootstrapSupervised[Run supervised pipeline]
+    
+    BootstrapSupervised --> BackfillSupervised[Backfill own data from cloud<br/>Background thread]
+    BackfillSupervised --> NavMain[Navigate to MainActivity]
+    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
+    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
+    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
+    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
+    CheckSession -->|Yes| RouteBT[Route to BtSettingsActivity]
+    
+    RouteBT --> BtSettings[BtSettingsActivity:<br/>Scan for devices]
+    BtSettings --> Connect[User selects device]
+    Connect --> BtConnected[DeviceCommunicationService starts<br/>BtConnectedActivity opens]
+    BtConnected --> End([Bluetooth pipeline active])
+```
+
+### Flow 2: Login â†’ MainActivity (Supervisor User)
+
+```mermaid
+flowchart TD
+    Start([User opens app]) --> Login[LoginActivity.java]
+    Login --> SignIn[User clicks Google Sign-In button]
+    SignIn --> Auth{Firebase Auth<br/>Successful?}
+    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
+    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
+    
+    CheckFirestore --> UserExists{User doc<br/>exists?}
+    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
+    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
+    CreateProfile --> ShowRoleUI
+    
+    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervisor<br/>email field shown]
+    WaitRole --> TypeEmail[User types/selects<br/>supervised email]
+    TypeEmail --> Autocomplete[Firestore query for<br/>supervised users<br/>Background thread]
+    Autocomplete --> ClickProceed[User clicks Continue]
+    
+    ClickProceed --> ValidateSupervisor{Email validation<br/>passes?}
+    ValidateSupervisor -->|No| ShowValidationError[Show error: email required/invalid]
+    ValidateSupervisor -->|Yes| SaveRole[Save role + supervisedEmail<br/>to Firestore<br/>Background thread]
+    
+    SaveRole --> SaveSuccess{Save<br/>successful?}
+    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
+    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
+    
+    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
+    LoadSession --> ResolveEmail[Resolve supervised email<br/>to UID<br/>Background thread]
+    ResolveEmail --> SessionLoaded{Session<br/>loaded?}
+    SessionLoaded -->|No| SessionError[Log error, session not ready]
+    SessionLoaded -->|Yes| BootstrapSupervisor[Run supervisor pipeline]
+    
+    BootstrapSupervisor --> PurgeOld[Delete old data<br/>not belonging to<br/>current supervised users]
+    PurgeOld --> BackfillEach[For each supervised UID:<br/>Backfill data from cloud<br/>Background thread]
+    BackfillEach --> StartMirrors[Start real-time mirrors<br/>for each supervised UID]
+    StartMirrors --> NavMain[Navigate to MainActivity]
+    
+    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
+    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
+    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
+    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
+    CheckSession -->|Yes| RouteDirect[Skip BT scanning<br/>Route to BtConnectedActivity]
+    
+    RouteDirect --> BtConnected[BtConnectedActivity:<br/>Shows latest posture<br/>from Room database]
+    BtConnected --> End([Monitoring active<br/>Real-time updates via mirrors])
+```
diff --git a/InnovaMotionApp/docs/High-Level Flowcharts/flowcharts_viewer_harcoded.html b/InnovaMotionApp/docs/High-Level Flowcharts/flowcharts_viewer_harcoded.html
index ad3ad32..8988b6e 100644
--- a/InnovaMotionApp/docs/High-Level Flowcharts/flowcharts_viewer_harcoded.html	
+++ b/InnovaMotionApp/docs/High-Level Flowcharts/flowcharts_viewer_harcoded.html	
@@ -1,154 +1,154 @@
-<!DOCTYPE html>
-<html lang="en">
-<head>
-  <meta charset="UTF-8" />
-  <meta name="viewport" content="width=device-width, initial-scale=1" />
-  <title>Highâ€‘Level Flowcharts Viewer</title>
-  <style>
-    :root{
-      --bg: #ffffff; --fg:#111827; --muted:#6b7280; --card:#f9fafb; --border:#e5e7eb;
-      --code:#f7f7f7; --link:#2563eb;
-    }
-    @media (prefers-color-scheme: dark){
-      :root{ --bg:#0b1020; --fg:#ecf0ff; --muted:#9aa3b2; --card:#121933; --border:#26314f; --code:#0e1630; --link:#93c5fd; }
-    }
-    html, body{ height:100%; }
-    body{ margin:0; padding:0; background:var(--bg); color:var(--fg); font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
-    header{ position:sticky; top:0; z-index:10; backdrop-filter:saturate(180%) blur(6px); background:color-mix(in srgb, var(--bg) 85%, transparent); border-bottom:1px solid var(--border); }
-    .wrap{ max-width:1100px; margin:0 auto; padding:16px 20px; }
-    h1{ font-size:clamp(20px, 2.6vw, 28px); margin:8px 0; }
-    h2{ font-size:clamp(18px, 2.2vw, 24px); margin-top:28px; }
-    h3{ font-size:clamp(17px, 2vw, 22px); margin:18px 0 8px; }
-    .card{ background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; margin:16px 0; }
-    .muted{ color:var(--muted); }
-    a{ color:var(--link); text-decoration:none; }
-    a:hover{ text-decoration:underline; }
-    .mermaid{ background:var(--bg); border:1px dashed var(--border); border-radius:12px; padding:12px; overflow:auto; }
-    .section{ scroll-margin-top:76px; }
-    .toc{ display:flex; gap:12px; flex-wrap:wrap; }
-    .toc a{ background:var(--card); border:1px solid var(--border); padding:8px 10px; border-radius:999px; }
-    footer{ color:var(--muted); padding:24px 0 40px; }
-  </style>
-  <script type="module">
-    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
-    mermaid.initialize({ startOnLoad: true, theme: (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default') });
-  </script>
-</head>
-<body>
-  <header>
-    <div class="wrap">
-      <h1>ğŸ”€ Highâ€‘Level Flowcharts Viewer</h1>
-      <div class="muted">Tap a section to jump</div>
-      <nav class="toc">
-        <a href="#flow1">Flow 1: Login â†’ MainActivity (Supervised)</a>
-        <a href="#flow2">Flow 2: Login â†’ MainActivity (Supervisor)</a>
-      </nav>
-    </div>
-  </header>
-
-  <main class="wrap">
-    <section id="flow1" class="section">
-      <h2>Flow 1: Login â†’ MainActivity (Supervised User)</h2>
-      <div class="card">
-        <div class="mermaid">
-flowchart TD
-    Start([User opens app]) --> Login[LoginActivity.java]
-    Login --> SignIn[User clicks Google Sign-In button]
-    SignIn --> Auth{Firebase Auth<br/>Successful?}
-    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
-    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
-    
-    CheckFirestore --> UserExists{User doc<br/>exists?}
-    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
-    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
-    CreateProfile --> ShowRoleUI
-    
-    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervised]
-    WaitRole --> ClickProceed[User clicks Continue]
-    ClickProceed --> ValidateSupervised{Role validation<br/>passes?}
-    ValidateSupervised -->|No| ShowValidationError[Show error message]
-    ValidateSupervised -->|Yes| SaveRole[Save role to Firestore<br/>Background thread]
-    
-    SaveRole --> SaveSuccess{Save<br/>successful?}
-    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
-    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
-    
-    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
-    LoadSession --> SessionLoaded{Session<br/>loaded?}
-    SessionLoaded -->|No| SessionError[Log error, session not ready]
-    SessionLoaded -->|Yes| BootstrapSupervised[Run supervised pipeline]
-    
-    BootstrapSupervised --> BackfillSupervised[Backfill own data from cloud<br/>Background thread]
-    BackfillSupervised --> NavMain[Navigate to MainActivity]
-    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
-    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
-    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
-    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
-    CheckSession -->|Yes| RouteBT[Route to BtSettingsActivity]
-    
-    RouteBT --> BtSettings[BtSettingsActivity:<br/>Scan for devices]
-    BtSettings --> Connect[User selects device]
-    Connect --> BtConnected[DeviceCommunicationService starts<br/>BtConnectedActivity opens]
-    BtConnected --> End([Bluetooth pipeline active])
-        </div>
-      </div>
-    </section>
-
-    <section id="flow2" class="section">
-      <h2>Flow 2: Login â†’ MainActivity (Supervisor User)</h2>
-      <div class="card">
-        <div class="mermaid">
-flowchart TD
-    Start([User opens app]) --> Login[LoginActivity.java]
-    Login --> SignIn[User clicks Google Sign-In button]
-    SignIn --> Auth{Firebase Auth<br/>Successful?}
-    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
-    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
-    
-    CheckFirestore --> UserExists{User doc<br/>exists?}
-    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
-    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
-    CreateProfile --> ShowRoleUI
-    
-    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervisor<br/>email field shown]
-    WaitRole --> TypeEmail[User types/selects<br/>supervised email]
-    TypeEmail --> Autocomplete[Firestore query for<br/>supervised users<br/>Background thread]
-    Autocomplete --> ClickProceed[User clicks Continue]
-    
-    ClickProceed --> ValidateSupervisor{Email validation<br/>passes?}
-    ValidateSupervisor -->|No| ShowValidationError[Show error: email required/invalid]
-    ValidateSupervisor -->|Yes| SaveRole[Save role + supervisedEmail<br/>to Firestore<br/>Background thread]
-    
-    SaveRole --> SaveSuccess{Save<br/>successful?}
-    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
-    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
-    
-    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
-    LoadSession --> ResolveEmail[Resolve supervised email<br/>to UID<br/>Background thread]
-    ResolveEmail --> SessionLoaded{Session<br/>loaded?}
-    SessionLoaded -->|No| SessionError[Log error, session not ready]
-    SessionLoaded -->|Yes| BootstrapSupervisor[Run supervisor pipeline]
-    
-    BootstrapSupervisor --> PurgeOld[Delete old data<br/>not belonging to<br/>current supervised users]
-    PurgeOld --> BackfillEach[For each supervised UID:<br/>Backfill data from cloud<br/>Background thread]
-    BackfillEach --> StartMirrors[Start real-time mirrors<br/>for each supervised UID]
-    StartMirrors --> NavMain[Navigate to MainActivity]
-    
-    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
-    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
-    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
-    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
-    CheckSession -->|Yes| RouteDirect[Skip BT scanning<br/>Route to BtConnectedActivity]
-    
-    RouteDirect --> BtConnected[BtConnectedActivity:<br/>Shows latest posture<br/>from Room database]
-    BtConnected --> End([Monitoring active<br/>Real-time updates via mirrors])
-        </div>
-      </div>
-    </section>
-
-    <footer>
-      <p class="muted">This viewer renders Mermaid diagrams client-side. Works online; for offline use, bundle the Mermaid script locally.</p>
-    </footer>
-  </main>
-</body>
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8" />
+  <meta name="viewport" content="width=device-width, initial-scale=1" />
+  <title>Highâ€‘Level Flowcharts Viewer</title>
+  <style>
+    :root{
+      --bg: #ffffff; --fg:#111827; --muted:#6b7280; --card:#f9fafb; --border:#e5e7eb;
+      --code:#f7f7f7; --link:#2563eb;
+    }
+    @media (prefers-color-scheme: dark){
+      :root{ --bg:#0b1020; --fg:#ecf0ff; --muted:#9aa3b2; --card:#121933; --border:#26314f; --code:#0e1630; --link:#93c5fd; }
+    }
+    html, body{ height:100%; }
+    body{ margin:0; padding:0; background:var(--bg); color:var(--fg); font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
+    header{ position:sticky; top:0; z-index:10; backdrop-filter:saturate(180%) blur(6px); background:color-mix(in srgb, var(--bg) 85%, transparent); border-bottom:1px solid var(--border); }
+    .wrap{ max-width:1100px; margin:0 auto; padding:16px 20px; }
+    h1{ font-size:clamp(20px, 2.6vw, 28px); margin:8px 0; }
+    h2{ font-size:clamp(18px, 2.2vw, 24px); margin-top:28px; }
+    h3{ font-size:clamp(17px, 2vw, 22px); margin:18px 0 8px; }
+    .card{ background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; margin:16px 0; }
+    .muted{ color:var(--muted); }
+    a{ color:var(--link); text-decoration:none; }
+    a:hover{ text-decoration:underline; }
+    .mermaid{ background:var(--bg); border:1px dashed var(--border); border-radius:12px; padding:12px; overflow:auto; }
+    .section{ scroll-margin-top:76px; }
+    .toc{ display:flex; gap:12px; flex-wrap:wrap; }
+    .toc a{ background:var(--card); border:1px solid var(--border); padding:8px 10px; border-radius:999px; }
+    footer{ color:var(--muted); padding:24px 0 40px; }
+  </style>
+  <script type="module">
+    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
+    mermaid.initialize({ startOnLoad: true, theme: (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'default') });
+  </script>
+</head>
+<body>
+  <header>
+    <div class="wrap">
+      <h1>ğŸ”€ Highâ€‘Level Flowcharts Viewer</h1>
+      <div class="muted">Tap a section to jump</div>
+      <nav class="toc">
+        <a href="#flow1">Flow 1: Login â†’ MainActivity (Supervised)</a>
+        <a href="#flow2">Flow 2: Login â†’ MainActivity (Supervisor)</a>
+      </nav>
+    </div>
+  </header>
+
+  <main class="wrap">
+    <section id="flow1" class="section">
+      <h2>Flow 1: Login â†’ MainActivity (Supervised User)</h2>
+      <div class="card">
+        <div class="mermaid">
+flowchart TD
+    Start([User opens app]) --> Login[LoginActivity.java]
+    Login --> SignIn[User clicks Google Sign-In button]
+    SignIn --> Auth{Firebase Auth<br/>Successful?}
+    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
+    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
+    
+    CheckFirestore --> UserExists{User doc<br/>exists?}
+    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
+    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
+    CreateProfile --> ShowRoleUI
+    
+    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervised]
+    WaitRole --> ClickProceed[User clicks Continue]
+    ClickProceed --> ValidateSupervised{Role validation<br/>passes?}
+    ValidateSupervised -->|No| ShowValidationError[Show error message]
+    ValidateSupervised -->|Yes| SaveRole[Save role to Firestore<br/>Background thread]
+    
+    SaveRole --> SaveSuccess{Save<br/>successful?}
+    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
+    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
+    
+    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
+    LoadSession --> SessionLoaded{Session<br/>loaded?}
+    SessionLoaded -->|No| SessionError[Log error, session not ready]
+    SessionLoaded -->|Yes| BootstrapSupervised[Run supervised pipeline]
+    
+    BootstrapSupervised --> BackfillSupervised[Backfill own data from cloud<br/>Background thread]
+    BackfillSupervised --> NavMain[Navigate to MainActivity]
+    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
+    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
+    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
+    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
+    CheckSession -->|Yes| RouteBT[Route to BtSettingsActivity]
+    
+    RouteBT --> BtSettings[BtSettingsActivity:<br/>Scan for devices]
+    BtSettings --> Connect[User selects device]
+    Connect --> BtConnected[DeviceCommunicationService starts<br/>BtConnectedActivity opens]
+    BtConnected --> End([Bluetooth pipeline active])
+        </div>
+      </div>
+    </section>
+
+    <section id="flow2" class="section">
+      <h2>Flow 2: Login â†’ MainActivity (Supervisor User)</h2>
+      <div class="card">
+        <div class="mermaid">
+flowchart TD
+    Start([User opens app]) --> Login[LoginActivity.java]
+    Login --> SignIn[User clicks Google Sign-In button]
+    SignIn --> Auth{Firebase Auth<br/>Successful?}
+    Auth -->|No| ShowError[Show error toast<br/>Stay on LoginActivity]
+    Auth -->|Yes| CheckFirestore[Check user doc in Firestore<br/>Background thread]
+    
+    CheckFirestore --> UserExists{User doc<br/>exists?}
+    UserExists -->|No| CreateProfile[Create user profile<br/>in Firestore]
+    UserExists -->|Yes| ShowRoleUI[Show role selection UI]
+    CreateProfile --> ShowRoleUI
+    
+    ShowRoleUI --> WaitRole[User sees pre-filled<br/>role = supervisor<br/>email field shown]
+    WaitRole --> TypeEmail[User types/selects<br/>supervised email]
+    TypeEmail --> Autocomplete[Firestore query for<br/>supervised users<br/>Background thread]
+    Autocomplete --> ClickProceed[User clicks Continue]
+    
+    ClickProceed --> ValidateSupervisor{Email validation<br/>passes?}
+    ValidateSupervisor -->|No| ShowValidationError[Show error: email required/invalid]
+    ValidateSupervisor -->|Yes| SaveRole[Save role + supervisedEmail<br/>to Firestore<br/>Background thread]
+    
+    SaveRole --> SaveSuccess{Save<br/>successful?}
+    SaveSuccess -->|No| ShowSaveError[Show error, re-enable buttons]
+    SaveSuccess -->|Yes| InitSessionGate[SessionGate.getInstance]
+    
+    InitSessionGate --> LoadSession[UserSession loads from Firestore<br/>Background thread]
+    LoadSession --> ResolveEmail[Resolve supervised email<br/>to UID<br/>Background thread]
+    ResolveEmail --> SessionLoaded{Session<br/>loaded?}
+    SessionLoaded -->|No| SessionError[Log error, session not ready]
+    SessionLoaded -->|Yes| BootstrapSupervisor[Run supervisor pipeline]
+    
+    BootstrapSupervisor --> PurgeOld[Delete old data<br/>not belonging to<br/>current supervised users]
+    PurgeOld --> BackfillEach[For each supervised UID:<br/>Backfill data from cloud<br/>Background thread]
+    BackfillEach --> StartMirrors[Start real-time mirrors<br/>for each supervised UID]
+    StartMirrors --> NavMain[Navigate to MainActivity]
+    
+    NavMain --> MainReady[MainActivity ready<br/>User can launch monitoring]
+    MainReady --> LaunchMonitoring[User clicks Launch Monitoring]
+    LaunchMonitoring --> CheckSession{SessionGate<br/>ready?}
+    CheckSession -->|No| FallbackBT[Route to BtSettingsActivity]
+    CheckSession -->|Yes| RouteDirect[Skip BT scanning<br/>Route to BtConnectedActivity]
+    
+    RouteDirect --> BtConnected[BtConnectedActivity:<br/>Shows latest posture<br/>from Room database]
+    BtConnected --> End([Monitoring active<br/>Real-time updates via mirrors])
+        </div>
+      </div>
+    </section>
+
+    <footer>
+      <p class="muted">This viewer renders Mermaid diagrams client-side. Works online; for offline use, bundle the Mermaid script locally.</p>
+    </footer>
+  </main>
+</body>
 </html>
\ No newline at end of file
diff --git a/InnovaMotionApp/docs/README.md b/InnovaMotionApp/docs/README.md
index 963fe14..b001e46 100644
--- a/InnovaMotionApp/docs/README.md
+++ b/InnovaMotionApp/docs/README.md
@@ -1,159 +1,159 @@
-# InnovaMotion App Documentation
-
-**Audience**: Junior/"little tech" teammates  
-**Style**: High-level, plain language explanations (no code snippets)  
-**Last Updated**: October 2025
-
----
-
-## ğŸ“‘ Documentation Index
-
-### Quick Start
-
-1. **[Summary.md](Summary.md)** â€“ Executive summary, glossary of key terms
-2. **[The Big Picture.md](The%20Big%20Picture.md)** â€“ 5-point overview of all major flows
-
-### Detailed Guides
-
-3. **[Detailed Flow Narratives.md](Detailed%20Flow%20Narratives.md)** â€“ Complete step-by-step flows:
-   - Entry flow: LoginActivity â†’ MainActivity (both roles)
-   - Bluetooth message pipeline (supervised users)
-   - Supervisor real-time mirror pipeline (**NEW**)
-   - Decision tables and threading details
-   - Open questions and assumptions
-
-4. **[Supervisor Mirror Pipeline.md](Supervisor%20Mirror%20Pipeline.md)** â€“ Deep dive into supervisor monitoring:
-   - Mirror setup and lifecycle
-   - Real-time update processing via `handleSupervisorDocumentChanges()`
-   - Fall detection and notification system
-   - Owner mapping and deduplication strategy
-   - Common issues and debugging tips
-
-### Visual References
-
-5. **[High-Level Flowcharts/](High-Level%20Flowcharts/)** â€“ Mermaid flowcharts:
-   - Login â†’ Main (supervised user)
-   - Login â†’ Main (supervisor user)
-
-6. **[Sequence Diagrams/](Sequence%20Diagrams/)** â€“ Mermaid sequence diagrams:
-   - `onProceed()` for supervised users
-   - `onProceed()` for supervisor users
-   - 500ms batch send cycle (supervised)
-
-7. **[File Reference Summary.md](File%20Reference%20Summary.md)** â€“ Quick lookup of all key files and their responsibilities
-
----
-
-## ğŸ¯ What's New (Latest Updates)
-
-### Added Documentation for `handleSupervisorDocumentChanges()`
-
-The critical function that was missing from the original documentation! This function is the heart of the supervisor mirror pipeline and handles:
-
-- **Real-time message processing** from supervised users
-- **Deduplication checks** (Firestore listeners can fire multiple times for the same doc)
-- **Owner mapping** (tagging messages with `owner_user_id` for multi-user support)
-- **Fall detection** (parsing posture, checking 24h window, fetching supervised user email)
-- **Supervisor notifications** (alerting supervisor when supervised user falls)
-- **Room database inserts** (with verification logging)
-
-**Files Updated**:
-- `Detailed Flow Narratives.md`: Added Section 4 (Supervisor Real-Time Mirror Pipeline) and Section 5 (Mirror Lifecycle Management)
-- `Summary.md`: Added supervisor pipeline summary
-- `The Big Picture.md`: Added point 3 (Supervisor Mirror Pipeline)
-- `File Reference Summary.md`: Expanded `FirestoreSyncService.java` description
-- **New**: `Supervisor Mirror Pipeline.md` (standalone deep-dive guide)
-
----
-
-## ğŸ” How to Use This Documentation
-
-### If you're new to the project:
-1. Start with **Summary.md** to understand terminology
-2. Read **The Big Picture.md** for a 5-minute overview
-3. Dive into **Detailed Flow Narratives.md** for complete step-by-step flows
-
-### If you're debugging supervisor issues:
-1. Go directly to **Supervisor Mirror Pipeline.md**
-2. Check the "Common Issues & Debugging" section at the end
-3. Review the decision table in **Detailed Flow Narratives.md** (Key Decision Point 4)
-
-### If you need to understand threading:
-1. Check the **Threading Summary** table in **Detailed Flow Narratives.md**
-2. Look for **Thread** annotations throughout all narratives
-
-### If you're looking for a specific file:
-1. Use **File Reference Summary.md** for quick lookups
-
----
-
-## ğŸ“ Documentation Principles
-
-1. **No code snippets** â€“ Only file names, class names, and method names
-2. **Explicit threading** â€“ Every action notes whether it's UI thread or background
-3. **Plain language** â€“ Explain *what happens and why*, not *how code is written*
-4. **Decision branches** â€“ All conditions, outcomes, side effects clearly labeled
-5. **Assumptions vs facts** â€“ Inferred behavior is clearly marked as "Assumption"
-
----
-
-## ğŸ—‚ï¸ File Structure
-
-```
-docs/
-â”œâ”€â”€ README.md (this file)
-â”œâ”€â”€ Summary.md
-â”œâ”€â”€ The Big Picture.md
-â”œâ”€â”€ Detailed Flow Narratives.md
-â”œâ”€â”€ Supervisor Mirror Pipeline.md (NEW)
-â”œâ”€â”€ File Reference Summary.md
-â”œâ”€â”€ High-Level Flowcharts/
-â”‚   â””â”€â”€ High-Level Flowcharts.md
-â””â”€â”€ Sequence Diagrams/
-    â”œâ”€â”€ Sequence Diagrams.md
-    â”œâ”€â”€ diagram1_on_proceed_supervised_user.png
-    â”œâ”€â”€ diagram2_on_proceed_supervisor_user.png
-    â””â”€â”€ diagram3_supervised_bluetooth_message_pipeline500ms_batch_cycle.png
-```
-
----
-
-## ğŸ’¡ Key Concepts to Understand
-
-### Owner Mapping (Critical for Supervisors)
-- Supervisor's Room database contains messages from **multiple** supervised users
-- Each `ReceivedBtDataEntity` has `owner_user_id` field
-- Supervised users: `owner_user_id = their own UID`
-- Supervisor mirrors: `owner_user_id = supervised user's UID`
-- All queries filter by `owner_user_id` to show correct data
-
-### Deduplication Strategy
-- Firestore listeners can fire multiple times for same document
-- Before inserting, check: `dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg)`
-- Returns `0` if not exists, `1` if exists
-- Prevents duplicate data in Room database
-
-### Fall Detection (24-Hour Window)
-- Supervisor receives notifications for falls within 24 hours
-- Why? Supervisor may be offline when fall occurs
-- On reconnect, mirror fires with all missed messages
-- Still notify if fall happened recently
-- Tradeoff: Risk of notification spam if multiple falls in 24h
-
-### Threading Discipline
-- **Background threads**: All Firestore, Room, Bluetooth operations
-- **UI thread**: Only UI updates (buttons, navigation, LiveData observers)
-- No blocking operations on UI thread (good practice throughout)
-
----
-
-## ğŸ“ Questions or Feedback?
-
-If something is unclear or missing, please update this documentation! Follow the same style:
-- Plain language (no code)
-- Explicit threading
-- Decision branches clearly labeled
-- Assumptions marked as such
-
-Happy reading! ğŸ“–
-
+# InnovaMotion App Documentation
+
+**Audience**: Junior/"little tech" teammates  
+**Style**: High-level, plain language explanations (no code snippets)  
+**Last Updated**: October 2025
+
+---
+
+## ğŸ“‘ Documentation Index
+
+### Quick Start
+
+1. **[Summary.md](Summary.md)** â€“ Executive summary, glossary of key terms
+2. **[The Big Picture.md](The%20Big%20Picture.md)** â€“ 5-point overview of all major flows
+
+### Detailed Guides
+
+3. **[Detailed Flow Narratives.md](Detailed%20Flow%20Narratives.md)** â€“ Complete step-by-step flows:
+   - Entry flow: LoginActivity â†’ MainActivity (both roles)
+   - Bluetooth message pipeline (supervised users)
+   - Supervisor real-time mirror pipeline (**NEW**)
+   - Decision tables and threading details
+   - Open questions and assumptions
+
+4. **[Supervisor Mirror Pipeline.md](Supervisor%20Mirror%20Pipeline.md)** â€“ Deep dive into supervisor monitoring:
+   - Mirror setup and lifecycle
+   - Real-time update processing via `handleSupervisorDocumentChanges()`
+   - Fall detection and notification system
+   - Owner mapping and deduplication strategy
+   - Common issues and debugging tips
+
+### Visual References
+
+5. **[High-Level Flowcharts/](High-Level%20Flowcharts/)** â€“ Mermaid flowcharts:
+   - Login â†’ Main (supervised user)
+   - Login â†’ Main (supervisor user)
+
+6. **[Sequence Diagrams/](Sequence%20Diagrams/)** â€“ Mermaid sequence diagrams:
+   - `onProceed()` for supervised users
+   - `onProceed()` for supervisor users
+   - 500ms batch send cycle (supervised)
+
+7. **[File Reference Summary.md](File%20Reference%20Summary.md)** â€“ Quick lookup of all key files and their responsibilities
+
+---
+
+## ğŸ¯ What's New (Latest Updates)
+
+### Added Documentation for `handleSupervisorDocumentChanges()`
+
+The critical function that was missing from the original documentation! This function is the heart of the supervisor mirror pipeline and handles:
+
+- **Real-time message processing** from supervised users
+- **Deduplication checks** (Firestore listeners can fire multiple times for the same doc)
+- **Owner mapping** (tagging messages with `owner_user_id` for multi-user support)
+- **Fall detection** (parsing posture, checking 24h window, fetching supervised user email)
+- **Supervisor notifications** (alerting supervisor when supervised user falls)
+- **Room database inserts** (with verification logging)
+
+**Files Updated**:
+- `Detailed Flow Narratives.md`: Added Section 4 (Supervisor Real-Time Mirror Pipeline) and Section 5 (Mirror Lifecycle Management)
+- `Summary.md`: Added supervisor pipeline summary
+- `The Big Picture.md`: Added point 3 (Supervisor Mirror Pipeline)
+- `File Reference Summary.md`: Expanded `FirestoreSyncService.java` description
+- **New**: `Supervisor Mirror Pipeline.md` (standalone deep-dive guide)
+
+---
+
+## ğŸ” How to Use This Documentation
+
+### If you're new to the project:
+1. Start with **Summary.md** to understand terminology
+2. Read **The Big Picture.md** for a 5-minute overview
+3. Dive into **Detailed Flow Narratives.md** for complete step-by-step flows
+
+### If you're debugging supervisor issues:
+1. Go directly to **Supervisor Mirror Pipeline.md**
+2. Check the "Common Issues & Debugging" section at the end
+3. Review the decision table in **Detailed Flow Narratives.md** (Key Decision Point 4)
+
+### If you need to understand threading:
+1. Check the **Threading Summary** table in **Detailed Flow Narratives.md**
+2. Look for **Thread** annotations throughout all narratives
+
+### If you're looking for a specific file:
+1. Use **File Reference Summary.md** for quick lookups
+
+---
+
+## ğŸ“ Documentation Principles
+
+1. **No code snippets** â€“ Only file names, class names, and method names
+2. **Explicit threading** â€“ Every action notes whether it's UI thread or background
+3. **Plain language** â€“ Explain *what happens and why*, not *how code is written*
+4. **Decision branches** â€“ All conditions, outcomes, side effects clearly labeled
+5. **Assumptions vs facts** â€“ Inferred behavior is clearly marked as "Assumption"
+
+---
+
+## ğŸ—‚ï¸ File Structure
+
+```
+docs/
+â”œâ”€â”€ README.md (this file)
+â”œâ”€â”€ Summary.md
+â”œâ”€â”€ The Big Picture.md
+â”œâ”€â”€ Detailed Flow Narratives.md
+â”œâ”€â”€ Supervisor Mirror Pipeline.md (NEW)
+â”œâ”€â”€ File Reference Summary.md
+â”œâ”€â”€ High-Level Flowcharts/
+â”‚   â””â”€â”€ High-Level Flowcharts.md
+â””â”€â”€ Sequence Diagrams/
+    â”œâ”€â”€ Sequence Diagrams.md
+    â”œâ”€â”€ diagram1_on_proceed_supervised_user.png
+    â”œâ”€â”€ diagram2_on_proceed_supervisor_user.png
+    â””â”€â”€ diagram3_supervised_bluetooth_message_pipeline500ms_batch_cycle.png
+```
+
+---
+
+## ğŸ’¡ Key Concepts to Understand
+
+### Owner Mapping (Critical for Supervisors)
+- Supervisor's Room database contains messages from **multiple** supervised users
+- Each `ReceivedBtDataEntity` has `owner_user_id` field
+- Supervised users: `owner_user_id = their own UID`
+- Supervisor mirrors: `owner_user_id = supervised user's UID`
+- All queries filter by `owner_user_id` to show correct data
+
+### Deduplication Strategy
+- Firestore listeners can fire multiple times for same document
+- Before inserting, check: `dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg)`
+- Returns `0` if not exists, `1` if exists
+- Prevents duplicate data in Room database
+
+### Fall Detection (24-Hour Window)
+- Supervisor receives notifications for falls within 24 hours
+- Why? Supervisor may be offline when fall occurs
+- On reconnect, mirror fires with all missed messages
+- Still notify if fall happened recently
+- Tradeoff: Risk of notification spam if multiple falls in 24h
+
+### Threading Discipline
+- **Background threads**: All Firestore, Room, Bluetooth operations
+- **UI thread**: Only UI updates (buttons, navigation, LiveData observers)
+- No blocking operations on UI thread (good practice throughout)
+
+---
+
+## ğŸ“ Questions or Feedback?
+
+If something is unclear or missing, please update this documentation! Follow the same style:
+- Plain language (no code)
+- Explicit threading
+- Decision branches clearly labeled
+- Assumptions marked as such
+
+Happy reading! ğŸ“–
+
diff --git a/InnovaMotionApp/docs/Sequence Diagrams/Sequence Diagrams.md b/InnovaMotionApp/docs/Sequence Diagrams/Sequence Diagrams.md
index d312e15..902198f 100644
--- a/InnovaMotionApp/docs/Sequence Diagrams/Sequence Diagrams.md	
+++ b/InnovaMotionApp/docs/Sequence Diagrams/Sequence Diagrams.md	
@@ -1,154 +1,154 @@
-
-## ğŸ” Sequence Diagrams
-
-### Diagram 1: onProceed() â€“ Supervised User
-
-```mermaid
-sequenceDiagram
-    actor User
-    participant UI as LoginActivity<br/>(UI Thread)
-    participant FS as Firestore<br/>(Background)
-    participant SG as SessionGate<br/>(Singleton)
-    participant US as UserSession<br/>(Background)
-    participant Sync as FirestoreSyncService<br/>(Background)
-    participant Main as MainActivity
-    
-    User->>UI: Click Continue (supervised role)
-    UI->>UI: Validate role selection (passes)
-    UI->>UI: Show loading, disable buttons
-    UI->>FS: Save role = "supervised"
-    activate FS
-    FS-->>UI: Save successful
-    deactivate FS
-    
-    UI->>SG: SessionGate.getInstance(context)
-    SG->>US: loadUserSession()
-    activate US
-    US->>FS: Get user doc
-    activate FS
-    FS-->>US: role = "supervised"
-    deactivate FS
-    US->>US: Cache role + supervisedUserIds = []
-    US-->>SG: onSessionLoaded
-    deactivate US
-    
-    SG->>SG: runPostAuthBootstrap("supervised")
-    SG->>Sync: backfillLocalFromCloudForCurrentUser()
-    activate Sync
-    Sync->>FS: Query messages where userId = currentUserId
-    activate FS
-    FS-->>Sync: QuerySnapshot (0-N messages)
-    deactivate FS
-    Sync->>Sync: Convert to entities
-    Sync->>Sync: Insert into Room (DAO)
-    Sync-->>SG: onSuccess
-    deactivate Sync
-    
-    UI->>Main: Intent(MainActivity), FLAG_CLEAR_TASK
-    UI->>UI: finish()
-    Main->>Main: onCreate, show home screen
-```
-
-### Diagram 2: onProceed() â€“ Supervisor User
-
-```mermaid
-sequenceDiagram
-    actor User
-    participant UI as LoginActivity<br/>(UI Thread)
-    participant FS as Firestore<br/>(Background)
-    participant SG as SessionGate<br/>(Singleton)
-    participant US as UserSession<br/>(Background)
-    participant Sync as FirestoreSyncService<br/>(Background)
-    participant Main as MainActivity
-    
-    User->>UI: Click Continue (supervisor role + email)
-    UI->>UI: Validate email (Gmail format)
-    UI->>UI: Show loading, disable buttons
-    UI->>FS: Save role = "supervisor"<br/>+ supervisedEmail
-    activate FS
-    FS-->>UI: Save successful
-    deactivate FS
-    
-    UI->>SG: SessionGate.getInstance(context)
-    SG->>US: loadUserSession()
-    activate US
-    US->>FS: Get user doc
-    activate FS
-    FS-->>US: role = "supervisor"<br/>supervisedEmail = "child@gmail.com"
-    deactivate FS
-    US->>US: resolveEmailToUserId()
-    US->>FS: Query users where email = "child@gmail.com"
-    activate FS
-    FS-->>US: Doc with UID = "childUid123"
-    deactivate FS
-    US->>US: Cache supervisedUserIds = ["childUid123"]
-    US-->>SG: onSessionLoaded
-    deactivate US
-    
-    SG->>SG: runPostAuthBootstrap("supervisor")
-    SG->>Sync: purgeAndBackfillForSupervisor(["childUid123"])
-    activate Sync
-    Sync->>Sync: Delete from Room where owner_user_id NOT IN ["childUid123"]
-    Sync->>Sync: For each childUid: backfillLocalFromCloudForSupervisedUser()
-    Sync->>FS: Query messages where userId = "childUid123"
-    activate FS
-    FS-->>Sync: QuerySnapshot (0-N messages)
-    deactivate FS
-    Sync->>Sync: Insert into Room with owner_user_id = "childUid123"
-    Sync->>Sync: startSupervisorMirrors(["childUid123"])
-    Sync->>FS: Attach snapshot listener<br/>query: userId=="childUid123" orderBy timestamp
-    activate FS
-    Note over Sync,FS: Real-time listener active<br/>New messages auto-download
-    deactivate FS
-    Sync-->>SG: onSuccess
-    deactivate Sync
-    
-    UI->>Main: Intent(MainActivity), FLAG_CLEAR_TASK
-    UI->>UI: finish()
-    Main->>Main: onCreate, show home screen
-```
-
-### Diagram 3: Bluetooth Message Pipeline (500ms Batch Cycle)
-
-```mermaid
-sequenceDiagram
-    participant BT as DeviceCommunicationThread<br/>(Background)
-    participant Q as Batch Queue<br/>(In-Memory)
-    participant Saver as Batch-Saving Thread<br/>(Background)
-    participant Room as Room Database<br/>(Local SQLite)
-    participant Sync as FirestoreSyncService<br/>(Background)
-    participant FS as Firestore<br/>(Cloud)
-    
-    Note over BT,Q: Message arrives from Bluetooth device
-    BT->>BT: onDataReceived("0xAB3311")
-    BT->>Q: synchronized add(entity)
-    Note over BT,Q: Message queued in memory
-    
-    Note over Saver: Every 500ms (timer loop)
-    Saver->>Saver: sleep(500ms)
-    Saver->>Q: synchronized copy & clear queue
-    alt Batch not empty
-        Saver->>Room: insertAll(batch)
-        Room-->>Saver: Insert complete
-        
-        loop For each entity in batch
-            Saver->>Sync: syncNewMessage(entity)
-            activate Sync
-            
-            alt User is supervised AND online
-                Sync->>FS: firestore.set(documentId, firestoreModel)
-                activate FS
-                FS-->>Sync: Success or Error
-                deactivate FS
-                Sync-->>Saver: onSuccess/onError (logged)
-            else User not supervised OR offline
-                Sync-->>Saver: Skip sync (data stays in Room)
-            end
-            deactivate Sync
-        end
-    else Batch empty
-        Note over Saver: No-op, wait for next cycle
-    end
-    
-    Note over Saver: Loop continues until service destroyed
-```
+
+## ğŸ” Sequence Diagrams
+
+### Diagram 1: onProceed() â€“ Supervised User
+
+```mermaid
+sequenceDiagram
+    actor User
+    participant UI as LoginActivity<br/>(UI Thread)
+    participant FS as Firestore<br/>(Background)
+    participant SG as SessionGate<br/>(Singleton)
+    participant US as UserSession<br/>(Background)
+    participant Sync as FirestoreSyncService<br/>(Background)
+    participant Main as MainActivity
+    
+    User->>UI: Click Continue (supervised role)
+    UI->>UI: Validate role selection (passes)
+    UI->>UI: Show loading, disable buttons
+    UI->>FS: Save role = "supervised"
+    activate FS
+    FS-->>UI: Save successful
+    deactivate FS
+    
+    UI->>SG: SessionGate.getInstance(context)
+    SG->>US: loadUserSession()
+    activate US
+    US->>FS: Get user doc
+    activate FS
+    FS-->>US: role = "supervised"
+    deactivate FS
+    US->>US: Cache role + supervisedUserIds = []
+    US-->>SG: onSessionLoaded
+    deactivate US
+    
+    SG->>SG: runPostAuthBootstrap("supervised")
+    SG->>Sync: backfillLocalFromCloudForCurrentUser()
+    activate Sync
+    Sync->>FS: Query messages where userId = currentUserId
+    activate FS
+    FS-->>Sync: QuerySnapshot (0-N messages)
+    deactivate FS
+    Sync->>Sync: Convert to entities
+    Sync->>Sync: Insert into Room (DAO)
+    Sync-->>SG: onSuccess
+    deactivate Sync
+    
+    UI->>Main: Intent(MainActivity), FLAG_CLEAR_TASK
+    UI->>UI: finish()
+    Main->>Main: onCreate, show home screen
+```
+
+### Diagram 2: onProceed() â€“ Supervisor User
+
+```mermaid
+sequenceDiagram
+    actor User
+    participant UI as LoginActivity<br/>(UI Thread)
+    participant FS as Firestore<br/>(Background)
+    participant SG as SessionGate<br/>(Singleton)
+    participant US as UserSession<br/>(Background)
+    participant Sync as FirestoreSyncService<br/>(Background)
+    participant Main as MainActivity
+    
+    User->>UI: Click Continue (supervisor role + email)
+    UI->>UI: Validate email (Gmail format)
+    UI->>UI: Show loading, disable buttons
+    UI->>FS: Save role = "supervisor"<br/>+ supervisedEmail
+    activate FS
+    FS-->>UI: Save successful
+    deactivate FS
+    
+    UI->>SG: SessionGate.getInstance(context)
+    SG->>US: loadUserSession()
+    activate US
+    US->>FS: Get user doc
+    activate FS
+    FS-->>US: role = "supervisor"<br/>supervisedEmail = "child@gmail.com"
+    deactivate FS
+    US->>US: resolveEmailToUserId()
+    US->>FS: Query users where email = "child@gmail.com"
+    activate FS
+    FS-->>US: Doc with UID = "childUid123"
+    deactivate FS
+    US->>US: Cache supervisedUserIds = ["childUid123"]
+    US-->>SG: onSessionLoaded
+    deactivate US
+    
+    SG->>SG: runPostAuthBootstrap("supervisor")
+    SG->>Sync: purgeAndBackfillForSupervisor(["childUid123"])
+    activate Sync
+    Sync->>Sync: Delete from Room where owner_user_id NOT IN ["childUid123"]
+    Sync->>Sync: For each childUid: backfillLocalFromCloudForSupervisedUser()
+    Sync->>FS: Query messages where userId = "childUid123"
+    activate FS
+    FS-->>Sync: QuerySnapshot (0-N messages)
+    deactivate FS
+    Sync->>Sync: Insert into Room with owner_user_id = "childUid123"
+    Sync->>Sync: startSupervisorMirrors(["childUid123"])
+    Sync->>FS: Attach snapshot listener<br/>query: userId=="childUid123" orderBy timestamp
+    activate FS
+    Note over Sync,FS: Real-time listener active<br/>New messages auto-download
+    deactivate FS
+    Sync-->>SG: onSuccess
+    deactivate Sync
+    
+    UI->>Main: Intent(MainActivity), FLAG_CLEAR_TASK
+    UI->>UI: finish()
+    Main->>Main: onCreate, show home screen
+```
+
+### Diagram 3: Bluetooth Message Pipeline (500ms Batch Cycle)
+
+```mermaid
+sequenceDiagram
+    participant BT as DeviceCommunicationThread<br/>(Background)
+    participant Q as Batch Queue<br/>(In-Memory)
+    participant Saver as Batch-Saving Thread<br/>(Background)
+    participant Room as Room Database<br/>(Local SQLite)
+    participant Sync as FirestoreSyncService<br/>(Background)
+    participant FS as Firestore<br/>(Cloud)
+    
+    Note over BT,Q: Message arrives from Bluetooth device
+    BT->>BT: onDataReceived("0xAB3311")
+    BT->>Q: synchronized add(entity)
+    Note over BT,Q: Message queued in memory
+    
+    Note over Saver: Every 500ms (timer loop)
+    Saver->>Saver: sleep(500ms)
+    Saver->>Q: synchronized copy & clear queue
+    alt Batch not empty
+        Saver->>Room: insertAll(batch)
+        Room-->>Saver: Insert complete
+        
+        loop For each entity in batch
+            Saver->>Sync: syncNewMessage(entity)
+            activate Sync
+            
+            alt User is supervised AND online
+                Sync->>FS: firestore.set(documentId, firestoreModel)
+                activate FS
+                FS-->>Sync: Success or Error
+                deactivate FS
+                Sync-->>Saver: onSuccess/onError (logged)
+            else User not supervised OR offline
+                Sync-->>Saver: Skip sync (data stays in Room)
+            end
+            deactivate Sync
+        end
+    else Batch empty
+        Note over Saver: No-op, wait for next cycle
+    end
+    
+    Note over Saver: Loop continues until service destroyed
+```
diff --git a/InnovaMotionApp/docs/Summary.md b/InnovaMotionApp/docs/Summary.md
index 91ddc73..ff180fd 100644
--- a/InnovaMotionApp/docs/Summary.md
+++ b/InnovaMotionApp/docs/Summary.md
@@ -1,39 +1,39 @@
-## ğŸ“˜ Executive Summary
-
-The InnovaMotion app supports two user types:
-1. **Supervised users**: Connect a Bluetooth wearable device, receive posture data, and upload it to the cloud
-2. **Supervisors**: Monitor data from one or more supervised users in real-time
-
-After successful Google sign-in at `LoginActivity.java`, users select their role and the app:
-- Loads their profile from Firebase (on a **background thread**)
-- Backfills historical data from the cloud
-- Routes them to `MainActivity.java`
-
-For **supervised users**, incoming Bluetooth messages follow this pipeline:
-1. Connection thread receives raw data â†’ adds to in-memory batch queue
-2. Batch-saving thread (every **500 ms**) saves batch to local **Room database** â†’ attempts Firebase upload
-3. Retry/offline handling ensures data reaches the cloud when connectivity returns
-
-For **supervisors**, real-time monitoring works via Firestore mirrors:
-1. After login, mirrors (snapshot listeners) attach to supervised users' data streams
-2. New messages automatically download and insert into Room with owner mapping
-3. Fall detection runs on incoming messages â†’ supervisor receives instant notifications
-4. UI updates in real-time as supervised users' devices upload posture data
-
----
-
-## ğŸ“š Glossary
-
-| Term | Definition |
-|------|------------|
-| **Supervised** | A user who wears the Bluetooth device and generates posture data |
-| **Supervisor** | A user who monitors one or more supervised users' data in real-time |
-| **Room** | Android's local SQLite database wrapper (`InnovaDatabase`, table: `ReceivedBtDataEntity`) |
-| **Firebase** | Cloud backend (Firestore for user profiles + Bluetooth messages; Firebase Auth for authentication) |
-| **Backfill** | Downloading historical data from cloud to local Room database after sign-in/role change |
-| **Mirror** | Real-time listener (supervisor only) that downloads new messages from supervised users as they appear in Firebase |
-| **Batch** | In-memory list of messages accumulated over 500 ms before saving to Room |
-| **SessionGate** | Singleton service that orchestrates post-login bootstrap (loads user role, starts backfill, launches mirrors) |
-| **UserSession** | Caches user role and supervised user IDs from Firebase |
-| **FirestoreSyncService** | Handles all cloud â†” local sync operations (upload for supervised, download+mirror for supervisor) |
+## ğŸ“˜ Executive Summary
+
+The InnovaMotion app supports two user types:
+1. **Supervised users**: Connect a Bluetooth wearable device, receive posture data, and upload it to the cloud
+2. **Supervisors**: Monitor data from one or more supervised users in real-time
+
+After successful Google sign-in at `LoginActivity.java`, users select their role and the app:
+- Loads their profile from Firebase (on a **background thread**)
+- Backfills historical data from the cloud
+- Routes them to `MainActivity.java`
+
+For **supervised users**, incoming Bluetooth messages follow this pipeline:
+1. Connection thread receives raw data â†’ adds to in-memory batch queue
+2. Batch-saving thread (every **500 ms**) saves batch to local **Room database** â†’ attempts Firebase upload
+3. Retry/offline handling ensures data reaches the cloud when connectivity returns
+
+For **supervisors**, real-time monitoring works via Firestore mirrors:
+1. After login, mirrors (snapshot listeners) attach to supervised users' data streams
+2. New messages automatically download and insert into Room with owner mapping
+3. Fall detection runs on incoming messages â†’ supervisor receives instant notifications
+4. UI updates in real-time as supervised users' devices upload posture data
+
+---
+
+## ğŸ“š Glossary
+
+| Term | Definition |
+|------|------------|
+| **Supervised** | A user who wears the Bluetooth device and generates posture data |
+| **Supervisor** | A user who monitors one or more supervised users' data in real-time |
+| **Room** | Android's local SQLite database wrapper (`InnovaDatabase`, table: `ReceivedBtDataEntity`) |
+| **Firebase** | Cloud backend (Firestore for user profiles + Bluetooth messages; Firebase Auth for authentication) |
+| **Backfill** | Downloading historical data from cloud to local Room database after sign-in/role change |
+| **Mirror** | Real-time listener (supervisor only) that downloads new messages from supervised users as they appear in Firebase |
+| **Batch** | In-memory list of messages accumulated over 500 ms before saving to Room |
+| **SessionGate** | Singleton service that orchestrates post-login bootstrap (loads user role, starts backfill, launches mirrors) |
+| **UserSession** | Caches user role and supervised user IDs from Firebase |
+| **FirestoreSyncService** | Handles all cloud â†” local sync operations (upload for supervised, download+mirror for supervisor) |
 | **DeviceCommunicationService** | Foreground Android service managing Bluetooth connection and batch-saving thread |
\ No newline at end of file
diff --git a/InnovaMotionApp/docs/Supervisor Mirror Pipeline.md b/InnovaMotionApp/docs/Supervisor Mirror Pipeline.md
index c7edc36..6880edf 100644
--- a/InnovaMotionApp/docs/Supervisor Mirror Pipeline.md	
+++ b/InnovaMotionApp/docs/Supervisor Mirror Pipeline.md	
@@ -1,229 +1,229 @@
-# Supervisor Mirror Pipeline â€“ Detailed Guide
-
-## Overview
-
-When a **supervisor** signs in, the app downloads real-time updates from their **supervised users** via Firestore snapshot listeners (called "mirrors"). This document explains the complete mirror lifecycle.
-
----
-
-## Phase 1: Mirror Setup (After Login)
-
-### Trigger
-- User completes login with role = "supervisor"
-- `SessionGate.runSupervisorPipeline()` executes
-- After backfill completes, `startSupervisorMirrors(supervisedUserIds)` is called
-
-### What Happens
-For each supervised UID:
-1. Attach Firestore listener: `collection("bluetooth_messages").whereEqualTo("userId", supervisedUid)`
-2. Store listener registration in `mirrorByUid` map
-3. Listener fires immediately with **all existing documents** (initial snapshot)
-4. Listener continues firing on **every new/updated document**
-
-### Files Involved
-- `FirestoreSyncService.java`: `startSupervisorMirror(supervisedUserId)`
-- `SessionGate.java`: `runSupervisorPipeline()`
-
----
-
-## Phase 2: Real-Time Updates (Mirror Active)
-
-### Trigger
-- Supervised user's device uploads new message to Firestore
-- Firestore sends snapshot update to supervisor's device
-- Listener callback fires: `queryDocumentSnapshots` parameter contains document changes
-
-### Processing Pipeline
-
-#### Step 1: Receive Snapshot
-**Thread**: Background (Firestore listener callback)
-- Firestore delivers `QuerySnapshot` with list of `DocumentChange` objects
-- Metadata indicates if data is from cache or server: `fromCache` boolean
-
-#### Step 2: Handle Document Changes
-**Thread**: Background (executorService)
-**Method**: `handleSupervisorDocumentChanges(documentChanges, supervisedUserId)`
-
-**Actions per document:**
-1. **Filter**: Only process `ADDED` or `MODIFIED` changes
-2. **Parse**: Convert Firestore doc â†’ `FirestoreDataModel` â†’ extract fields
-3. **Dedup Check**: Query Room: `dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg)`
-   - If exists (returns `1`): Skip this message
-   - If not exists (returns `0`): Continue
-4. **Create Entity**:
-   ```java
-   ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
-     deviceAddress,
-     timestamp,
-     receivedMsg,
-     supervisedUserId  // owner_user_id = supervised user's UID
-   )
-   ```
-5. **Fall Detection** (if message is recent):
-   - Parse posture: `PostureFactory.createPosture(receivedMsg)`
-   - If `FallingPosture` detected:
-     - Fetch supervised user's email from Firestore (async)
-     - Show local notification on supervisor's device
-     - Notification text: "Supervised user ([email]) has fallen"
-6. **Batch Insert**: After processing all changes:
-   - `dao.insertAll(entitiesToInsert)`
-   - Log verification: `dao.dbgCountForOwner(supervisedUserId)`
-
-#### Step 3: UI Update (if BtConnectedActivity is visible)
-**Thread**: UI thread (LiveData observer)
-- `SupervisorFeedViewModel` observes Room database (filtered by target supervised user)
-- New message inserted â†’ LiveData emits new `Posture`
-- `BtConnectedActivity.displayPostureData()` updates UI immediately
-
----
-
-## Phase 3: Fall Detection & Notification
-
-### When It Happens
-- During mirror document processing
-- **Only if**:
-  1. Message timestamp is within **24 hours** of current time
-  2. Message parses as `FallingPosture` type
-
-### Why 24 Hours?
-- Supervisor may be offline when fall occurs
-- On reconnect, mirror fires with all missed messages
-- Still notify supervisor if fall happened recently (within 24h)
-- **Tradeoff**: Risk of notification spam if multiple falls in 24h window
-
-### Notification Flow
-1. Detect fall in `handleSupervisorDocumentChanges()`
-2. **Async fetch supervised user's email**:
-   - Query: `firestore.collection("users").document(supervisedUserId).get()`
-   - Success: Use `email` field for notification text
-   - Failure: Fallback to `supervisedUserId` (UID) for notification text
-3. **Show notification**:
-   - Method: `AlertNotifications.notifyFall(context, who, body)`
-   - Notification appears in system notification tray
-   - Tapping notification opens app (configured in `AlertNotifications`)
-
-### Threading Notes
-- Fall detection: Background thread (part of mirror processing)
-- Email fetch: Background thread (Firestore async get)
-- Notification shown: UI thread (via system NotificationManager)
-
----
-
-## Phase 4: Mirror Lifecycle Events
-
-### Event: Network Disconnected
-**Trigger**: `NetworkConnectivityMonitor` detects offline
-**Action**: `stopAllMirrors()` called
-**Effect**: 
-- All listeners detached (call `listener.remove()`)
-- `mirrorByUid` map cleared
-- No more real-time updates until reconnect
-
-### Event: Network Reconnected
-**Trigger**: `NetworkConnectivityMonitor` detects online
-**Action**: `handleConnectivityRestored()` â†’ `startSupervisorMirrors()` called
-**Effect**:
-- Mirrors re-attached for each supervised UID
-- Listeners fire immediately with all documents (including any missed during offline)
-- Fall notifications may be shown for recent missed falls
-
-### Event: User Signs Out
-**Trigger**: User clicks sign out button
-**Action**: `SessionGate.handleUserSignedOut()` â†’ `stopAllMirrors()` + `clearLocalData()`
-**Effect**:
-- All mirrors stopped
-- Room database cleared (all messages deleted)
-- Next sign-in starts fresh
-
-### Event: User Changes Role
-**Trigger**: User signs out, signs back in with different role (e.g., supervisor â†’ supervised)
-**Action**: `stopAllMirrors()` during sign-out, then `runSupervisedPipeline()` on new sign-in
-**Effect**:
-- Old mirrors properly cleaned up
-- No mirrors started for supervised role
-- Room database purged of old supervised users' data
-
----
-
-## Key Implementation Details
-
-### Owner Mapping (Critical)
-**Problem**: Supervisor's Room database contains messages from **multiple** supervised users. How do we keep them separate?
-
-**Solution**: Every `ReceivedBtDataEntity` has `owner_user_id` field:
-- For **supervised users**: `owner_user_id = currentUserId` (their own UID)
-- For **supervisor mirrors**: `owner_user_id = supervisedUserId` (the supervised user's UID)
-
-**Queries**: All Room queries for supervisors use `WHERE owner_user_id = ?` to filter by supervised user.
-
-### Deduplication Strategy
-**Problem**: Firestore listeners can fire multiple times for the same document (cache vs server updates, reconnect events)
-
-**Solution**: Before inserting, check if message already exists:
-```java
-int exists = dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg);
-if (exists == 0) {
-  // Insert new message
-}
-```
-
-**Why this works**: Unique constraint on `(owner_user_id, device_address, timestamp, received_msg)` ensures no duplicates.
-
-### Mirror Concurrency Control
-**Problem**: Multiple threads might try to start the same mirror simultaneously
-
-**Solution**: Use two data structures:
-1. `mirrorByUid` (Map): Stores active listeners
-2. `startingUids` (Set): Tracks mirrors currently being started
-
-**Logic**:
-```java
-if (mirrorByUid.containsKey(supervisedUserId)) {
-  return; // Already active
-}
-if (startingUids.contains(supervisedUserId)) {
-  return; // Start in progress
-}
-startingUids.add(supervisedUserId);
-// ... attach listener ...
-mirrorByUid.put(supervisedUserId, listener);
-startingUids.remove(supervisedUserId);
-```
-
----
-
-## Files Reference
-
-| File | Responsibility |
-|------|---------------|
-| `FirestoreSyncService.java` | Mirror setup, document processing, fall detection, Room inserts |
-| `SessionGate.java` | Orchestrates mirror start after login, cleanup on sign-out |
-| `NetworkConnectivityMonitor.java` | Detects online/offline, triggers mirror restart |
-| `SupervisorFeedViewModel.java` | Queries Room for latest messages (filtered by supervised user) |
-| `BtConnectedActivity.java` | Observes ViewModel, updates UI with latest posture |
-| `AlertNotifications.java` | Shows fall notifications |
-| `ReceivedBtDataDao.java` | Room database queries (dedup check, insert, owner filtering) |
-
----
-
-## Common Issues & Debugging
-
-### Issue: Supervisor not seeing real-time updates
-**Check**:
-1. Mirror active? Check logs for `"SYNC/Mirror: Attach listener for childUid=..."`
-2. Network online? Check `NetworkConnectivityMonitor.isConnected()`
-3. Messages in Firestore? Query `bluetooth_messages` collection for supervised UID
-4. Owner mapping correct? Check `dao.dbgCountForOwner(supervisedUserId)` â†’ should be > 0
-
-### Issue: Duplicate notifications for same fall
-**Root cause**: Fall detection checks every message in 24h window, no "already notified" tracking
-**Workaround**: Reduce `RECENT_MS` constant (currently 24h) or add "notified" flag to Room database
-
-### Issue: Mirror not restarting after network reconnect
-**Check**:
-1. `handleConnectivityRestored()` called? Check logs for `"Network connectivity restored"`
-2. User session loaded? Check `userSession.isLoaded()` and `userSession.isSupervisor()`
-3. Supervised user IDs present? Check `userSession.getSupervisedUserIds()` â†’ should not be empty
-
----
-
+# Supervisor Mirror Pipeline â€“ Detailed Guide
+
+## Overview
+
+When a **supervisor** signs in, the app downloads real-time updates from their **supervised users** via Firestore snapshot listeners (called "mirrors"). This document explains the complete mirror lifecycle.
+
+---
+
+## Phase 1: Mirror Setup (After Login)
+
+### Trigger
+- User completes login with role = "supervisor"
+- `SessionGate.runSupervisorPipeline()` executes
+- After backfill completes, `startSupervisorMirrors(supervisedUserIds)` is called
+
+### What Happens
+For each supervised UID:
+1. Attach Firestore listener: `collection("bluetooth_messages").whereEqualTo("userId", supervisedUid)`
+2. Store listener registration in `mirrorByUid` map
+3. Listener fires immediately with **all existing documents** (initial snapshot)
+4. Listener continues firing on **every new/updated document**
+
+### Files Involved
+- `FirestoreSyncService.java`: `startSupervisorMirror(supervisedUserId)`
+- `SessionGate.java`: `runSupervisorPipeline()`
+
+---
+
+## Phase 2: Real-Time Updates (Mirror Active)
+
+### Trigger
+- Supervised user's device uploads new message to Firestore
+- Firestore sends snapshot update to supervisor's device
+- Listener callback fires: `queryDocumentSnapshots` parameter contains document changes
+
+### Processing Pipeline
+
+#### Step 1: Receive Snapshot
+**Thread**: Background (Firestore listener callback)
+- Firestore delivers `QuerySnapshot` with list of `DocumentChange` objects
+- Metadata indicates if data is from cache or server: `fromCache` boolean
+
+#### Step 2: Handle Document Changes
+**Thread**: Background (executorService)
+**Method**: `handleSupervisorDocumentChanges(documentChanges, supervisedUserId)`
+
+**Actions per document:**
+1. **Filter**: Only process `ADDED` or `MODIFIED` changes
+2. **Parse**: Convert Firestore doc â†’ `FirestoreDataModel` â†’ extract fields
+3. **Dedup Check**: Query Room: `dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg)`
+   - If exists (returns `1`): Skip this message
+   - If not exists (returns `0`): Continue
+4. **Create Entity**:
+   ```java
+   ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
+     deviceAddress,
+     timestamp,
+     receivedMsg,
+     supervisedUserId  // owner_user_id = supervised user's UID
+   )
+   ```
+5. **Fall Detection** (if message is recent):
+   - Parse posture: `PostureFactory.createPosture(receivedMsg)`
+   - If `FallingPosture` detected:
+     - Fetch supervised user's email from Firestore (async)
+     - Show local notification on supervisor's device
+     - Notification text: "Supervised user ([email]) has fallen"
+6. **Batch Insert**: After processing all changes:
+   - `dao.insertAll(entitiesToInsert)`
+   - Log verification: `dao.dbgCountForOwner(supervisedUserId)`
+
+#### Step 3: UI Update (if BtConnectedActivity is visible)
+**Thread**: UI thread (LiveData observer)
+- `SupervisorFeedViewModel` observes Room database (filtered by target supervised user)
+- New message inserted â†’ LiveData emits new `Posture`
+- `BtConnectedActivity.displayPostureData()` updates UI immediately
+
+---
+
+## Phase 3: Fall Detection & Notification
+
+### When It Happens
+- During mirror document processing
+- **Only if**:
+  1. Message timestamp is within **24 hours** of current time
+  2. Message parses as `FallingPosture` type
+
+### Why 24 Hours?
+- Supervisor may be offline when fall occurs
+- On reconnect, mirror fires with all missed messages
+- Still notify supervisor if fall happened recently (within 24h)
+- **Tradeoff**: Risk of notification spam if multiple falls in 24h window
+
+### Notification Flow
+1. Detect fall in `handleSupervisorDocumentChanges()`
+2. **Async fetch supervised user's email**:
+   - Query: `firestore.collection("users").document(supervisedUserId).get()`
+   - Success: Use `email` field for notification text
+   - Failure: Fallback to `supervisedUserId` (UID) for notification text
+3. **Show notification**:
+   - Method: `AlertNotifications.notifyFall(context, who, body)`
+   - Notification appears in system notification tray
+   - Tapping notification opens app (configured in `AlertNotifications`)
+
+### Threading Notes
+- Fall detection: Background thread (part of mirror processing)
+- Email fetch: Background thread (Firestore async get)
+- Notification shown: UI thread (via system NotificationManager)
+
+---
+
+## Phase 4: Mirror Lifecycle Events
+
+### Event: Network Disconnected
+**Trigger**: `NetworkConnectivityMonitor` detects offline
+**Action**: `stopAllMirrors()` called
+**Effect**: 
+- All listeners detached (call `listener.remove()`)
+- `mirrorByUid` map cleared
+- No more real-time updates until reconnect
+
+### Event: Network Reconnected
+**Trigger**: `NetworkConnectivityMonitor` detects online
+**Action**: `handleConnectivityRestored()` â†’ `startSupervisorMirrors()` called
+**Effect**:
+- Mirrors re-attached for each supervised UID
+- Listeners fire immediately with all documents (including any missed during offline)
+- Fall notifications may be shown for recent missed falls
+
+### Event: User Signs Out
+**Trigger**: User clicks sign out button
+**Action**: `SessionGate.handleUserSignedOut()` â†’ `stopAllMirrors()` + `clearLocalData()`
+**Effect**:
+- All mirrors stopped
+- Room database cleared (all messages deleted)
+- Next sign-in starts fresh
+
+### Event: User Changes Role
+**Trigger**: User signs out, signs back in with different role (e.g., supervisor â†’ supervised)
+**Action**: `stopAllMirrors()` during sign-out, then `runSupervisedPipeline()` on new sign-in
+**Effect**:
+- Old mirrors properly cleaned up
+- No mirrors started for supervised role
+- Room database purged of old supervised users' data
+
+---
+
+## Key Implementation Details
+
+### Owner Mapping (Critical)
+**Problem**: Supervisor's Room database contains messages from **multiple** supervised users. How do we keep them separate?
+
+**Solution**: Every `ReceivedBtDataEntity` has `owner_user_id` field:
+- For **supervised users**: `owner_user_id = currentUserId` (their own UID)
+- For **supervisor mirrors**: `owner_user_id = supervisedUserId` (the supervised user's UID)
+
+**Queries**: All Room queries for supervisors use `WHERE owner_user_id = ?` to filter by supervised user.
+
+### Deduplication Strategy
+**Problem**: Firestore listeners can fire multiple times for the same document (cache vs server updates, reconnect events)
+
+**Solution**: Before inserting, check if message already exists:
+```java
+int exists = dao.messageExistsOwned(supervisedUserId, deviceAddress, timestamp, receivedMsg);
+if (exists == 0) {
+  // Insert new message
+}
+```
+
+**Why this works**: Unique constraint on `(owner_user_id, device_address, timestamp, received_msg)` ensures no duplicates.
+
+### Mirror Concurrency Control
+**Problem**: Multiple threads might try to start the same mirror simultaneously
+
+**Solution**: Use two data structures:
+1. `mirrorByUid` (Map): Stores active listeners
+2. `startingUids` (Set): Tracks mirrors currently being started
+
+**Logic**:
+```java
+if (mirrorByUid.containsKey(supervisedUserId)) {
+  return; // Already active
+}
+if (startingUids.contains(supervisedUserId)) {
+  return; // Start in progress
+}
+startingUids.add(supervisedUserId);
+// ... attach listener ...
+mirrorByUid.put(supervisedUserId, listener);
+startingUids.remove(supervisedUserId);
+```
+
+---
+
+## Files Reference
+
+| File | Responsibility |
+|------|---------------|
+| `FirestoreSyncService.java` | Mirror setup, document processing, fall detection, Room inserts |
+| `SessionGate.java` | Orchestrates mirror start after login, cleanup on sign-out |
+| `NetworkConnectivityMonitor.java` | Detects online/offline, triggers mirror restart |
+| `SupervisorFeedViewModel.java` | Queries Room for latest messages (filtered by supervised user) |
+| `BtConnectedActivity.java` | Observes ViewModel, updates UI with latest posture |
+| `AlertNotifications.java` | Shows fall notifications |
+| `ReceivedBtDataDao.java` | Room database queries (dedup check, insert, owner filtering) |
+
+---
+
+## Common Issues & Debugging
+
+### Issue: Supervisor not seeing real-time updates
+**Check**:
+1. Mirror active? Check logs for `"SYNC/Mirror: Attach listener for childUid=..."`
+2. Network online? Check `NetworkConnectivityMonitor.isConnected()`
+3. Messages in Firestore? Query `bluetooth_messages` collection for supervised UID
+4. Owner mapping correct? Check `dao.dbgCountForOwner(supervisedUserId)` â†’ should be > 0
+
+### Issue: Duplicate notifications for same fall
+**Root cause**: Fall detection checks every message in 24h window, no "already notified" tracking
+**Workaround**: Reduce `RECENT_MS` constant (currently 24h) or add "notified" flag to Room database
+
+### Issue: Mirror not restarting after network reconnect
+**Check**:
+1. `handleConnectivityRestored()` called? Check logs for `"Network connectivity restored"`
+2. User session loaded? Check `userSession.isLoaded()` and `userSession.isSupervisor()`
+3. Supervised user IDs present? Check `userSession.getSupervisedUserIds()` â†’ should not be empty
+
+---
+
diff --git a/InnovaMotionApp/docs/The Big Picture.md b/InnovaMotionApp/docs/The Big Picture.md
index eb7bbd5..22cb969 100644
--- a/InnovaMotionApp/docs/The Big Picture.md	
+++ b/InnovaMotionApp/docs/The Big Picture.md	
@@ -1,29 +1,29 @@
-## ğŸ¯ Final Summary: The Big Picture
-
-1. **Login â†’ Main** is a **multi-step async flow**:
-   - Google Auth â†’ Firestore profile check â†’ Role selection â†’ Firestore save â†’ SessionGate init â†’ UserSession load â†’ Role-based bootstrap (backfill + mirrors) â†’ MainActivity
-   - **Supervised** users end up in a state where they can connect a BT device and start uploading data.
-   - **Supervisor** users end up with local Room database pre-filled with supervised users' data + real-time mirrors active.
-
-2. **Bluetooth Pipeline** (supervised only) is a **three-stage pipeline**:
-   - Stage 1: **BT thread** receives raw messages â†’ adds to in-memory queue
-   - Stage 2: **Batch thread** (every 500ms) drains queue â†’ inserts into Room â†’ triggers Firestore upload
-   - Stage 3: **Sync service** (background) uploads to Firestore if online, otherwise retries when network returns
-   - **Key file**: `DeviceCommunicationService.java` (batchSaving "DeviceCommunicationService.java")
-
-3. **Supervisor Mirror Pipeline** (supervisor only) is a **real-time sync system**:
-   - Stage 1: **Snapshot listeners** (mirrors) attach to supervised users' Firestore data after login
-   - Stage 2: **Mirror callback** fires on new/updated messages â†’ `handleSupervisorDocumentChanges()` processes updates
-   - Stage 3: **Deduplication check** â†’ Create entity with `owner_user_id` mapping â†’ **Fall detection** â†’ Insert to Room
-   - **Fall detection**: If message is recent (24h) AND posture is FallingPosture â†’ fetch supervised user email â†’ show notification
-   - **Key file**: `FirestoreSyncService.java` (method: `handleSupervisorDocumentChanges()`)
-   - **UI updates**: Room LiveData observers trigger automatic UI refresh in `BtConnectedActivity`
-
-4. **Threading discipline**:
-   - All network/DB operations: **Background threads** (executorService, Firestore callbacks, Room DAOs, BT socket)
-   - All UI updates: **UI thread** (via `runOnUiThread()`)
-   - No blocking operations on UI thread (good practice observed throughout)
-
-5. **Offline resilience**:
-   - Supervised users: Messages always saved to Room first, Firestore upload is best-effort (retries on reconnect)
+## ğŸ¯ Final Summary: The Big Picture
+
+1. **Login â†’ Main** is a **multi-step async flow**:
+   - Google Auth â†’ Firestore profile check â†’ Role selection â†’ Firestore save â†’ SessionGate init â†’ UserSession load â†’ Role-based bootstrap (backfill + mirrors) â†’ MainActivity
+   - **Supervised** users end up in a state where they can connect a BT device and start uploading data.
+   - **Supervisor** users end up with local Room database pre-filled with supervised users' data + real-time mirrors active.
+
+2. **Bluetooth Pipeline** (supervised only) is a **three-stage pipeline**:
+   - Stage 1: **BT thread** receives raw messages â†’ adds to in-memory queue
+   - Stage 2: **Batch thread** (every 500ms) drains queue â†’ inserts into Room â†’ triggers Firestore upload
+   - Stage 3: **Sync service** (background) uploads to Firestore if online, otherwise retries when network returns
+   - **Key file**: `DeviceCommunicationService.java` (batchSaving "DeviceCommunicationService.java")
+
+3. **Supervisor Mirror Pipeline** (supervisor only) is a **real-time sync system**:
+   - Stage 1: **Snapshot listeners** (mirrors) attach to supervised users' Firestore data after login
+   - Stage 2: **Mirror callback** fires on new/updated messages â†’ `handleSupervisorDocumentChanges()` processes updates
+   - Stage 3: **Deduplication check** â†’ Create entity with `owner_user_id` mapping â†’ **Fall detection** â†’ Insert to Room
+   - **Fall detection**: If message is recent (24h) AND posture is FallingPosture â†’ fetch supervised user email â†’ show notification
+   - **Key file**: `FirestoreSyncService.java` (method: `handleSupervisorDocumentChanges()`)
+   - **UI updates**: Room LiveData observers trigger automatic UI refresh in `BtConnectedActivity`
+
+4. **Threading discipline**:
+   - All network/DB operations: **Background threads** (executorService, Firestore callbacks, Room DAOs, BT socket)
+   - All UI updates: **UI thread** (via `runOnUiThread()`)
+   - No blocking operations on UI thread (good practice observed throughout)
+
+5. **Offline resilience**:
+   - Supervised users: Messages always saved to Room first, Firestore upload is best-effort (retries on reconnect)
    - Supervisor users: Backfill downloads missing data on reconnect, mirrors re-attach if needed
\ No newline at end of file
diff --git a/InnovaMotionApp/docs/__Feature_Sheet.md b/InnovaMotionApp/docs/__Feature_Sheet.md
index b6833cb..1aa348f 100644
--- a/InnovaMotionApp/docs/__Feature_Sheet.md
+++ b/InnovaMotionApp/docs/__Feature_Sheet.md
@@ -1,198 +1,198 @@
-# InnovaMotion App â€“ Feature Sheet
-
-**For**: Presentations & Stakeholder Communication  
-**Last Updated**: October 2025
-
----
-
-## Core Features
-
-### 1. Real-Time Fall Detection & Alerts
-- Automatic detection when supervised user falls
-- Instant push notifications to supervisor's device
-- Notification includes supervised user's identity (name/email)
-- 24-hour alert window ensures falls aren't missed even during offline periods
-- Smart fall detection via posture analysis from wearable device
-- Multiple notification channels (in-app alerts + system notifications)
-
-### 2. Continuous Posture Monitoring
-- Constant tracking of posture data from wearable Bluetooth device
-- Live updates every 500 milliseconds
-- Visual dashboard showing current posture status
-- Real-time posture classification (standing, sitting, lying, falling)
-- Instant visual feedback with animated posture representations
-- Historical trend analysis capability through local database
-
-### 3. Dual Role System
-- **Supervised User**: Wear the device and generate posture data
-  - Connect personal Bluetooth wearable device
-  - Data automatically collected and uploaded to cloud
-  - Local notifications for fall events
-  - Full control over device connection settings
-- **Supervisors**: Monitor one supervised user remotely
-  - No physical device needed
-  - Real-time dashboard of supervised user
-  - Switch between different supervised user on-demand
-  - Centralized monitoring from single device
-
-### 4. Offline-First Architecture
-- **Supervised user**: Data always saved locally first, then synced to cloud
-- **Supervisors**: Automatic data download when reconnecting to internet
-- No data loss during network interruptions
-- Seamless operation in areas with poor connectivity
-- Local SQLite database (Room) ensures data persistence
-- Automatic background sync when network returns
-- Battery-efficient offline operation
-
-### 5. Intelligent Batch Processing
-- Messages collected in 500-millisecond batches
-- Reduces battery consumption and network usage
-- Prevents database overload during high-frequency data streams
-- Automatic queue management for incoming Bluetooth messages
-- Thread-safe batch processing ensures data integrity
-- Optimized for continuous 24/7 operation
-
-### 6. Real-Time Data Mirroring (Supervisors)
-- Firestore snapshot listeners provide instant updates
-- Changes from supervised user appear immediately on supervisor's device
-- Automatic mirror setup after login
-- Mirrors re-attach automatically after network interruptions
-- Smart deduplication prevents duplicate data entries
-- Live UI updates without manual refresh
-
-### 7. Cloud-Based Data Management
-- Secure Google Firebase authentication with CredentialManager
-- Centralized Firestore database with automatic backup
-- Cross-device accessibility (access data from any device)
-- Automatic document ID generation for unique message tracking
-- Cloud-based user profile management
-- Role and permissions stored securely in Firestore
-
-### 8. Multi-User Supervision
-- Single supervisor can monitor multiple supervised users, separately (one at a time)
-- Individual data streams kept separate via owner mapping
-- Filter and view specific user's data on demand
-- Scalable for institutional use (nursing homes, hospitals, rehabilitation centers)
-- Each supervised user's data tagged with unique owner ID
-- Smart data purging when supervised user are removed
-- Backfill system downloads historical data for new supervised user
-
-### 9. Bluetooth Device Integration
-- Automatic device scanning and discovery
-- Reliable connection management with auto-retry (up to 2 retries)
-- Foreground service ensures connection stays active
-- Persistent notification shows connection status
-- Real-time device status monitoring
-- Graceful handling of connection interruptions
-- Support for standard Bluetooth wearable devices
-
-### 10. Smart Deduplication System
-- Prevents duplicate messages in database
-- Firestore listener can fire multiple timesâ€”system filters duplicates
-- Unique constraint on device address + timestamp + message content
-- Owner-aware deduplication (checks per supervised user)
-- Reduces storage usage and improves query performance
-- Ensures data accuracy and integrity
-
-### 11. Network Resilience & Auto-Retry
-- Automatic detection of network status changes
-- Background retry mechanism for failed uploads
-- Batch upload of missed messages when network returns
-- No user intervention required for sync recovery
-- Smart connectivity monitoring service
-- Handles airplane mode, WiFi switching, and cellular transitions
-- Exponential backoff prevents server overload (assumed)
-
-### 12. Role-Based Navigation & UI
-- Automatic routing based on user role (supervised vs supervisor)
-- Supervised user directed to Bluetooth setup screen
-- Supervisors bypass Bluetooth setup, go directly to monitoring dashboard
-- Role selection saved and pre-filled on subsequent logins
-- Session management handles role switching seamlessly
-- Context-aware UI elements (hide/show based on role)
-
-### 13. Historical Data Access
-- Backfill system downloads past data on first login
-- Query by timestamp to fetch only new messages
-- Local Room database stores complete history
-- Efficient incremental sync (only downloads what's missing)
-- Fast local queries for historical analysis
-- Data survives app reinstalls (cloud backup)
-
-### 14. Owner Mapping System
-- Critical for multi-user supervision
-- Each message tagged with `owner_user_id` field
-- Supervised user: owner = their own ID
-- Supervisor mirrors: owner = supervised user's ID
-- All queries filtered by owner to prevent data mixing
-- Enables accurate per-user analytics and reporting
-
-### 15. Google Sign-In Integration
-- Secure authentication via Google CredentialManager
-- One-tap sign-in experience
-- No password management required
-- Firebase Auth token caching for offline access
-- User profile automatically created on first login
-- Email autocomplete for finding supervised user
-- Validated Gmail email format for supervisor assignments
-
-### 16. Session Management & Bootstrapping
-- SessionGate singleton orchestrates post-login workflow
-- Loads user role and supervised user IDs from Firestore
-- Automatic bootstrap: backfill + mirror setup based on role
-- Session persistence across app restarts
-- Thread-safe session state management
-- Graceful handling of session load errors
-
-### 17. Threading & Performance Optimization
-- All network operations on background threads
-- All database operations on background threads
-- UI updates only on main thread (proper Android practices)
-- No blocking operations that freeze the UI
-- ExecutorService manages background task pool
-- Dedicated Bluetooth thread for device communication
-- Separate batch-saving thread for periodic database inserts
-
-### 18. Comprehensive Error Handling
-- Network errors: Graceful fallback to local storage
-- Bluetooth errors: Automatic reconnection attempts
-- Authentication errors: Clear error messages and prompts
-- Validation errors: Inline feedback on forms
-- Firestore errors: Logged with context for debugging
-- Database errors: Transaction rollback and retry logic
-
-### 19. Developer-Friendly Architecture
-- Clean separation of concerns (UI, Business Logic, Data)
-- Extensive logging for debugging and monitoring
-- Documented decision points and flow branches
-- Assumption tracking for code clarity
-- Thread annotations throughout codebase
-- ViewModel pattern for UI state management
-- Repository pattern for data access
-
-### 20. Notifications & Alerts System
-- Local fall notifications for supervised user
-- Remote fall notifications for supervisors
-- System notification tray integration
-- Notification includes supervised user identification
-- Tappable notifications open app to relevant screen
-- Foreground service notification shows connection status
-- Alert history preserved in Room database
-
----
-
-## Key Differentiators
-
-1. **True Offline Operation**: Unlike competitors, works seamlessly without internet
-2. **Real-Time Supervisor Mirroring**: Instant updates via Firestore listeners, not polling
-3. **Multi-User Supervision**: One supervisor monitors unlimited users
-4. **24-Hour Alert Window**: Catches falls even when supervisor was offline
-5. **Battery-Optimized Batching**: 500ms cycles balance responsiveness and efficiency
-6. **Healthcare-Grade Architecture**: HIPAA-ready, secure, and reliable
-7. **Zero Data Loss Guarantee**: Offline-first design with automatic cloud sync
-8. **Developer-Friendly Codebase**: Well-documented, maintainable, and extensible
-
----
-
-*This feature sheet covers the complete InnovaMotion App ecosystem as documented in October 2025. For technical implementation details, see the full documentation suite.*
-
+# InnovaMotion App â€“ Feature Sheet
+
+**For**: Presentations & Stakeholder Communication  
+**Last Updated**: October 2025
+
+---
+
+## Core Features
+
+### 1. Real-Time Fall Detection & Alerts
+- Automatic detection when supervised user falls
+- Instant push notifications to supervisor's device
+- Notification includes supervised user's identity (name/email)
+- 24-hour alert window ensures falls aren't missed even during offline periods
+- Smart fall detection via posture analysis from wearable device
+- Multiple notification channels (in-app alerts + system notifications)
+
+### 2. Continuous Posture Monitoring
+- Constant tracking of posture data from wearable Bluetooth device
+- Live updates every 500 milliseconds
+- Visual dashboard showing current posture status
+- Real-time posture classification (standing, sitting, lying, falling)
+- Instant visual feedback with animated posture representations
+- Historical trend analysis capability through local database
+
+### 3. Dual Role System
+- **Supervised User**: Wear the device and generate posture data
+  - Connect personal Bluetooth wearable device
+  - Data automatically collected and uploaded to cloud
+  - Local notifications for fall events
+  - Full control over device connection settings
+- **Supervisors**: Monitor one supervised user remotely
+  - No physical device needed
+  - Real-time dashboard of supervised user
+  - Switch between different supervised user on-demand
+  - Centralized monitoring from single device
+
+### 4. Offline-First Architecture
+- **Supervised user**: Data always saved locally first, then synced to cloud
+- **Supervisors**: Automatic data download when reconnecting to internet
+- No data loss during network interruptions
+- Seamless operation in areas with poor connectivity
+- Local SQLite database (Room) ensures data persistence
+- Automatic background sync when network returns
+- Battery-efficient offline operation
+
+### 5. Intelligent Batch Processing
+- Messages collected in 500-millisecond batches
+- Reduces battery consumption and network usage
+- Prevents database overload during high-frequency data streams
+- Automatic queue management for incoming Bluetooth messages
+- Thread-safe batch processing ensures data integrity
+- Optimized for continuous 24/7 operation
+
+### 6. Real-Time Data Mirroring (Supervisors)
+- Firestore snapshot listeners provide instant updates
+- Changes from supervised user appear immediately on supervisor's device
+- Automatic mirror setup after login
+- Mirrors re-attach automatically after network interruptions
+- Smart deduplication prevents duplicate data entries
+- Live UI updates without manual refresh
+
+### 7. Cloud-Based Data Management
+- Secure Google Firebase authentication with CredentialManager
+- Centralized Firestore database with automatic backup
+- Cross-device accessibility (access data from any device)
+- Automatic document ID generation for unique message tracking
+- Cloud-based user profile management
+- Role and permissions stored securely in Firestore
+
+### 8. Multi-User Supervision
+- Single supervisor can monitor multiple supervised users, separately (one at a time)
+- Individual data streams kept separate via owner mapping
+- Filter and view specific user's data on demand
+- Scalable for institutional use (nursing homes, hospitals, rehabilitation centers)
+- Each supervised user's data tagged with unique owner ID
+- Smart data purging when supervised user are removed
+- Backfill system downloads historical data for new supervised user
+
+### 9. Bluetooth Device Integration
+- Automatic device scanning and discovery
+- Reliable connection management with auto-retry (up to 2 retries)
+- Foreground service ensures connection stays active
+- Persistent notification shows connection status
+- Real-time device status monitoring
+- Graceful handling of connection interruptions
+- Support for standard Bluetooth wearable devices
+
+### 10. Smart Deduplication System
+- Prevents duplicate messages in database
+- Firestore listener can fire multiple timesâ€”system filters duplicates
+- Unique constraint on device address + timestamp + message content
+- Owner-aware deduplication (checks per supervised user)
+- Reduces storage usage and improves query performance
+- Ensures data accuracy and integrity
+
+### 11. Network Resilience & Auto-Retry
+- Automatic detection of network status changes
+- Background retry mechanism for failed uploads
+- Batch upload of missed messages when network returns
+- No user intervention required for sync recovery
+- Smart connectivity monitoring service
+- Handles airplane mode, WiFi switching, and cellular transitions
+- Exponential backoff prevents server overload (assumed)
+
+### 12. Role-Based Navigation & UI
+- Automatic routing based on user role (supervised vs supervisor)
+- Supervised user directed to Bluetooth setup screen
+- Supervisors bypass Bluetooth setup, go directly to monitoring dashboard
+- Role selection saved and pre-filled on subsequent logins
+- Session management handles role switching seamlessly
+- Context-aware UI elements (hide/show based on role)
+
+### 13. Historical Data Access
+- Backfill system downloads past data on first login
+- Query by timestamp to fetch only new messages
+- Local Room database stores complete history
+- Efficient incremental sync (only downloads what's missing)
+- Fast local queries for historical analysis
+- Data survives app reinstalls (cloud backup)
+
+### 14. Owner Mapping System
+- Critical for multi-user supervision
+- Each message tagged with `owner_user_id` field
+- Supervised user: owner = their own ID
+- Supervisor mirrors: owner = supervised user's ID
+- All queries filtered by owner to prevent data mixing
+- Enables accurate per-user analytics and reporting
+
+### 15. Google Sign-In Integration
+- Secure authentication via Google CredentialManager
+- One-tap sign-in experience
+- No password management required
+- Firebase Auth token caching for offline access
+- User profile automatically created on first login
+- Email autocomplete for finding supervised user
+- Validated Gmail email format for supervisor assignments
+
+### 16. Session Management & Bootstrapping
+- SessionGate singleton orchestrates post-login workflow
+- Loads user role and supervised user IDs from Firestore
+- Automatic bootstrap: backfill + mirror setup based on role
+- Session persistence across app restarts
+- Thread-safe session state management
+- Graceful handling of session load errors
+
+### 17. Threading & Performance Optimization
+- All network operations on background threads
+- All database operations on background threads
+- UI updates only on main thread (proper Android practices)
+- No blocking operations that freeze the UI
+- ExecutorService manages background task pool
+- Dedicated Bluetooth thread for device communication
+- Separate batch-saving thread for periodic database inserts
+
+### 18. Comprehensive Error Handling
+- Network errors: Graceful fallback to local storage
+- Bluetooth errors: Automatic reconnection attempts
+- Authentication errors: Clear error messages and prompts
+- Validation errors: Inline feedback on forms
+- Firestore errors: Logged with context for debugging
+- Database errors: Transaction rollback and retry logic
+
+### 19. Developer-Friendly Architecture
+- Clean separation of concerns (UI, Business Logic, Data)
+- Extensive logging for debugging and monitoring
+- Documented decision points and flow branches
+- Assumption tracking for code clarity
+- Thread annotations throughout codebase
+- ViewModel pattern for UI state management
+- Repository pattern for data access
+
+### 20. Notifications & Alerts System
+- Local fall notifications for supervised user
+- Remote fall notifications for supervisors
+- System notification tray integration
+- Notification includes supervised user identification
+- Tappable notifications open app to relevant screen
+- Foreground service notification shows connection status
+- Alert history preserved in Room database
+
+---
+
+## Key Differentiators
+
+1. **True Offline Operation**: Unlike competitors, works seamlessly without internet
+2. **Real-Time Supervisor Mirroring**: Instant updates via Firestore listeners, not polling
+3. **Multi-User Supervision**: One supervisor monitors unlimited users
+4. **24-Hour Alert Window**: Catches falls even when supervisor was offline
+5. **Battery-Optimized Batching**: 500ms cycles balance responsiveness and efficiency
+6. **Healthcare-Grade Architecture**: HIPAA-ready, secure, and reliable
+7. **Zero Data Loss Guarantee**: Offline-first design with automatic cloud sync
+8. **Developer-Friendly Codebase**: Well-documented, maintainable, and extensible
+
+---
+
+*This feature sheet covers the complete InnovaMotion App ecosystem as documented in October 2025. For technical implementation details, see the full documentation suite.*
+
diff --git a/InnovaMotionApp/docs/tasks/00-overview.md b/InnovaMotionApp/docs/tasks/00-overview.md
index 0a994d9..7183b98 100644
--- a/InnovaMotionApp/docs/tasks/00-overview.md
+++ b/InnovaMotionApp/docs/tasks/00-overview.md
@@ -1,113 +1,113 @@
-# Multi-User Posture Monitoring System - Task Overview
-
-This folder contains the breakdown of the Multi-User Posture Monitoring System specification into discrete, assignable development tasks.
-
-## Architecture Overview
-
-```mermaid
-flowchart TB
-    subgraph Hardware
-        BT[Bluetooth Device]
-    end
-    
-    subgraph AggregatorPhone[Aggregator Phone]
-        Parser[Packet Parser]
-        LocalDB[(Room DB)]
-        AggUI[Aggregator UI]
-        NameMgr[Person Name Manager]
-    end
-    
-    subgraph Cloud
-        Firestore[(Firestore)]
-    end
-    
-    subgraph SupervisorPhone[Supervisor Phone]
-        SuperDash[Supervisor Dashboard]
-        DetailView[Person Detail View]
-    end
-    
-    BT -->|"sensorId;hexCode\nEND_PACKET"| Parser
-    Parser --> LocalDB
-    LocalDB --> AggUI
-    LocalDB -->|Batch Sync| Firestore
-    Firestore -->|Real-time Sync| SuperDash
-    SuperDash --> DetailView
-    NameMgr --> LocalDB
-    NameMgr --> Firestore
-```
-
----
-
-## Task List
-
-| Task | Description | Effort | Dependencies |
-|------|-------------|--------|--------------|
-| [Task 1](./01-packet-parser.md) | Multi-User Packet Parser | 2-3 days | None |
-| [Task 2](./02-data-model.md) | Data Model Extension | 2-3 days | None |
-| [Task 3](./03-person-names.md) | Monitored Person Entity & Name Management | 2 days | Task 2 |
-| [Task 4](./04-service-integration.md) | DeviceCommunicationService Integration | 2-3 days | Task 1, 2 |
-| [Task 5](./05-message-log-ui.md) | Aggregator UI - Live Message Monitor | 3-4 days | Task 2, 3 |
-| [Task 6](./06-live-posture-ui.md) | Aggregator UI - Live Posture Viewer | 2-3 days | Task 3, 5 |
-| [Task 7](./07-name-management-ui.md) | Person Name Management UI | 2 days | Task 3 |
-| [Task 8](./08-supervisor-dashboard.md) | Supervisor Multi-Person Dashboard | 3-4 days | Task 2, 3 |
-| [Task 9](./09-person-detail-view.md) | Individual Person Detail View | 1-2 days | Task 8 |
-| [Task 10](./10-batch-upload.md) | Firestore Batch Upload Optimization | 2-3 days | Task 2, 4 |
-| [Task 11](./11-query-optimization.md) | Supervisor Query Optimization | 1-2 days | Task 2 |
-| [Task 12](./12-role-terminology.md) | Role Terminology Update | 1 day | None |
-| [Task 13](./13-constants.md) | Constants and Configuration | 0.5 days | All |
-
----
-
-## Task Dependency Graph
-
-```mermaid
-flowchart TD
-    T1[Task 1: Packet Parser]
-    T2[Task 2: Data Model]
-    T3[Task 3: Person Names]
-    T4[Task 4: Service Integration]
-    T5[Task 5: Message Log UI]
-    T6[Task 6: Live Posture UI]
-    T7[Task 7: Name Management UI]
-    T8[Task 8: Supervisor Dashboard]
-    T9[Task 9: Person Detail View]
-    T10[Task 10: Batch Upload]
-    T11[Task 11: Query Optimization]
-    T12[Task 12: Role Terminology]
-    T13[Task 13: Constants]
-    
-    T1 --> T4
-    T2 --> T4
-    T2 --> T3
-    T2 --> T5
-    T2 --> T8
-    T3 --> T5
-    T3 --> T6
-    T3 --> T7
-    T3 --> T8
-    T4 --> T10
-    T5 --> T6
-    T8 --> T9
-    T2 --> T10
-    T2 --> T11
-```
-
----
-
-## Team Assignment Recommendations
-
-| Developer Role | Recommended Tasks |
-|---------------|-------------------|
-| Bluetooth/Backend Dev 1 | Task 1, Task 4 |
-| Backend/Database Dev | Task 2, Task 3, Task 10, Task 11 |
-| UI Developer 1 | Task 5, Task 6, Task 7 |
-| UI Developer 2 | Task 8, Task 9 |
-| Any/Cleanup | Task 12, Task 13 |
-
----
-
-## Sprint Planning Suggestion
-
-**Sprint 1 (Week 1-2):** Tasks 1, 2, 3 (Foundation)  
-**Sprint 2 (Week 2-3):** Tasks 4, 5, 6, 7 (Aggregator Complete)  
-**Sprint 3 (Week 3-4):** Tasks 8, 9, 10, 11, 12, 13 (Supervisor + Polish)
+# Multi-User Posture Monitoring System - Task Overview
+
+This folder contains the breakdown of the Multi-User Posture Monitoring System specification into discrete, assignable development tasks.
+
+## Architecture Overview
+
+```mermaid
+flowchart TB
+    subgraph Hardware
+        BT[Bluetooth Device]
+    end
+    
+    subgraph AggregatorPhone[Aggregator Phone]
+        Parser[Packet Parser]
+        LocalDB[(Room DB)]
+        AggUI[Aggregator UI]
+        NameMgr[Person Name Manager]
+    end
+    
+    subgraph Cloud
+        Firestore[(Firestore)]
+    end
+    
+    subgraph SupervisorPhone[Supervisor Phone]
+        SuperDash[Supervisor Dashboard]
+        DetailView[Person Detail View]
+    end
+    
+    BT -->|"sensorId;hexCode\nEND_PACKET"| Parser
+    Parser --> LocalDB
+    LocalDB --> AggUI
+    LocalDB -->|Batch Sync| Firestore
+    Firestore -->|Real-time Sync| SuperDash
+    SuperDash --> DetailView
+    NameMgr --> LocalDB
+    NameMgr --> Firestore
+```
+
+---
+
+## Task List
+
+| Task | Description | Effort | Dependencies |
+|------|-------------|--------|--------------|
+| [Task 1](./01-packet-parser.md) | Multi-User Packet Parser | 2-3 days | None |
+| [Task 2](./02-data-model.md) | Data Model Extension | 2-3 days | None |
+| [Task 3](./03-person-names.md) | Monitored Person Entity & Name Management | 2 days | Task 2 |
+| [Task 4](./04-service-integration.md) | DeviceCommunicationService Integration | 2-3 days | Task 1, 2 |
+| [Task 5](./05-message-log-ui.md) | Aggregator UI - Live Message Monitor | 3-4 days | Task 2, 3 |
+| [Task 6](./06-live-posture-ui.md) | Aggregator UI - Live Posture Viewer | 2-3 days | Task 3, 5 |
+| [Task 7](./07-name-management-ui.md) | Person Name Management UI | 2 days | Task 3 |
+| [Task 8](./08-supervisor-dashboard.md) | Supervisor Multi-Person Dashboard | 3-4 days | Task 2, 3 |
+| [Task 9](./09-person-detail-view.md) | Individual Person Detail View | 1-2 days | Task 8 |
+| [Task 10](./10-batch-upload.md) | Firestore Batch Upload Optimization | 2-3 days | Task 2, 4 |
+| [Task 11](./11-query-optimization.md) | Supervisor Query Optimization | 1-2 days | Task 2 |
+| [Task 12](./12-role-terminology.md) | Role Terminology Update | 1 day | None |
+| [Task 13](./13-constants.md) | Constants and Configuration | 0.5 days | All |
+
+---
+
+## Task Dependency Graph
+
+```mermaid
+flowchart TD
+    T1[Task 1: Packet Parser]
+    T2[Task 2: Data Model]
+    T3[Task 3: Person Names]
+    T4[Task 4: Service Integration]
+    T5[Task 5: Message Log UI]
+    T6[Task 6: Live Posture UI]
+    T7[Task 7: Name Management UI]
+    T8[Task 8: Supervisor Dashboard]
+    T9[Task 9: Person Detail View]
+    T10[Task 10: Batch Upload]
+    T11[Task 11: Query Optimization]
+    T12[Task 12: Role Terminology]
+    T13[Task 13: Constants]
+    
+    T1 --> T4
+    T2 --> T4
+    T2 --> T3
+    T2 --> T5
+    T2 --> T8
+    T3 --> T5
+    T3 --> T6
+    T3 --> T7
+    T3 --> T8
+    T4 --> T10
+    T5 --> T6
+    T8 --> T9
+    T2 --> T10
+    T2 --> T11
+```
+
+---
+
+## Team Assignment Recommendations
+
+| Developer Role | Recommended Tasks |
+|---------------|-------------------|
+| Bluetooth/Backend Dev 1 | Task 1, Task 4 |
+| Backend/Database Dev | Task 2, Task 3, Task 10, Task 11 |
+| UI Developer 1 | Task 5, Task 6, Task 7 |
+| UI Developer 2 | Task 8, Task 9 |
+| Any/Cleanup | Task 12, Task 13 |
+
+---
+
+## Sprint Planning Suggestion
+
+**Sprint 1 (Week 1-2):** Tasks 1, 2, 3 (Foundation)  
+**Sprint 2 (Week 2-3):** Tasks 4, 5, 6, 7 (Aggregator Complete)  
+**Sprint 3 (Week 3-4):** Tasks 8, 9, 10, 11, 12, 13 (Supervisor + Polish)
diff --git a/InnovaMotionApp/docs/tasks/01-packet-parser.md b/InnovaMotionApp/docs/tasks/01-packet-parser.md
index f18a8be..d1cddf2 100644
--- a/InnovaMotionApp/docs/tasks/01-packet-parser.md
+++ b/InnovaMotionApp/docs/tasks/01-packet-parser.md
@@ -1,119 +1,119 @@
-# TASK 1: Multi-User Packet Parser
-
-**Assigned To:** Backend/Bluetooth Developer  
-**Estimated Effort:** 2-3 days  
-**Dependencies:** None (foundational task)  
-**Status:** Pending
-
----
-
-## Context
-
-The current protocol receives single hex codes like `0xAB3311\n`. The new protocol sends packets with multiple sensor readings:
-
-```
-sensor001;0xAB3311\n
-sensor002;0xEF0112\n
-END_PACKET\n
-```
-
----
-
-## Deliverables
-
-### 1. Create `PacketParser.java` in `bluetooth/` package
-
-- Parse incoming lines and buffer them until `END_PACKET\n` is received
-- Extract `sensorId` and `hexCode` from each line using semicolon delimiter
-- Return a list of `ParsedReading` objects when packet is complete
-- Handle malformed lines gracefully (log and skip)
-
-**Suggested implementation:**
-
-```java
-public class PacketParser {
-    private final List<ParsedReading> buffer = new ArrayList<>();
-    
-    /**
-     * Feed a line to the parser.
-     * @return List of readings if packet is complete, null otherwise
-     */
-    public List<ParsedReading> feedLine(String line) {
-        if ("END_PACKET".equals(line.trim())) {
-            List<ParsedReading> result = new ArrayList<>(buffer);
-            buffer.clear();
-            return result;
-        }
-        
-        ParsedReading reading = parseLine(line);
-        if (reading != null) {
-            buffer.add(reading);
-        }
-        return null;
-    }
-    
-    private ParsedReading parseLine(String line) {
-        // Parse "sensorId;hexCode" format
-        // Return null and log if malformed
-    }
-}
-```
-
-### 2. Create `ParsedReading.java` data class in `bluetooth/` or `data/` package
-
-Fields:
-- `String sensorId` - The sensor/person identifier from hardware
-- `String hexCode` - The posture hex code (e.g., "0xAB3311")
-- `long receivedTimestamp` - When this reading was received
-
-```java
-public class ParsedReading {
-    private final String sensorId;
-    private final String hexCode;
-    private final long receivedTimestamp;
-    
-    // Constructor, getters
-}
-```
-
-### 3. Create unit tests for edge cases
-
-Test scenarios:
-- Empty packets (just `END_PACKET\n`)
-- Malformed lines (no semicolon, empty sensor ID, empty hex code)
-- Large packets (100+ readings)
-- Mixed valid/invalid lines (valid lines should be kept, invalid skipped)
-- Multiple consecutive packets
-- Packet without terminator (buffer grows indefinitely - consider max size limit)
-
----
-
-## Integration Points
-
-- Will be called from `DeviceCommunicationThread.startReceiving()` instead of direct callback
-- Existing callback `onDataReceived()` signature may need extension or new callback interface:
-
-```java
-public interface DataCallback {
-    void onConnectionEstablished(BluetoothDevice device);
-    void onDataReceived(BluetoothDevice device, String data); // Legacy single-line
-    void onPacketReceived(BluetoothDevice device, List<ParsedReading> readings); // NEW
-    void onConnectionDisconnected();
-}
-```
-
----
-
-## Files to Review
-
-- [`DeviceCommunicationThread.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationThread.java) - current line-by-line reading logic
-
----
-
-## Acceptance Criteria
-
-- [ ] `PacketParser` correctly buffers lines until `END_PACKET`
-- [ ] Semicolon delimiter parsing works for various sensor ID formats (UUIDs, simple IDs)
-- [ ] Malformed lines are logged and skipped without crashing
-- [ ] Unit tests cover all edge cases
-- [ ] No memory leaks (buffer is cleared after packet completion)
+# TASK 1: Multi-User Packet Parser
+
+**Assigned To:** Backend/Bluetooth Developer  
+**Estimated Effort:** 2-3 days  
+**Dependencies:** None (foundational task)  
+**Status:** Pending
+
+---
+
+## Context
+
+The current protocol receives single hex codes like `0xAB3311\n`. The new protocol sends packets with multiple sensor readings:
+
+```
+sensor001;0xAB3311\n
+sensor002;0xEF0112\n
+END_PACKET\n
+```
+
+---
+
+## Deliverables
+
+### 1. Create `PacketParser.java` in `bluetooth/` package
+
+- Parse incoming lines and buffer them until `END_PACKET\n` is received
+- Extract `sensorId` and `hexCode` from each line using semicolon delimiter
+- Return a list of `ParsedReading` objects when packet is complete
+- Handle malformed lines gracefully (log and skip)
+
+**Suggested implementation:**
+
+```java
+public class PacketParser {
+    private final List<ParsedReading> buffer = new ArrayList<>();
+    
+    /**
+     * Feed a line to the parser.
+     * @return List of readings if packet is complete, null otherwise
+     */
+    public List<ParsedReading> feedLine(String line) {
+        if ("END_PACKET".equals(line.trim())) {
+            List<ParsedReading> result = new ArrayList<>(buffer);
+            buffer.clear();
+            return result;
+        }
+        
+        ParsedReading reading = parseLine(line);
+        if (reading != null) {
+            buffer.add(reading);
+        }
+        return null;
+    }
+    
+    private ParsedReading parseLine(String line) {
+        // Parse "sensorId;hexCode" format
+        // Return null and log if malformed
+    }
+}
+```
+
+### 2. Create `ParsedReading.java` data class in `bluetooth/` or `data/` package
+
+Fields:
+- `String sensorId` - The sensor/person identifier from hardware
+- `String hexCode` - The posture hex code (e.g., "0xAB3311")
+- `long receivedTimestamp` - When this reading was received
+
+```java
+public class ParsedReading {
+    private final String sensorId;
+    private final String hexCode;
+    private final long receivedTimestamp;
+    
+    // Constructor, getters
+}
+```
+
+### 3. Create unit tests for edge cases
+
+Test scenarios:
+- Empty packets (just `END_PACKET\n`)
+- Malformed lines (no semicolon, empty sensor ID, empty hex code)
+- Large packets (100+ readings)
+- Mixed valid/invalid lines (valid lines should be kept, invalid skipped)
+- Multiple consecutive packets
+- Packet without terminator (buffer grows indefinitely - consider max size limit)
+
+---
+
+## Integration Points
+
+- Will be called from `DeviceCommunicationThread.startReceiving()` instead of direct callback
+- Existing callback `onDataReceived()` signature may need extension or new callback interface:
+
+```java
+public interface DataCallback {
+    void onConnectionEstablished(BluetoothDevice device);
+    void onDataReceived(BluetoothDevice device, String data); // Legacy single-line
+    void onPacketReceived(BluetoothDevice device, List<ParsedReading> readings); // NEW
+    void onConnectionDisconnected();
+}
+```
+
+---
+
+## Files to Review
+
+- [`DeviceCommunicationThread.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationThread.java) - current line-by-line reading logic
+
+---
+
+## Acceptance Criteria
+
+- [ ] `PacketParser` correctly buffers lines until `END_PACKET`
+- [ ] Semicolon delimiter parsing works for various sensor ID formats (UUIDs, simple IDs)
+- [ ] Malformed lines are logged and skipped without crashing
+- [ ] Unit tests cover all edge cases
+- [ ] No memory leaks (buffer is cleared after packet completion)
diff --git a/InnovaMotionApp/docs/tasks/02-data-model.md b/InnovaMotionApp/docs/tasks/02-data-model.md
index 23ea346..1119641 100644
--- a/InnovaMotionApp/docs/tasks/02-data-model.md
+++ b/InnovaMotionApp/docs/tasks/02-data-model.md
@@ -1,152 +1,152 @@
-# TASK 2: Data Model Extension for Multi-User
-
-**Assigned To:** Backend/Database Developer  
-**Estimated Effort:** 2-3 days  
-**Dependencies:** None (can run parallel with Task 1)  
-**Status:** Pending
-
----
-
-## Context
-
-Current `ReceivedBtDataEntity` stores messages per `deviceAddress` (Bluetooth MAC). The new model needs to track per `sensorId` (monitored person ID from hardware).
-
----
-
-## Deliverables
-
-### 1. Update `ReceivedBtDataEntity.java`
-
-Add new field for sensor ID:
-
-```java
-@Nullable
-@ColumnInfo(name = "sensor_id")
-private String sensorId;
-```
-
-Add constructor overload accepting sensorId:
-
-```java
-// New multi-user constructor
-public ReceivedBtDataEntity(
-    @NonNull String deviceAddress, 
-    long timestamp, 
-    @NonNull String receivedMsg,
-    @NonNull String ownerUserId,
-    @NonNull String sensorId
-) {
-    this.deviceAddress = deviceAddress;
-    this.timestamp = timestamp;
-    this.receivedMsg = receivedMsg;
-    this.ownerUserId = ownerUserId;
-    this.sensorId = sensorId;
-}
-```
-
-Update existing constructors for backward compatibility (sensorId = null for legacy data).
-
-Add getter/setter for sensorId.
-
-### 2. Update `ReceivedBtDataDao.java`
-
-Add queries filtered by `sensor_id`:
-
-```java
-// Get latest reading for a specific sensor
-@Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
-LiveData<ReceivedBtDataEntity> getLatestForSensor(String sensorId);
-
-// Get all readings for a specific sensor
-@Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp ASC")
-LiveData<List<ReceivedBtDataEntity>> getAllForSensor(String sensorId);
-
-// Get all distinct sensor IDs (for dropdown/list population)
-@Query("SELECT DISTINCT sensor_id FROM received_bt_data WHERE sensor_id IS NOT NULL")
-LiveData<List<String>> getDistinctSensorIds();
-
-// Get latest reading per sensor (for dashboard - one row per person)
-@Query("SELECT * FROM received_bt_data WHERE sensor_id IS NOT NULL GROUP BY sensor_id HAVING timestamp = MAX(timestamp)")
-LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensor();
-
-// Combined owner + sensor filtering
-@Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
-LiveData<ReceivedBtDataEntity> getLatestForOwnerAndSensor(String ownerUid, String sensorId);
-
-// Get distinct sensors for an owner
-@Query("SELECT DISTINCT sensor_id FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id IS NOT NULL")
-LiveData<List<String>> getDistinctSensorIdsForOwner(String ownerUid);
-```
-
-### 3. Update `FirestoreDataModel.java`
-
-Add sensorId field:
-
-```java
-private String sensorId;
-
-// Update constructor
-public FirestoreDataModel(String deviceAddress, long timestamp, String receivedMsg, String userId, String sensorId) {
-    // ... existing code ...
-    this.sensorId = sensorId;
-    this.documentId = generateDocumentId(userId, deviceAddress, timestamp, sensorId);
-}
-
-// Update generateDocumentId to include sensorId
-public static String generateDocumentId(String userId, String deviceAddress, long timestamp, String sensorId) {
-    String sensorPart = (sensorId != null) ? sensorId : "legacy";
-    return userId + "_" + deviceAddress.replace(":", "") + "_" + sensorPart + "_" + timestamp;
-}
-
-// Update toFirestoreDocument
-public Map<String, Object> toFirestoreDocument() {
-    Map<String, Object> doc = new HashMap<>();
-    // ... existing fields ...
-    doc.put("sensorId", sensorId);
-    return doc;
-}
-
-// Update fromFirestoreDocument
-public static FirestoreDataModel fromFirestoreDocument(Map<String, Object> doc) {
-    // ... existing code ...
-    model.sensorId = (String) doc.get("sensorId");
-    return model;
-}
-```
-
-### 4. Create Room migration
-
-In `InnovaDatabase.java`:
-
-```java
-static final Migration MIGRATION_X_Y = new Migration(X, Y) {
-    @Override
-    public void migrate(@NonNull SupportSQLiteDatabase database) {
-        database.execSQL("ALTER TABLE received_bt_data ADD COLUMN sensor_id TEXT");
-        // Optionally create index for faster queries
-        database.execSQL("CREATE INDEX IF NOT EXISTS index_received_bt_data_sensor_id ON received_bt_data(sensor_id)");
-    }
-};
-```
-
-Update database version and add migration to builder.
-
----
-
-## Files to Modify
-
-- [`ReceivedBtDataEntity.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataEntity.java)
-- [`ReceivedBtDataDao.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java)
-- [`InnovaDatabase.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java)
-- [`FirestoreDataModel.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreDataModel.java)
-
----
-
-## Acceptance Criteria
-
-- [ ] `sensor_id` column added to database with proper migration
-- [ ] All new DAO queries compile and work correctly
-- [ ] Existing data continues to work (backward compatibility)
-- [ ] FirestoreDataModel includes sensorId in serialization/deserialization
-- [ ] Document IDs are unique even with same timestamp but different sensors
-- [ ] Index created for sensor_id column for query performance
+# TASK 2: Data Model Extension for Multi-User
+
+**Assigned To:** Backend/Database Developer  
+**Estimated Effort:** 2-3 days  
+**Dependencies:** None (can run parallel with Task 1)  
+**Status:** Pending
+
+---
+
+## Context
+
+Current `ReceivedBtDataEntity` stores messages per `deviceAddress` (Bluetooth MAC). The new model needs to track per `sensorId` (monitored person ID from hardware).
+
+---
+
+## Deliverables
+
+### 1. Update `ReceivedBtDataEntity.java`
+
+Add new field for sensor ID:
+
+```java
+@Nullable
+@ColumnInfo(name = "sensor_id")
+private String sensorId;
+```
+
+Add constructor overload accepting sensorId:
+
+```java
+// New multi-user constructor
+public ReceivedBtDataEntity(
+    @NonNull String deviceAddress, 
+    long timestamp, 
+    @NonNull String receivedMsg,
+    @NonNull String ownerUserId,
+    @NonNull String sensorId
+) {
+    this.deviceAddress = deviceAddress;
+    this.timestamp = timestamp;
+    this.receivedMsg = receivedMsg;
+    this.ownerUserId = ownerUserId;
+    this.sensorId = sensorId;
+}
+```
+
+Update existing constructors for backward compatibility (sensorId = null for legacy data).
+
+Add getter/setter for sensorId.
+
+### 2. Update `ReceivedBtDataDao.java`
+
+Add queries filtered by `sensor_id`:
+
+```java
+// Get latest reading for a specific sensor
+@Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
+LiveData<ReceivedBtDataEntity> getLatestForSensor(String sensorId);
+
+// Get all readings for a specific sensor
+@Query("SELECT * FROM received_bt_data WHERE sensor_id = :sensorId ORDER BY timestamp ASC")
+LiveData<List<ReceivedBtDataEntity>> getAllForSensor(String sensorId);
+
+// Get all distinct sensor IDs (for dropdown/list population)
+@Query("SELECT DISTINCT sensor_id FROM received_bt_data WHERE sensor_id IS NOT NULL")
+LiveData<List<String>> getDistinctSensorIds();
+
+// Get latest reading per sensor (for dashboard - one row per person)
+@Query("SELECT * FROM received_bt_data WHERE sensor_id IS NOT NULL GROUP BY sensor_id HAVING timestamp = MAX(timestamp)")
+LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensor();
+
+// Combined owner + sensor filtering
+@Query("SELECT * FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id = :sensorId ORDER BY timestamp DESC LIMIT 1")
+LiveData<ReceivedBtDataEntity> getLatestForOwnerAndSensor(String ownerUid, String sensorId);
+
+// Get distinct sensors for an owner
+@Query("SELECT DISTINCT sensor_id FROM received_bt_data WHERE owner_user_id = :ownerUid AND sensor_id IS NOT NULL")
+LiveData<List<String>> getDistinctSensorIdsForOwner(String ownerUid);
+```
+
+### 3. Update `FirestoreDataModel.java`
+
+Add sensorId field:
+
+```java
+private String sensorId;
+
+// Update constructor
+public FirestoreDataModel(String deviceAddress, long timestamp, String receivedMsg, String userId, String sensorId) {
+    // ... existing code ...
+    this.sensorId = sensorId;
+    this.documentId = generateDocumentId(userId, deviceAddress, timestamp, sensorId);
+}
+
+// Update generateDocumentId to include sensorId
+public static String generateDocumentId(String userId, String deviceAddress, long timestamp, String sensorId) {
+    String sensorPart = (sensorId != null) ? sensorId : "legacy";
+    return userId + "_" + deviceAddress.replace(":", "") + "_" + sensorPart + "_" + timestamp;
+}
+
+// Update toFirestoreDocument
+public Map<String, Object> toFirestoreDocument() {
+    Map<String, Object> doc = new HashMap<>();
+    // ... existing fields ...
+    doc.put("sensorId", sensorId);
+    return doc;
+}
+
+// Update fromFirestoreDocument
+public static FirestoreDataModel fromFirestoreDocument(Map<String, Object> doc) {
+    // ... existing code ...
+    model.sensorId = (String) doc.get("sensorId");
+    return model;
+}
+```
+
+### 4. Create Room migration
+
+In `InnovaDatabase.java`:
+
+```java
+static final Migration MIGRATION_X_Y = new Migration(X, Y) {
+    @Override
+    public void migrate(@NonNull SupportSQLiteDatabase database) {
+        database.execSQL("ALTER TABLE received_bt_data ADD COLUMN sensor_id TEXT");
+        // Optionally create index for faster queries
+        database.execSQL("CREATE INDEX IF NOT EXISTS index_received_bt_data_sensor_id ON received_bt_data(sensor_id)");
+    }
+};
+```
+
+Update database version and add migration to builder.
+
+---
+
+## Files to Modify
+
+- [`ReceivedBtDataEntity.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataEntity.java)
+- [`ReceivedBtDataDao.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java)
+- [`InnovaDatabase.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java)
+- [`FirestoreDataModel.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreDataModel.java)
+
+---
+
+## Acceptance Criteria
+
+- [ ] `sensor_id` column added to database with proper migration
+- [ ] All new DAO queries compile and work correctly
+- [ ] Existing data continues to work (backward compatibility)
+- [ ] FirestoreDataModel includes sensorId in serialization/deserialization
+- [ ] Document IDs are unique even with same timestamp but different sensors
+- [ ] Index created for sensor_id column for query performance
diff --git a/InnovaMotionApp/docs/tasks/03-person-names.md b/InnovaMotionApp/docs/tasks/03-person-names.md
index 60ef933..50f76fa 100644
--- a/InnovaMotionApp/docs/tasks/03-person-names.md
+++ b/InnovaMotionApp/docs/tasks/03-person-names.md
@@ -1,279 +1,279 @@
-# TASK 3: Monitored Person Entity and Name Management
-
-**Assigned To:** Backend Developer  
-**Estimated Effort:** 2 days  
-**Dependencies:** Task 2 (data model)  
-**Status:** Pending
-
----
-
-## Context
-
-Sensor IDs like `sensor001` or UUIDs are not human-readable. The system needs to map these to friendly names like "Ion Popescu" that sync to supervisor devices.
-
----
-
-## Deliverables
-
-### 1. Create `MonitoredPerson.java` entity in `data/database/`
-
-```java
-@Entity(
-    tableName = "monitored_persons",
-    indices = {
-        @Index(value = {"sensor_id"}, unique = true)
-    }
-)
-public class MonitoredPerson {
-    @PrimaryKey(autoGenerate = true)
-    @ColumnInfo(name = "id")
-    public long id;
-
-    @NonNull
-    @ColumnInfo(name = "sensor_id")
-    private String sensorId;
-
-    @NonNull
-    @ColumnInfo(name = "display_name")
-    private String displayName;
-
-    @ColumnInfo(name = "created_at")
-    private long createdAt;
-
-    @ColumnInfo(name = "updated_at")
-    private long updatedAt;
-
-    // Constructors, getters, setters
-}
-```
-
-### 2. Create `MonitoredPersonDao.java`
-
-```java
-@Dao
-public interface MonitoredPersonDao {
-
-    @Insert(onConflict = OnConflictStrategy.REPLACE)
-    long insert(MonitoredPerson person);
-
-    @Update
-    void update(MonitoredPerson person);
-
-    @Delete
-    void delete(MonitoredPerson person);
-
-    // Get display name for a sensor, returns null if not found
-    @Query("SELECT display_name FROM monitored_persons WHERE sensor_id = :sensorId LIMIT 1")
-    String getDisplayNameForSensor(String sensorId);
-
-    // Get all monitored persons (LiveData for UI)
-    @Query("SELECT * FROM monitored_persons ORDER BY display_name ASC")
-    LiveData<List<MonitoredPerson>> getAllMonitoredPersons();
-
-    // Synchronous version for background operations
-    @Query("SELECT * FROM monitored_persons ORDER BY display_name ASC")
-    List<MonitoredPerson> getAllMonitoredPersonsSync();
-
-    // Upsert by sensor ID
-    @Query("INSERT OR REPLACE INTO monitored_persons (sensor_id, display_name, created_at, updated_at) " +
-           "VALUES (:sensorId, :displayName, :now, :now)")
-    void upsertByName(String sensorId, String displayName, long now);
-
-    // Check if sensor exists
-    @Query("SELECT COUNT(*) FROM monitored_persons WHERE sensor_id = :sensorId")
-    int sensorExists(String sensorId);
-
-    // Get person by sensor ID
-    @Query("SELECT * FROM monitored_persons WHERE sensor_id = :sensorId LIMIT 1")
-    MonitoredPerson getPersonBySensorId(String sensorId);
-}
-```
-
-### 3. Create `PersonNameManager.java` in `utils/` or new `managers/` package
-
-```java
-public class PersonNameManager {
-    private static PersonNameManager instance;
-    private final MonitoredPersonDao dao;
-    private final ExecutorService executor;
-
-    private PersonNameManager(Context context) {
-        this.dao = InnovaDatabase.getInstance(context).monitoredPersonDao();
-        this.executor = Executors.newSingleThreadExecutor();
-    }
-
-    public static synchronized PersonNameManager getInstance(Context context) {
-        if (instance == null) {
-            instance = new PersonNameManager(context.getApplicationContext());
-        }
-        return instance;
-    }
-
-    /**
-     * Get display name for a sensor ID.
-     * Returns the sensorId itself if no friendly name is set.
-     * Must be called off main thread.
-     */
-    public String getDisplayName(String sensorId) {
-        String name = dao.getDisplayNameForSensor(sensorId);
-        return (name != null && !name.isEmpty()) ? name : sensorId;
-    }
-
-    /**
-     * Set display name for a sensor ID.
-     * Creates entry if it doesn't exist.
-     */
-    public void setDisplayName(String sensorId, String displayName) {
-        executor.execute(() -> {
-            dao.upsertByName(sensorId, displayName, System.currentTimeMillis());
-        });
-    }
-
-    /**
-     * Ensure a sensor ID exists in the database.
-     * If not, creates an entry with sensorId as the default display name.
-     * Call this when a new sensor is first seen.
-     */
-    public void ensureSensorExists(String sensorId) {
-        executor.execute(() -> {
-            if (dao.sensorExists(sensorId) == 0) {
-                dao.upsertByName(sensorId, sensorId, System.currentTimeMillis());
-            }
-        });
-    }
-
-    /**
-     * Get LiveData of all monitored persons for UI.
-     */
-    public LiveData<List<MonitoredPerson>> getAllPersonsLive() {
-        return dao.getAllMonitoredPersons();
-    }
-}
-```
-
-### 4. Update `InnovaDatabase.java`
-
-```java
-@Database(
-    entities = {
-        ReceivedBtDataEntity.class,
-        MonitoredPerson.class  // ADD THIS
-    },
-    version = X + 1,  // INCREMENT VERSION
-    exportSchema = false
-)
-public abstract class InnovaDatabase extends RoomDatabase {
-    // ... existing code ...
-    
-    public abstract MonitoredPersonDao monitoredPersonDao();  // ADD THIS
-}
-
-// Add migration
-static final Migration MIGRATION_X_Y = new Migration(X, Y) {
-    @Override
-    public void migrate(@NonNull SupportSQLiteDatabase database) {
-        database.execSQL(
-            "CREATE TABLE IF NOT EXISTS monitored_persons (" +
-            "id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
-            "sensor_id TEXT NOT NULL, " +
-            "display_name TEXT NOT NULL, " +
-            "created_at INTEGER NOT NULL DEFAULT 0, " +
-            "updated_at INTEGER NOT NULL DEFAULT 0)"
-        );
-        database.execSQL(
-            "CREATE UNIQUE INDEX IF NOT EXISTS index_monitored_persons_sensor_id ON monitored_persons(sensor_id)"
-        );
-    }
-};
-```
-
----
-
-## Sub-task 3b: Cloud Sync for Person Names
-
-### 5. Create `PersonNamesFirestoreSync.java` in `sync/`
-
-```java
-public class PersonNamesFirestoreSync {
-    private static final String TAG = "PersonNamesSync";
-    private static final String COLLECTION_MONITORED_PERSONS = "monitored_persons";
-    
-    private final FirebaseFirestore firestore;
-    private final MonitoredPersonDao dao;
-    private final String aggregatorUid;
-    
-    /**
-     * Upload all person names to Firestore.
-     * Collection path: users/{aggregatorUid}/monitored_persons/{sensorId}
-     */
-    public void uploadAllNames(SyncCallback callback) {
-        List<MonitoredPerson> persons = dao.getAllMonitoredPersonsSync();
-        
-        WriteBatch batch = firestore.batch();
-        for (MonitoredPerson person : persons) {
-            DocumentReference docRef = firestore
-                .collection("users")
-                .document(aggregatorUid)
-                .collection(COLLECTION_MONITORED_PERSONS)
-                .document(person.getSensorId());
-            
-            Map<String, Object> data = new HashMap<>();
-            data.put("sensorId", person.getSensorId());
-            data.put("displayName", person.getDisplayName());
-            data.put("updatedAt", person.getUpdatedAt());
-            
-            batch.set(docRef, data);
-        }
-        
-        batch.commit()
-            .addOnSuccessListener(aVoid -> callback.onSuccess("Uploaded " + persons.size() + " names"))
-            .addOnFailureListener(e -> callback.onError(e.getMessage()));
-    }
-    
-    /**
-     * Download person names from a specific aggregator (for supervisors).
-     */
-    public void downloadNamesFromAggregator(String aggregatorUid, SyncCallback callback) {
-        firestore.collection("users")
-            .document(aggregatorUid)
-            .collection(COLLECTION_MONITORED_PERSONS)
-            .get()
-            .addOnSuccessListener(querySnapshot -> {
-                for (DocumentSnapshot doc : querySnapshot) {
-                    String sensorId = doc.getString("sensorId");
-                    String displayName = doc.getString("displayName");
-                    if (sensorId != null && displayName != null) {
-                        dao.upsertByName(sensorId, displayName, System.currentTimeMillis());
-                    }
-                }
-                callback.onSuccess("Downloaded " + querySnapshot.size() + " names");
-            })
-            .addOnFailureListener(e -> callback.onError(e.getMessage()));
-    }
-}
-```
-
----
-
-## Files to Create
-
-- `app/src/main/java/com/melisa/innovamotionapp/data/database/MonitoredPerson.java`
-- `app/src/main/java/com/melisa/innovamotionapp/data/database/MonitoredPersonDao.java`
-- `app/src/main/java/com/melisa/innovamotionapp/utils/PersonNameManager.java` (or `managers/`)
-- `app/src/main/java/com/melisa/innovamotionapp/sync/PersonNamesFirestoreSync.java`
-
-## Files to Modify
-
-- [`InnovaDatabase.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java)
-
----
-
-## Acceptance Criteria
-
-- [ ] `MonitoredPerson` entity created with proper Room annotations
-- [ ] DAO provides all necessary CRUD and query operations
-- [ ] `PersonNameManager` provides simple API for name lookup with fallback
-- [ ] New sensors are auto-registered when first seen
-- [ ] Person names sync to Firestore for supervisor access
-- [ ] Supervisors can download names from their linked aggregator
-- [ ] Database migration works correctly
+# TASK 3: Monitored Person Entity and Name Management
+
+**Assigned To:** Backend Developer  
+**Estimated Effort:** 2 days  
+**Dependencies:** Task 2 (data model)  
+**Status:** Pending
+
+---
+
+## Context
+
+Sensor IDs like `sensor001` or UUIDs are not human-readable. The system needs to map these to friendly names like "Ion Popescu" that sync to supervisor devices.
+
+---
+
+## Deliverables
+
+### 1. Create `MonitoredPerson.java` entity in `data/database/`
+
+```java
+@Entity(
+    tableName = "monitored_persons",
+    indices = {
+        @Index(value = {"sensor_id"}, unique = true)
+    }
+)
+public class MonitoredPerson {
+    @PrimaryKey(autoGenerate = true)
+    @ColumnInfo(name = "id")
+    public long id;
+
+    @NonNull
+    @ColumnInfo(name = "sensor_id")
+    private String sensorId;
+
+    @NonNull
+    @ColumnInfo(name = "display_name")
+    private String displayName;
+
+    @ColumnInfo(name = "created_at")
+    private long createdAt;
+
+    @ColumnInfo(name = "updated_at")
+    private long updatedAt;
+
+    // Constructors, getters, setters
+}
+```
+
+### 2. Create `MonitoredPersonDao.java`
+
+```java
+@Dao
+public interface MonitoredPersonDao {
+
+    @Insert(onConflict = OnConflictStrategy.REPLACE)
+    long insert(MonitoredPerson person);
+
+    @Update
+    void update(MonitoredPerson person);
+
+    @Delete
+    void delete(MonitoredPerson person);
+
+    // Get display name for a sensor, returns null if not found
+    @Query("SELECT display_name FROM monitored_persons WHERE sensor_id = :sensorId LIMIT 1")
+    String getDisplayNameForSensor(String sensorId);
+
+    // Get all monitored persons (LiveData for UI)
+    @Query("SELECT * FROM monitored_persons ORDER BY display_name ASC")
+    LiveData<List<MonitoredPerson>> getAllMonitoredPersons();
+
+    // Synchronous version for background operations
+    @Query("SELECT * FROM monitored_persons ORDER BY display_name ASC")
+    List<MonitoredPerson> getAllMonitoredPersonsSync();
+
+    // Upsert by sensor ID
+    @Query("INSERT OR REPLACE INTO monitored_persons (sensor_id, display_name, created_at, updated_at) " +
+           "VALUES (:sensorId, :displayName, :now, :now)")
+    void upsertByName(String sensorId, String displayName, long now);
+
+    // Check if sensor exists
+    @Query("SELECT COUNT(*) FROM monitored_persons WHERE sensor_id = :sensorId")
+    int sensorExists(String sensorId);
+
+    // Get person by sensor ID
+    @Query("SELECT * FROM monitored_persons WHERE sensor_id = :sensorId LIMIT 1")
+    MonitoredPerson getPersonBySensorId(String sensorId);
+}
+```
+
+### 3. Create `PersonNameManager.java` in `utils/` or new `managers/` package
+
+```java
+public class PersonNameManager {
+    private static PersonNameManager instance;
+    private final MonitoredPersonDao dao;
+    private final ExecutorService executor;
+
+    private PersonNameManager(Context context) {
+        this.dao = InnovaDatabase.getInstance(context).monitoredPersonDao();
+        this.executor = Executors.newSingleThreadExecutor();
+    }
+
+    public static synchronized PersonNameManager getInstance(Context context) {
+        if (instance == null) {
+            instance = new PersonNameManager(context.getApplicationContext());
+        }
+        return instance;
+    }
+
+    /**
+     * Get display name for a sensor ID.
+     * Returns the sensorId itself if no friendly name is set.
+     * Must be called off main thread.
+     */
+    public String getDisplayName(String sensorId) {
+        String name = dao.getDisplayNameForSensor(sensorId);
+        return (name != null && !name.isEmpty()) ? name : sensorId;
+    }
+
+    /**
+     * Set display name for a sensor ID.
+     * Creates entry if it doesn't exist.
+     */
+    public void setDisplayName(String sensorId, String displayName) {
+        executor.execute(() -> {
+            dao.upsertByName(sensorId, displayName, System.currentTimeMillis());
+        });
+    }
+
+    /**
+     * Ensure a sensor ID exists in the database.
+     * If not, creates an entry with sensorId as the default display name.
+     * Call this when a new sensor is first seen.
+     */
+    public void ensureSensorExists(String sensorId) {
+        executor.execute(() -> {
+            if (dao.sensorExists(sensorId) == 0) {
+                dao.upsertByName(sensorId, sensorId, System.currentTimeMillis());
+            }
+        });
+    }
+
+    /**
+     * Get LiveData of all monitored persons for UI.
+     */
+    public LiveData<List<MonitoredPerson>> getAllPersonsLive() {
+        return dao.getAllMonitoredPersons();
+    }
+}
+```
+
+### 4. Update `InnovaDatabase.java`
+
+```java
+@Database(
+    entities = {
+        ReceivedBtDataEntity.class,
+        MonitoredPerson.class  // ADD THIS
+    },
+    version = X + 1,  // INCREMENT VERSION
+    exportSchema = false
+)
+public abstract class InnovaDatabase extends RoomDatabase {
+    // ... existing code ...
+    
+    public abstract MonitoredPersonDao monitoredPersonDao();  // ADD THIS
+}
+
+// Add migration
+static final Migration MIGRATION_X_Y = new Migration(X, Y) {
+    @Override
+    public void migrate(@NonNull SupportSQLiteDatabase database) {
+        database.execSQL(
+            "CREATE TABLE IF NOT EXISTS monitored_persons (" +
+            "id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
+            "sensor_id TEXT NOT NULL, " +
+            "display_name TEXT NOT NULL, " +
+            "created_at INTEGER NOT NULL DEFAULT 0, " +
+            "updated_at INTEGER NOT NULL DEFAULT 0)"
+        );
+        database.execSQL(
+            "CREATE UNIQUE INDEX IF NOT EXISTS index_monitored_persons_sensor_id ON monitored_persons(sensor_id)"
+        );
+    }
+};
+```
+
+---
+
+## Sub-task 3b: Cloud Sync for Person Names
+
+### 5. Create `PersonNamesFirestoreSync.java` in `sync/`
+
+```java
+public class PersonNamesFirestoreSync {
+    private static final String TAG = "PersonNamesSync";
+    private static final String COLLECTION_MONITORED_PERSONS = "monitored_persons";
+    
+    private final FirebaseFirestore firestore;
+    private final MonitoredPersonDao dao;
+    private final String aggregatorUid;
+    
+    /**
+     * Upload all person names to Firestore.
+     * Collection path: users/{aggregatorUid}/monitored_persons/{sensorId}
+     */
+    public void uploadAllNames(SyncCallback callback) {
+        List<MonitoredPerson> persons = dao.getAllMonitoredPersonsSync();
+        
+        WriteBatch batch = firestore.batch();
+        for (MonitoredPerson person : persons) {
+            DocumentReference docRef = firestore
+                .collection("users")
+                .document(aggregatorUid)
+                .collection(COLLECTION_MONITORED_PERSONS)
+                .document(person.getSensorId());
+            
+            Map<String, Object> data = new HashMap<>();
+            data.put("sensorId", person.getSensorId());
+            data.put("displayName", person.getDisplayName());
+            data.put("updatedAt", person.getUpdatedAt());
+            
+            batch.set(docRef, data);
+        }
+        
+        batch.commit()
+            .addOnSuccessListener(aVoid -> callback.onSuccess("Uploaded " + persons.size() + " names"))
+            .addOnFailureListener(e -> callback.onError(e.getMessage()));
+    }
+    
+    /**
+     * Download person names from a specific aggregator (for supervisors).
+     */
+    public void downloadNamesFromAggregator(String aggregatorUid, SyncCallback callback) {
+        firestore.collection("users")
+            .document(aggregatorUid)
+            .collection(COLLECTION_MONITORED_PERSONS)
+            .get()
+            .addOnSuccessListener(querySnapshot -> {
+                for (DocumentSnapshot doc : querySnapshot) {
+                    String sensorId = doc.getString("sensorId");
+                    String displayName = doc.getString("displayName");
+                    if (sensorId != null && displayName != null) {
+                        dao.upsertByName(sensorId, displayName, System.currentTimeMillis());
+                    }
+                }
+                callback.onSuccess("Downloaded " + querySnapshot.size() + " names");
+            })
+            .addOnFailureListener(e -> callback.onError(e.getMessage()));
+    }
+}
+```
+
+---
+
+## Files to Create
+
+- `app/src/main/java/com/melisa/innovamotionapp/data/database/MonitoredPerson.java`
+- `app/src/main/java/com/melisa/innovamotionapp/data/database/MonitoredPersonDao.java`
+- `app/src/main/java/com/melisa/innovamotionapp/utils/PersonNameManager.java` (or `managers/`)
+- `app/src/main/java/com/melisa/innovamotionapp/sync/PersonNamesFirestoreSync.java`
+
+## Files to Modify
+
+- [`InnovaDatabase.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/InnovaDatabase.java)
+
+---
+
+## Acceptance Criteria
+
+- [ ] `MonitoredPerson` entity created with proper Room annotations
+- [ ] DAO provides all necessary CRUD and query operations
+- [ ] `PersonNameManager` provides simple API for name lookup with fallback
+- [ ] New sensors are auto-registered when first seen
+- [ ] Person names sync to Firestore for supervisor access
+- [ ] Supervisors can download names from their linked aggregator
+- [ ] Database migration works correctly
diff --git a/InnovaMotionApp/docs/tasks/04-service-integration.md b/InnovaMotionApp/docs/tasks/04-service-integration.md
index 3139029..dd46822 100644
--- a/InnovaMotionApp/docs/tasks/04-service-integration.md
+++ b/InnovaMotionApp/docs/tasks/04-service-integration.md
@@ -1,185 +1,185 @@
-# TASK 4: DeviceCommunicationService Multi-User Integration
-
-**Assigned To:** Backend/Bluetooth Developer  
-**Estimated Effort:** 2-3 days  
-**Dependencies:** Task 1 (Parser), Task 2 (Data Model)  
-**Status:** Pending
-
----
-
-## Context
-
-The service currently processes single readings. It needs to buffer lines, detect `END_PACKET`, and process batches.
-
----
-
-## Deliverables
-
-### 1. Modify `DeviceCommunicationService.java`
-
-Replace single-reading `onDataReceived` handling with packet-based processing:
-
-```java
-public class DeviceCommunicationService extends Service {
-    // ... existing fields ...
-    
-    private PacketParser packetParser;
-    private PersonNameManager personNameManager;
-    
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        // ... existing init ...
-        
-        packetParser = new PacketParser();
-        personNameManager = PersonNameManager.getInstance(this);
-    }
-    
-    public void connectToDevice(BluetoothDevice device) {
-        // ... existing connection setup ...
-        
-        deviceCommunicationThread = new DeviceCommunicationThread(device, new DeviceCommunicationThread.DataCallback() {
-            
-            @Override
-            public void onDataReceived(BluetoothDevice device, String receivedData) {
-                // Feed line to packet parser
-                List<ParsedReading> completedPacket = packetParser.feedLine(receivedData);
-                
-                if (completedPacket != null && !completedPacket.isEmpty()) {
-                    // Packet is complete, process it
-                    processPacket(device, completedPacket);
-                }
-            }
-            
-            // ... other callbacks unchanged ...
-        });
-    }
-    
-    /**
-     * Process a complete packet of readings.
-     */
-    private void processPacket(BluetoothDevice device, List<ParsedReading> readings) {
-        Log.d(TAG, "[Service] Processing packet with " + readings.size() + " readings");
-        
-        final long now = System.currentTimeMillis();
-        String ownerUid = null;
-        if (userSession.isLoaded() && userSession.isSupervised()) {
-            ownerUid = firestoreSyncService.getCurrentUserId();
-        }
-        
-        List<ReceivedBtDataEntity> entities = new ArrayList<>();
-        
-        for (ParsedReading reading : readings) {
-            // Ensure this sensor exists in person names database
-            personNameManager.ensureSensorExists(reading.getSensorId());
-            
-            // Create entity with sensor ID
-            ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
-                device.getAddress(),
-                reading.getReceivedTimestamp(),
-                reading.getHexCode(),
-                ownerUid,
-                reading.getSensorId()
-            );
-            entities.add(entity);
-            
-            // Convert to Posture for UI updates and fall detection
-            Posture posture = PostureFactory.createPosture(reading.getHexCode());
-            
-            // Check for falls - include sensor ID in alert
-            if (posture instanceof FallingPosture) {
-                String personName = personNameManager.getDisplayName(reading.getSensorId());
-                AlertNotifications.notifyFall(
-                    DeviceCommunicationService.this,
-                    personName,
-                    getString(R.string.notif_fall_text_generic)
-                );
-            }
-            
-            // Update UI with most recent reading
-            // Note: May want to track per-sensor for multi-user dashboard
-            GlobalData.getInstance().setReceivedPosture(posture);
-        }
-        
-        // Batch insert all entities
-        synchronized (lock) {
-            temporaryReceivedBtDataListToSave.addAll(entities);
-        }
-        
-        // Log file (optional - consider if still needed)
-        try {
-            for (ParsedReading reading : readings) {
-                fileOutputStream.write((reading.getSensorId() + ";" + reading.getHexCode() + "\n").getBytes());
-            }
-        } catch (IOException e) {
-            Log.e(TAG, "ERROR writing posture file", e);
-        }
-    }
-}
-```
-
-### 2. Update `DeviceCommunicationThread.DataCallback`
-
-Option A: Keep existing interface, parser handles buffering in Service.
-
-Option B: Add new callback method:
-
-```java
-public interface DataCallback {
-    void onConnectionEstablished(BluetoothDevice device);
-    void onDataReceived(BluetoothDevice device, String data);
-    
-    // NEW: Called when a complete packet is received
-    default void onPacketReceived(BluetoothDevice device, List<ParsedReading> readings) {
-        // Default implementation for backward compatibility
-    }
-    
-    void onConnectionDisconnected();
-}
-```
-
-### 3. Update fall notification logic
-
-Modify `AlertNotifications.notifyFall()` to include person name:
-
-```java
-public static void notifyFall(Context context, String personName, String messageBody) {
-    String title = context.getString(R.string.notif_fall_title, personName);
-    // ... existing notification code using personName in title/body ...
-}
-```
-
-Update string resources:
-```xml
-<string name="notif_fall_title">Fall Detected: %1$s</string>
-<string name="notif_fall_text_generic">may have fallen. Check immediately.</string>
-```
-
----
-
-## Files to Modify
-
-- [`DeviceCommunicationService.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java)
-- [`DeviceCommunicationThread.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationThread.java) (if adding new callback)
-- [`AlertNotifications.java`](../../app/src/main/java/com/melisa/innovamotionapp/utils/AlertNotifications.java)
-- String resources (`strings.xml`)
-
----
-
-## Integration Points
-
-- Uses `PacketParser` from Task 1
-- Uses updated `ReceivedBtDataEntity` from Task 2
-- Uses `PersonNameManager` from Task 3
-
----
-
-## Acceptance Criteria
-
-- [ ] Packets are correctly buffered until `END_PACKET`
-- [ ] Each reading in packet creates a separate database entity with sensorId
-- [ ] Fall notifications include person name/sensor ID
-- [ ] Multiple readings per packet are batch-inserted efficiently
-- [ ] New sensor IDs are auto-registered in person names table
-- [ ] Legacy single-line format still works (backward compatibility - optional)
-- [ ] No blocking on main thread
+# TASK 4: DeviceCommunicationService Multi-User Integration
+
+**Assigned To:** Backend/Bluetooth Developer  
+**Estimated Effort:** 2-3 days  
+**Dependencies:** Task 1 (Parser), Task 2 (Data Model)  
+**Status:** Pending
+
+---
+
+## Context
+
+The service currently processes single readings. It needs to buffer lines, detect `END_PACKET`, and process batches.
+
+---
+
+## Deliverables
+
+### 1. Modify `DeviceCommunicationService.java`
+
+Replace single-reading `onDataReceived` handling with packet-based processing:
+
+```java
+public class DeviceCommunicationService extends Service {
+    // ... existing fields ...
+    
+    private PacketParser packetParser;
+    private PersonNameManager personNameManager;
+    
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        // ... existing init ...
+        
+        packetParser = new PacketParser();
+        personNameManager = PersonNameManager.getInstance(this);
+    }
+    
+    public void connectToDevice(BluetoothDevice device) {
+        // ... existing connection setup ...
+        
+        deviceCommunicationThread = new DeviceCommunicationThread(device, new DeviceCommunicationThread.DataCallback() {
+            
+            @Override
+            public void onDataReceived(BluetoothDevice device, String receivedData) {
+                // Feed line to packet parser
+                List<ParsedReading> completedPacket = packetParser.feedLine(receivedData);
+                
+                if (completedPacket != null && !completedPacket.isEmpty()) {
+                    // Packet is complete, process it
+                    processPacket(device, completedPacket);
+                }
+            }
+            
+            // ... other callbacks unchanged ...
+        });
+    }
+    
+    /**
+     * Process a complete packet of readings.
+     */
+    private void processPacket(BluetoothDevice device, List<ParsedReading> readings) {
+        Log.d(TAG, "[Service] Processing packet with " + readings.size() + " readings");
+        
+        final long now = System.currentTimeMillis();
+        String ownerUid = null;
+        if (userSession.isLoaded() && userSession.isSupervised()) {
+            ownerUid = firestoreSyncService.getCurrentUserId();
+        }
+        
+        List<ReceivedBtDataEntity> entities = new ArrayList<>();
+        
+        for (ParsedReading reading : readings) {
+            // Ensure this sensor exists in person names database
+            personNameManager.ensureSensorExists(reading.getSensorId());
+            
+            // Create entity with sensor ID
+            ReceivedBtDataEntity entity = new ReceivedBtDataEntity(
+                device.getAddress(),
+                reading.getReceivedTimestamp(),
+                reading.getHexCode(),
+                ownerUid,
+                reading.getSensorId()
+            );
+            entities.add(entity);
+            
+            // Convert to Posture for UI updates and fall detection
+            Posture posture = PostureFactory.createPosture(reading.getHexCode());
+            
+            // Check for falls - include sensor ID in alert
+            if (posture instanceof FallingPosture) {
+                String personName = personNameManager.getDisplayName(reading.getSensorId());
+                AlertNotifications.notifyFall(
+                    DeviceCommunicationService.this,
+                    personName,
+                    getString(R.string.notif_fall_text_generic)
+                );
+            }
+            
+            // Update UI with most recent reading
+            // Note: May want to track per-sensor for multi-user dashboard
+            GlobalData.getInstance().setReceivedPosture(posture);
+        }
+        
+        // Batch insert all entities
+        synchronized (lock) {
+            temporaryReceivedBtDataListToSave.addAll(entities);
+        }
+        
+        // Log file (optional - consider if still needed)
+        try {
+            for (ParsedReading reading : readings) {
+                fileOutputStream.write((reading.getSensorId() + ";" + reading.getHexCode() + "\n").getBytes());
+            }
+        } catch (IOException e) {
+            Log.e(TAG, "ERROR writing posture file", e);
+        }
+    }
+}
+```
+
+### 2. Update `DeviceCommunicationThread.DataCallback`
+
+Option A: Keep existing interface, parser handles buffering in Service.
+
+Option B: Add new callback method:
+
+```java
+public interface DataCallback {
+    void onConnectionEstablished(BluetoothDevice device);
+    void onDataReceived(BluetoothDevice device, String data);
+    
+    // NEW: Called when a complete packet is received
+    default void onPacketReceived(BluetoothDevice device, List<ParsedReading> readings) {
+        // Default implementation for backward compatibility
+    }
+    
+    void onConnectionDisconnected();
+}
+```
+
+### 3. Update fall notification logic
+
+Modify `AlertNotifications.notifyFall()` to include person name:
+
+```java
+public static void notifyFall(Context context, String personName, String messageBody) {
+    String title = context.getString(R.string.notif_fall_title, personName);
+    // ... existing notification code using personName in title/body ...
+}
+```
+
+Update string resources:
+```xml
+<string name="notif_fall_title">Fall Detected: %1$s</string>
+<string name="notif_fall_text_generic">may have fallen. Check immediately.</string>
+```
+
+---
+
+## Files to Modify
+
+- [`DeviceCommunicationService.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java)
+- [`DeviceCommunicationThread.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationThread.java) (if adding new callback)
+- [`AlertNotifications.java`](../../app/src/main/java/com/melisa/innovamotionapp/utils/AlertNotifications.java)
+- String resources (`strings.xml`)
+
+---
+
+## Integration Points
+
+- Uses `PacketParser` from Task 1
+- Uses updated `ReceivedBtDataEntity` from Task 2
+- Uses `PersonNameManager` from Task 3
+
+---
+
+## Acceptance Criteria
+
+- [ ] Packets are correctly buffered until `END_PACKET`
+- [ ] Each reading in packet creates a separate database entity with sensorId
+- [ ] Fall notifications include person name/sensor ID
+- [ ] Multiple readings per packet are batch-inserted efficiently
+- [ ] New sensor IDs are auto-registered in person names table
+- [ ] Legacy single-line format still works (backward compatibility - optional)
+- [ ] No blocking on main thread
diff --git a/InnovaMotionApp/docs/tasks/05-message-log-ui.md b/InnovaMotionApp/docs/tasks/05-message-log-ui.md
index 3966177..22ba1c4 100644
--- a/InnovaMotionApp/docs/tasks/05-message-log-ui.md
+++ b/InnovaMotionApp/docs/tasks/05-message-log-ui.md
@@ -1,433 +1,433 @@
-# TASK 5: Aggregator UI - Live Message Monitor (Tab 1)
-
-**Assigned To:** UI/Android Developer  
-**Estimated Effort:** 3-4 days  
-**Dependencies:** Task 2 (Data Model), Task 3 (Person Names)  
-**Status:** Pending
-
----
-
-## Context
-
-New debugging interface for aggregator phones showing real-time message log with per-person statistics.
-
----
-
-## Deliverables
-
-### 1. Create `AggregatorDashboardActivity.java` in `activities/`
-
-```java
-public class AggregatorDashboardActivity extends BaseActivity {
-    private ActivityAggregatorDashboardBinding binding;
-    private AggregatorDashboardPagerAdapter pagerAdapter;
-    
-    @Override
-    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
-        binding = ActivityAggregatorDashboardBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-        
-        setupViewPager();
-        setupTabLayout();
-    }
-    
-    private void setupViewPager() {
-        pagerAdapter = new AggregatorDashboardPagerAdapter(this);
-        binding.viewPager.setAdapter(pagerAdapter);
-    }
-    
-    private void setupTabLayout() {
-        new TabLayoutMediator(binding.tabLayout, binding.viewPager, (tab, position) -> {
-            switch (position) {
-                case 0:
-                    tab.setText(R.string.tab_message_log);
-                    tab.setIcon(R.drawable.ic_list);
-                    break;
-                case 1:
-                    tab.setText(R.string.tab_live_posture);
-                    tab.setIcon(R.drawable.ic_person);
-                    break;
-            }
-        }).attach();
-    }
-}
-
-// Pager Adapter
-public class AggregatorDashboardPagerAdapter extends FragmentStateAdapter {
-    public AggregatorDashboardPagerAdapter(@NonNull FragmentActivity fragmentActivity) {
-        super(fragmentActivity);
-    }
-    
-    @NonNull
-    @Override
-    public Fragment createFragment(int position) {
-        switch (position) {
-            case 0: return new MessageLogFragment();
-            case 1: return new LivePostureFragment();
-            default: throw new IllegalArgumentException("Invalid position: " + position);
-        }
-    }
-    
-    @Override
-    public int getItemCount() {
-        return 2;
-    }
-}
-```
-
-### 2. Create `MessageLogFragment.java` in new `ui/fragments/` package
-
-```java
-public class MessageLogFragment extends Fragment {
-    private FragmentMessageLogBinding binding;
-    private MessageLogViewModel viewModel;
-    private MessageLogAdapter adapter;
-    
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        binding = FragmentMessageLogBinding.inflate(inflater, container, false);
-        return binding.getRoot();
-    }
-    
-    @Override
-    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        
-        viewModel = new ViewModelProvider(this).get(MessageLogViewModel.class);
-        
-        setupRecyclerView();
-        setupFilters();
-        observeData();
-    }
-    
-    private void setupRecyclerView() {
-        adapter = new MessageLogAdapter();
-        binding.recyclerView.setLayoutManager(new LinearLayoutManager(requireContext()));
-        binding.recyclerView.setAdapter(adapter);
-        
-        // Auto-scroll to bottom for new messages
-        adapter.registerAdapterDataObserver(new RecyclerView.AdapterDataObserver() {
-            @Override
-            public void onItemRangeInserted(int positionStart, int itemCount) {
-                if (binding.autoScrollSwitch.isChecked()) {
-                    binding.recyclerView.smoothScrollToPosition(adapter.getItemCount() - 1);
-                }
-            }
-        });
-    }
-    
-    private void setupFilters() {
-        // Sensor filter spinner
-        viewModel.getAvailableSensors().observe(getViewLifecycleOwner(), sensors -> {
-            // Populate filter spinner
-        });
-        
-        binding.filterSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
-            @Override
-            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
-                String selectedSensor = (String) parent.getItemAtPosition(position);
-                viewModel.setFilterSensor(selectedSensor);
-            }
-            // ...
-        });
-    }
-    
-    private void observeData() {
-        viewModel.getMessages().observe(getViewLifecycleOwner(), messages -> {
-            adapter.submitList(messages);
-        });
-        
-        viewModel.getMessageCountsPerSensor().observe(getViewLifecycleOwner(), counts -> {
-            // Update summary header
-            updateSummaryHeader(counts);
-        });
-    }
-}
-```
-
-### 3. Create `MessageLogAdapter.java` in `ui/adapters/`
-
-```java
-public class MessageLogAdapter extends ListAdapter<MessageLogItem, MessageLogAdapter.ViewHolder> {
-    
-    public MessageLogAdapter() {
-        super(new DiffCallback());
-    }
-    
-    @NonNull
-    @Override
-    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
-        ItemMessageLogBinding binding = ItemMessageLogBinding.inflate(
-            LayoutInflater.from(parent.getContext()), parent, false);
-        return new ViewHolder(binding);
-    }
-    
-    @Override
-    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
-        holder.bind(getItem(position));
-    }
-    
-    static class ViewHolder extends RecyclerView.ViewHolder {
-        private final ItemMessageLogBinding binding;
-        
-        ViewHolder(ItemMessageLogBinding binding) {
-            super(binding.getRoot());
-            this.binding = binding;
-        }
-        
-        void bind(MessageLogItem item) {
-            binding.timestampText.setText(formatTimestamp(item.getTimestamp()));
-            binding.sensorNameText.setText(item.getDisplayName());
-            binding.hexCodeText.setText(item.getHexCode());
-            binding.postureIcon.setImageResource(item.getPostureIconRes());
-            
-            // Highlight falls in red
-            if (item.isFall()) {
-                binding.cardView.setCardBackgroundColor(
-                    ContextCompat.getColor(itemView.getContext(), R.color.fall_alert_background));
-            } else {
-                binding.cardView.setCardBackgroundColor(
-                    ContextCompat.getColor(itemView.getContext(), R.color.card_background));
-            }
-        }
-    }
-    
-    static class DiffCallback extends DiffUtil.ItemCallback<MessageLogItem> {
-        @Override
-        public boolean areItemsTheSame(@NonNull MessageLogItem oldItem, @NonNull MessageLogItem newItem) {
-            return oldItem.getId() == newItem.getId();
-        }
-        
-        @Override
-        public boolean areContentsTheSame(@NonNull MessageLogItem oldItem, @NonNull MessageLogItem newItem) {
-            return oldItem.equals(newItem);
-        }
-    }
-}
-```
-
-### 4. Create `MessageLogViewModel.java` in `ui/viewmodels/`
-
-```java
-public class MessageLogViewModel extends AndroidViewModel {
-    private final ReceivedBtDataDao dao;
-    private final PersonNameManager personNameManager;
-    private final MutableLiveData<String> filterSensor = new MutableLiveData<>(null);
-    
-    // Transformed data
-    private final LiveData<List<MessageLogItem>> messages;
-    private final LiveData<List<String>> availableSensors;
-    private final LiveData<Map<String, Integer>> messageCountsPerSensor;
-    
-    public MessageLogViewModel(@NonNull Application application) {
-        super(application);
-        dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
-        personNameManager = PersonNameManager.getInstance(application);
-        
-        // Get recent messages (limit to last 500)
-        LiveData<List<ReceivedBtDataEntity>> rawMessages = dao.getRecentMessages(500);
-        
-        // Transform to UI model with person names
-        messages = Transformations.switchMap(filterSensor, sensor -> {
-            LiveData<List<ReceivedBtDataEntity>> filtered = 
-                (sensor == null || sensor.isEmpty()) 
-                    ? rawMessages 
-                    : dao.getMessagesForSensor(sensor, 500);
-            
-            return Transformations.map(filtered, entities -> {
-                List<MessageLogItem> items = new ArrayList<>();
-                for (ReceivedBtDataEntity entity : entities) {
-                    items.add(new MessageLogItem(
-                        entity.getId(),
-                        entity.getTimestamp(),
-                        entity.getSensorId(),
-                        personNameManager.getDisplayName(entity.getSensorId()),
-                        entity.getReceivedMsg(),
-                        getPostureIcon(entity.getReceivedMsg()),
-                        isFallPosture(entity.getReceivedMsg())
-                    ));
-                }
-                return items;
-            });
-        });
-        
-        availableSensors = dao.getDistinctSensorIds();
-        
-        // Message counts per sensor
-        messageCountsPerSensor = Transformations.map(rawMessages, entities -> {
-            Map<String, Integer> counts = new HashMap<>();
-            for (ReceivedBtDataEntity entity : entities) {
-                String sensor = entity.getSensorId();
-                counts.put(sensor, counts.getOrDefault(sensor, 0) + 1);
-            }
-            return counts;
-        });
-    }
-    
-    public void setFilterSensor(String sensor) {
-        filterSensor.setValue(sensor);
-    }
-    
-    // Getters for LiveData...
-}
-```
-
-### 5. Create layouts
-
-**`activity_aggregator_dashboard.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical">
-    
-    <com.google.android.material.tabs.TabLayout
-        android:id="@+id/tabLayout"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content" />
-    
-    <androidx.viewpager2.widget.ViewPager2
-        android:id="@+id/viewPager"
-        android:layout_width="match_parent"
-        android:layout_height="0dp"
-        android:layout_weight="1" />
-        
-</LinearLayout>
-```
-
-**`fragment_message_log.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical">
-    
-    <!-- Summary Header -->
-    <LinearLayout
-        android:id="@+id/summaryHeader"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:padding="8dp"
-        android:orientation="horizontal">
-        <!-- Message counts per person will go here -->
-    </LinearLayout>
-    
-    <!-- Filter Controls -->
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:padding="8dp"
-        android:orientation="horizontal">
-        
-        <Spinner
-            android:id="@+id/filterSpinner"
-            android:layout_width="0dp"
-            android:layout_weight="1"
-            android:layout_height="wrap_content" />
-        
-        <com.google.android.material.switchmaterial.SwitchMaterial
-            android:id="@+id/autoScrollSwitch"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Auto-scroll"
-            android:checked="true" />
-    </LinearLayout>
-    
-    <!-- Message List -->
-    <androidx.recyclerview.widget.RecyclerView
-        android:id="@+id/recyclerView"
-        android:layout_width="match_parent"
-        android:layout_height="0dp"
-        android:layout_weight="1" />
-        
-</LinearLayout>
-```
-
-**`item_message_log.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<com.google.android.material.card.MaterialCardView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/cardView"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:layout_margin="4dp">
-    
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="horizontal"
-        android:padding="8dp">
-        
-        <ImageView
-            android:id="@+id/postureIcon"
-            android:layout_width="40dp"
-            android:layout_height="40dp" />
-        
-        <LinearLayout
-            android:layout_width="0dp"
-            android:layout_weight="1"
-            android:layout_height="wrap_content"
-            android:layout_marginStart="8dp"
-            android:orientation="vertical">
-            
-            <TextView
-                android:id="@+id/sensorNameText"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:textStyle="bold" />
-            
-            <TextView
-                android:id="@+id/hexCodeText"
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:textSize="12sp" />
-        </LinearLayout>
-        
-        <TextView
-            android:id="@+id/timestampText"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:textSize="10sp" />
-    </LinearLayout>
-</com.google.android.material.card.MaterialCardView>
-```
-
----
-
-## UI Specification
-
-- Show last 100-500 messages (configurable via Constants)
-- Auto-scroll to bottom for new messages (optional toggle)
-- Tap message to see full details (optional - could show dialog)
-- Fall messages highlighted with red background or icon
-- Filter by sensor/person in dropdown
-- Summary header shows message count per person
-
----
-
-## Files to Create
-
-- `app/src/main/java/com/melisa/innovamotionapp/activities/AggregatorDashboardActivity.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/fragments/MessageLogFragment.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/adapters/MessageLogAdapter.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/MessageLogViewModel.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/models/MessageLogItem.java`
-- `app/src/main/res/layout/activity_aggregator_dashboard.xml`
-- `app/src/main/res/layout/fragment_message_log.xml`
-- `app/src/main/res/layout/item_message_log.xml`
-
----
-
-## Acceptance Criteria
-
-- [ ] TabLayout with ViewPager2 works correctly
-- [ ] Messages display in real-time as they arrive
-- [ ] Each message shows timestamp, person name, hex code, posture icon
-- [ ] Fall messages are visually highlighted (red)
-- [ ] Message count per person displayed in summary
-- [ ] Filter dropdown works to show only one person's messages
-- [ ] Auto-scroll toggle works
-- [ ] Smooth performance with 500+ messages (DiffUtil)
+# TASK 5: Aggregator UI - Live Message Monitor (Tab 1)
+
+**Assigned To:** UI/Android Developer  
+**Estimated Effort:** 3-4 days  
+**Dependencies:** Task 2 (Data Model), Task 3 (Person Names)  
+**Status:** Pending
+
+---
+
+## Context
+
+New debugging interface for aggregator phones showing real-time message log with per-person statistics.
+
+---
+
+## Deliverables
+
+### 1. Create `AggregatorDashboardActivity.java` in `activities/`
+
+```java
+public class AggregatorDashboardActivity extends BaseActivity {
+    private ActivityAggregatorDashboardBinding binding;
+    private AggregatorDashboardPagerAdapter pagerAdapter;
+    
+    @Override
+    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
+        binding = ActivityAggregatorDashboardBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+        
+        setupViewPager();
+        setupTabLayout();
+    }
+    
+    private void setupViewPager() {
+        pagerAdapter = new AggregatorDashboardPagerAdapter(this);
+        binding.viewPager.setAdapter(pagerAdapter);
+    }
+    
+    private void setupTabLayout() {
+        new TabLayoutMediator(binding.tabLayout, binding.viewPager, (tab, position) -> {
+            switch (position) {
+                case 0:
+                    tab.setText(R.string.tab_message_log);
+                    tab.setIcon(R.drawable.ic_list);
+                    break;
+                case 1:
+                    tab.setText(R.string.tab_live_posture);
+                    tab.setIcon(R.drawable.ic_person);
+                    break;
+            }
+        }).attach();
+    }
+}
+
+// Pager Adapter
+public class AggregatorDashboardPagerAdapter extends FragmentStateAdapter {
+    public AggregatorDashboardPagerAdapter(@NonNull FragmentActivity fragmentActivity) {
+        super(fragmentActivity);
+    }
+    
+    @NonNull
+    @Override
+    public Fragment createFragment(int position) {
+        switch (position) {
+            case 0: return new MessageLogFragment();
+            case 1: return new LivePostureFragment();
+            default: throw new IllegalArgumentException("Invalid position: " + position);
+        }
+    }
+    
+    @Override
+    public int getItemCount() {
+        return 2;
+    }
+}
+```
+
+### 2. Create `MessageLogFragment.java` in new `ui/fragments/` package
+
+```java
+public class MessageLogFragment extends Fragment {
+    private FragmentMessageLogBinding binding;
+    private MessageLogViewModel viewModel;
+    private MessageLogAdapter adapter;
+    
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        binding = FragmentMessageLogBinding.inflate(inflater, container, false);
+        return binding.getRoot();
+    }
+    
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        
+        viewModel = new ViewModelProvider(this).get(MessageLogViewModel.class);
+        
+        setupRecyclerView();
+        setupFilters();
+        observeData();
+    }
+    
+    private void setupRecyclerView() {
+        adapter = new MessageLogAdapter();
+        binding.recyclerView.setLayoutManager(new LinearLayoutManager(requireContext()));
+        binding.recyclerView.setAdapter(adapter);
+        
+        // Auto-scroll to bottom for new messages
+        adapter.registerAdapterDataObserver(new RecyclerView.AdapterDataObserver() {
+            @Override
+            public void onItemRangeInserted(int positionStart, int itemCount) {
+                if (binding.autoScrollSwitch.isChecked()) {
+                    binding.recyclerView.smoothScrollToPosition(adapter.getItemCount() - 1);
+                }
+            }
+        });
+    }
+    
+    private void setupFilters() {
+        // Sensor filter spinner
+        viewModel.getAvailableSensors().observe(getViewLifecycleOwner(), sensors -> {
+            // Populate filter spinner
+        });
+        
+        binding.filterSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                String selectedSensor = (String) parent.getItemAtPosition(position);
+                viewModel.setFilterSensor(selectedSensor);
+            }
+            // ...
+        });
+    }
+    
+    private void observeData() {
+        viewModel.getMessages().observe(getViewLifecycleOwner(), messages -> {
+            adapter.submitList(messages);
+        });
+        
+        viewModel.getMessageCountsPerSensor().observe(getViewLifecycleOwner(), counts -> {
+            // Update summary header
+            updateSummaryHeader(counts);
+        });
+    }
+}
+```
+
+### 3. Create `MessageLogAdapter.java` in `ui/adapters/`
+
+```java
+public class MessageLogAdapter extends ListAdapter<MessageLogItem, MessageLogAdapter.ViewHolder> {
+    
+    public MessageLogAdapter() {
+        super(new DiffCallback());
+    }
+    
+    @NonNull
+    @Override
+    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        ItemMessageLogBinding binding = ItemMessageLogBinding.inflate(
+            LayoutInflater.from(parent.getContext()), parent, false);
+        return new ViewHolder(binding);
+    }
+    
+    @Override
+    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
+        holder.bind(getItem(position));
+    }
+    
+    static class ViewHolder extends RecyclerView.ViewHolder {
+        private final ItemMessageLogBinding binding;
+        
+        ViewHolder(ItemMessageLogBinding binding) {
+            super(binding.getRoot());
+            this.binding = binding;
+        }
+        
+        void bind(MessageLogItem item) {
+            binding.timestampText.setText(formatTimestamp(item.getTimestamp()));
+            binding.sensorNameText.setText(item.getDisplayName());
+            binding.hexCodeText.setText(item.getHexCode());
+            binding.postureIcon.setImageResource(item.getPostureIconRes());
+            
+            // Highlight falls in red
+            if (item.isFall()) {
+                binding.cardView.setCardBackgroundColor(
+                    ContextCompat.getColor(itemView.getContext(), R.color.fall_alert_background));
+            } else {
+                binding.cardView.setCardBackgroundColor(
+                    ContextCompat.getColor(itemView.getContext(), R.color.card_background));
+            }
+        }
+    }
+    
+    static class DiffCallback extends DiffUtil.ItemCallback<MessageLogItem> {
+        @Override
+        public boolean areItemsTheSame(@NonNull MessageLogItem oldItem, @NonNull MessageLogItem newItem) {
+            return oldItem.getId() == newItem.getId();
+        }
+        
+        @Override
+        public boolean areContentsTheSame(@NonNull MessageLogItem oldItem, @NonNull MessageLogItem newItem) {
+            return oldItem.equals(newItem);
+        }
+    }
+}
+```
+
+### 4. Create `MessageLogViewModel.java` in `ui/viewmodels/`
+
+```java
+public class MessageLogViewModel extends AndroidViewModel {
+    private final ReceivedBtDataDao dao;
+    private final PersonNameManager personNameManager;
+    private final MutableLiveData<String> filterSensor = new MutableLiveData<>(null);
+    
+    // Transformed data
+    private final LiveData<List<MessageLogItem>> messages;
+    private final LiveData<List<String>> availableSensors;
+    private final LiveData<Map<String, Integer>> messageCountsPerSensor;
+    
+    public MessageLogViewModel(@NonNull Application application) {
+        super(application);
+        dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
+        personNameManager = PersonNameManager.getInstance(application);
+        
+        // Get recent messages (limit to last 500)
+        LiveData<List<ReceivedBtDataEntity>> rawMessages = dao.getRecentMessages(500);
+        
+        // Transform to UI model with person names
+        messages = Transformations.switchMap(filterSensor, sensor -> {
+            LiveData<List<ReceivedBtDataEntity>> filtered = 
+                (sensor == null || sensor.isEmpty()) 
+                    ? rawMessages 
+                    : dao.getMessagesForSensor(sensor, 500);
+            
+            return Transformations.map(filtered, entities -> {
+                List<MessageLogItem> items = new ArrayList<>();
+                for (ReceivedBtDataEntity entity : entities) {
+                    items.add(new MessageLogItem(
+                        entity.getId(),
+                        entity.getTimestamp(),
+                        entity.getSensorId(),
+                        personNameManager.getDisplayName(entity.getSensorId()),
+                        entity.getReceivedMsg(),
+                        getPostureIcon(entity.getReceivedMsg()),
+                        isFallPosture(entity.getReceivedMsg())
+                    ));
+                }
+                return items;
+            });
+        });
+        
+        availableSensors = dao.getDistinctSensorIds();
+        
+        // Message counts per sensor
+        messageCountsPerSensor = Transformations.map(rawMessages, entities -> {
+            Map<String, Integer> counts = new HashMap<>();
+            for (ReceivedBtDataEntity entity : entities) {
+                String sensor = entity.getSensorId();
+                counts.put(sensor, counts.getOrDefault(sensor, 0) + 1);
+            }
+            return counts;
+        });
+    }
+    
+    public void setFilterSensor(String sensor) {
+        filterSensor.setValue(sensor);
+    }
+    
+    // Getters for LiveData...
+}
+```
+
+### 5. Create layouts
+
+**`activity_aggregator_dashboard.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+    
+    <com.google.android.material.tabs.TabLayout
+        android:id="@+id/tabLayout"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" />
+    
+    <androidx.viewpager2.widget.ViewPager2
+        android:id="@+id/viewPager"
+        android:layout_width="match_parent"
+        android:layout_height="0dp"
+        android:layout_weight="1" />
+        
+</LinearLayout>
+```
+
+**`fragment_message_log.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+    
+    <!-- Summary Header -->
+    <LinearLayout
+        android:id="@+id/summaryHeader"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:padding="8dp"
+        android:orientation="horizontal">
+        <!-- Message counts per person will go here -->
+    </LinearLayout>
+    
+    <!-- Filter Controls -->
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:padding="8dp"
+        android:orientation="horizontal">
+        
+        <Spinner
+            android:id="@+id/filterSpinner"
+            android:layout_width="0dp"
+            android:layout_weight="1"
+            android:layout_height="wrap_content" />
+        
+        <com.google.android.material.switchmaterial.SwitchMaterial
+            android:id="@+id/autoScrollSwitch"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="Auto-scroll"
+            android:checked="true" />
+    </LinearLayout>
+    
+    <!-- Message List -->
+    <androidx.recyclerview.widget.RecyclerView
+        android:id="@+id/recyclerView"
+        android:layout_width="match_parent"
+        android:layout_height="0dp"
+        android:layout_weight="1" />
+        
+</LinearLayout>
+```
+
+**`item_message_log.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<com.google.android.material.card.MaterialCardView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/cardView"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:layout_margin="4dp">
+    
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:padding="8dp">
+        
+        <ImageView
+            android:id="@+id/postureIcon"
+            android:layout_width="40dp"
+            android:layout_height="40dp" />
+        
+        <LinearLayout
+            android:layout_width="0dp"
+            android:layout_weight="1"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:orientation="vertical">
+            
+            <TextView
+                android:id="@+id/sensorNameText"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textStyle="bold" />
+            
+            <TextView
+                android:id="@+id/hexCodeText"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="12sp" />
+        </LinearLayout>
+        
+        <TextView
+            android:id="@+id/timestampText"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="10sp" />
+    </LinearLayout>
+</com.google.android.material.card.MaterialCardView>
+```
+
+---
+
+## UI Specification
+
+- Show last 100-500 messages (configurable via Constants)
+- Auto-scroll to bottom for new messages (optional toggle)
+- Tap message to see full details (optional - could show dialog)
+- Fall messages highlighted with red background or icon
+- Filter by sensor/person in dropdown
+- Summary header shows message count per person
+
+---
+
+## Files to Create
+
+- `app/src/main/java/com/melisa/innovamotionapp/activities/AggregatorDashboardActivity.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/fragments/MessageLogFragment.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/adapters/MessageLogAdapter.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/MessageLogViewModel.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/models/MessageLogItem.java`
+- `app/src/main/res/layout/activity_aggregator_dashboard.xml`
+- `app/src/main/res/layout/fragment_message_log.xml`
+- `app/src/main/res/layout/item_message_log.xml`
+
+---
+
+## Acceptance Criteria
+
+- [ ] TabLayout with ViewPager2 works correctly
+- [ ] Messages display in real-time as they arrive
+- [ ] Each message shows timestamp, person name, hex code, posture icon
+- [ ] Fall messages are visually highlighted (red)
+- [ ] Message count per person displayed in summary
+- [ ] Filter dropdown works to show only one person's messages
+- [ ] Auto-scroll toggle works
+- [ ] Smooth performance with 500+ messages (DiffUtil)
diff --git a/InnovaMotionApp/docs/tasks/06-live-posture-ui.md b/InnovaMotionApp/docs/tasks/06-live-posture-ui.md
index 8f9b526..79a05aa 100644
--- a/InnovaMotionApp/docs/tasks/06-live-posture-ui.md
+++ b/InnovaMotionApp/docs/tasks/06-live-posture-ui.md
@@ -1,320 +1,320 @@
-# TASK 6: Aggregator UI - Live Posture Viewer (Tab 2)
-
-**Assigned To:** UI/Android Developer  
-**Estimated Effort:** 2-3 days  
-**Dependencies:** Task 5 (shares Activity), Task 3 (Person Names)  
-**Status:** Pending
-
----
-
-## Context
-
-Select any monitored person from dropdown and see their current posture with animation. This is the second tab in the Aggregator Dashboard.
-
----
-
-## Deliverables
-
-### 1. Create `LivePostureFragment.java`
-
-```java
-public class LivePostureFragment extends Fragment {
-    private FragmentLivePostureBinding binding;
-    private LivePostureViewModel viewModel;
-    
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        binding = FragmentLivePostureBinding.inflate(inflater, container, false);
-        return binding.getRoot();
-    }
-    
-    @Override
-    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        
-        viewModel = new ViewModelProvider(this).get(LivePostureViewModel.class);
-        
-        setupPersonSelector();
-        observePosture();
-    }
-    
-    private void setupPersonSelector() {
-        // Observe available persons and populate spinner
-        viewModel.getAvailablePersons().observe(getViewLifecycleOwner(), persons -> {
-            ArrayAdapter<MonitoredPerson> adapter = new ArrayAdapter<>(
-                requireContext(),
-                android.R.layout.simple_spinner_item,
-                persons
-            );
-            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-            binding.personSpinner.setAdapter(adapter);
-        });
-        
-        // Handle selection changes
-        binding.personSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
-            @Override
-            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
-                MonitoredPerson selected = (MonitoredPerson) parent.getItemAtPosition(position);
-                viewModel.selectPerson(selected.getSensorId());
-            }
-            
-            @Override
-            public void onNothingSelected(AdapterView<?> parent) {
-                viewModel.selectPerson(null);
-            }
-        });
-    }
-    
-    private void observePosture() {
-        viewModel.getCurrentPosture().observe(getViewLifecycleOwner(), posture -> {
-            if (posture != null) {
-                displayPosture(posture);
-            } else {
-                showNoDataState();
-            }
-        });
-        
-        viewModel.getLastUpdateTime().observe(getViewLifecycleOwner(), timestamp -> {
-            if (timestamp != null) {
-                binding.lastUpdateText.setText(
-                    getString(R.string.last_update, formatTime(timestamp))
-                );
-            }
-        });
-        
-        viewModel.getSelectedPersonName().observe(getViewLifecycleOwner(), name -> {
-            binding.personNameText.setText(name);
-        });
-    }
-    
-    /**
-     * Display posture using existing logic from BtConnectedActivity
-     */
-    private void displayPosture(Posture posture) {
-        // Show posture description
-        String description = getString(posture.getTextCode(), 
-            viewModel.getSelectedPersonName().getValue());
-        binding.descriptionText.setText(description);
-        
-        // Show risk level
-        binding.riskText.setText(getString(posture.getRisc()));
-        
-        // Play posture animation/video
-        if (posture instanceof UnknownPosture) {
-            binding.videoView.stopPlayback();
-            binding.videoView.setVideoURI(null);
-        } else {
-            String videoPath = "android.resource://" + 
-                requireContext().getPackageName() + "/" + posture.getVideoCode();
-            binding.videoView.setVideoPath(videoPath);
-            binding.videoView.start();
-        }
-    }
-    
-    private void showNoDataState() {
-        binding.descriptionText.setText(R.string.no_data_available);
-        binding.riskText.setText("-");
-        binding.videoView.stopPlayback();
-    }
-}
-```
-
-### 2. Create `LivePostureViewModel.java`
-
-```java
-public class LivePostureViewModel extends AndroidViewModel {
-    private final ReceivedBtDataDao dao;
-    private final MonitoredPersonDao personDao;
-    private final PersonNameManager personNameManager;
-    
-    private final MutableLiveData<String> selectedSensorId = new MutableLiveData<>();
-    private final LiveData<Posture> currentPosture;
-    private final LiveData<Long> lastUpdateTime;
-    private final LiveData<String> selectedPersonName;
-    private final LiveData<List<MonitoredPerson>> availablePersons;
-    
-    public LivePostureViewModel(@NonNull Application application) {
-        super(application);
-        
-        InnovaDatabase db = InnovaDatabase.getInstance(application);
-        dao = db.receivedBtDataDao();
-        personDao = db.monitoredPersonDao();
-        personNameManager = PersonNameManager.getInstance(application);
-        
-        // Available persons for dropdown
-        availablePersons = personDao.getAllMonitoredPersons();
-        
-        // Current posture based on selected sensor
-        LiveData<ReceivedBtDataEntity> latestReading = Transformations.switchMap(
-            selectedSensorId, 
-            sensorId -> {
-                if (sensorId == null || sensorId.isEmpty()) {
-                    return new MutableLiveData<>(null);
-                }
-                return dao.getLatestForSensor(sensorId);
-            }
-        );
-        
-        // Transform reading to Posture
-        currentPosture = Transformations.map(latestReading, entity -> {
-            if (entity == null) return null;
-            return PostureFactory.createPosture(entity.getReceivedMsg());
-        });
-        
-        // Extract timestamp
-        lastUpdateTime = Transformations.map(latestReading, entity -> {
-            if (entity == null) return null;
-            return entity.getTimestamp();
-        });
-        
-        // Selected person name
-        selectedPersonName = Transformations.map(selectedSensorId, sensorId -> {
-            if (sensorId == null) return "";
-            return personNameManager.getDisplayName(sensorId);
-        });
-    }
-    
-    public void selectPerson(String sensorId) {
-        selectedSensorId.setValue(sensorId);
-    }
-    
-    public LiveData<List<MonitoredPerson>> getAvailablePersons() {
-        return availablePersons;
-    }
-    
-    public LiveData<Posture> getCurrentPosture() {
-        return currentPosture;
-    }
-    
-    public LiveData<Long> getLastUpdateTime() {
-        return lastUpdateTime;
-    }
-    
-    public LiveData<String> getSelectedPersonName() {
-        return selectedPersonName;
-    }
-}
-```
-
-### 3. Create layout `fragment_live_posture.xml`
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical"
-    android:padding="16dp">
-    
-    <!-- Person Selector -->
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="horizontal"
-        android:gravity="center_vertical">
-        
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="@string/select_person"
-            android:textStyle="bold" />
-        
-        <Spinner
-            android:id="@+id/personSpinner"
-            android:layout_width="0dp"
-            android:layout_weight="1"
-            android:layout_height="wrap_content"
-            android:layout_marginStart="8dp" />
-    </LinearLayout>
-    
-    <!-- Person Name (large display) -->
-    <TextView
-        android:id="@+id/personNameText"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:textSize="24sp"
-        android:textStyle="bold"
-        android:gravity="center"
-        android:layout_marginTop="16dp" />
-    
-    <!-- Posture Video/Animation -->
-    <VideoView
-        android:id="@+id/videoView"
-        android:layout_width="match_parent"
-        android:layout_height="0dp"
-        android:layout_weight="1"
-        android:layout_marginTop="16dp" />
-    
-    <!-- Posture Description -->
-    <TextView
-        android:id="@+id/descriptionText"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:textSize="18sp"
-        android:gravity="center"
-        android:layout_marginTop="16dp" />
-    
-    <!-- Risk Level -->
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="horizontal"
-        android:gravity="center"
-        android:layout_marginTop="8dp">
-        
-        <TextView
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="@string/risk_level" />
-        
-        <TextView
-            android:id="@+id/riskText"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginStart="8dp"
-            android:textStyle="bold" />
-    </LinearLayout>
-    
-    <!-- Last Update Time -->
-    <TextView
-        android:id="@+id/lastUpdateText"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:textSize="12sp"
-        android:gravity="center"
-        android:textColor="@android:color/darker_gray"
-        android:layout_marginTop="8dp" />
-        
-</LinearLayout>
-```
-
----
-
-## Reuse Existing Components
-
-Reference these files for posture display logic:
-
-- [`BtConnectedActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java) - `displayPostureData()` method
-- [`PostureFactory.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureFactory.java) - hex to Posture conversion
-- Existing video resources in `res/raw/`
-
----
-
-## Files to Create
-
-- `app/src/main/java/com/melisa/innovamotionapp/ui/fragments/LivePostureFragment.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/LivePostureViewModel.java`
-- `app/src/main/res/layout/fragment_live_posture.xml`
-
----
-
-## Acceptance Criteria
-
-- [ ] Person dropdown populated with all monitored persons
-- [ ] Selecting a person shows their latest posture
-- [ ] Posture animation/video plays correctly
-- [ ] Description and risk level displayed
-- [ ] Last update timestamp shown
-- [ ] Updates in real-time as new data arrives
-- [ ] Graceful handling when no data available
-- [ ] Reuses existing posture display logic (DRY)
+# TASK 6: Aggregator UI - Live Posture Viewer (Tab 2)
+
+**Assigned To:** UI/Android Developer  
+**Estimated Effort:** 2-3 days  
+**Dependencies:** Task 5 (shares Activity), Task 3 (Person Names)  
+**Status:** Pending
+
+---
+
+## Context
+
+Select any monitored person from dropdown and see their current posture with animation. This is the second tab in the Aggregator Dashboard.
+
+---
+
+## Deliverables
+
+### 1. Create `LivePostureFragment.java`
+
+```java
+public class LivePostureFragment extends Fragment {
+    private FragmentLivePostureBinding binding;
+    private LivePostureViewModel viewModel;
+    
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        binding = FragmentLivePostureBinding.inflate(inflater, container, false);
+        return binding.getRoot();
+    }
+    
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        
+        viewModel = new ViewModelProvider(this).get(LivePostureViewModel.class);
+        
+        setupPersonSelector();
+        observePosture();
+    }
+    
+    private void setupPersonSelector() {
+        // Observe available persons and populate spinner
+        viewModel.getAvailablePersons().observe(getViewLifecycleOwner(), persons -> {
+            ArrayAdapter<MonitoredPerson> adapter = new ArrayAdapter<>(
+                requireContext(),
+                android.R.layout.simple_spinner_item,
+                persons
+            );
+            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+            binding.personSpinner.setAdapter(adapter);
+        });
+        
+        // Handle selection changes
+        binding.personSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                MonitoredPerson selected = (MonitoredPerson) parent.getItemAtPosition(position);
+                viewModel.selectPerson(selected.getSensorId());
+            }
+            
+            @Override
+            public void onNothingSelected(AdapterView<?> parent) {
+                viewModel.selectPerson(null);
+            }
+        });
+    }
+    
+    private void observePosture() {
+        viewModel.getCurrentPosture().observe(getViewLifecycleOwner(), posture -> {
+            if (posture != null) {
+                displayPosture(posture);
+            } else {
+                showNoDataState();
+            }
+        });
+        
+        viewModel.getLastUpdateTime().observe(getViewLifecycleOwner(), timestamp -> {
+            if (timestamp != null) {
+                binding.lastUpdateText.setText(
+                    getString(R.string.last_update, formatTime(timestamp))
+                );
+            }
+        });
+        
+        viewModel.getSelectedPersonName().observe(getViewLifecycleOwner(), name -> {
+            binding.personNameText.setText(name);
+        });
+    }
+    
+    /**
+     * Display posture using existing logic from BtConnectedActivity
+     */
+    private void displayPosture(Posture posture) {
+        // Show posture description
+        String description = getString(posture.getTextCode(), 
+            viewModel.getSelectedPersonName().getValue());
+        binding.descriptionText.setText(description);
+        
+        // Show risk level
+        binding.riskText.setText(getString(posture.getRisc()));
+        
+        // Play posture animation/video
+        if (posture instanceof UnknownPosture) {
+            binding.videoView.stopPlayback();
+            binding.videoView.setVideoURI(null);
+        } else {
+            String videoPath = "android.resource://" + 
+                requireContext().getPackageName() + "/" + posture.getVideoCode();
+            binding.videoView.setVideoPath(videoPath);
+            binding.videoView.start();
+        }
+    }
+    
+    private void showNoDataState() {
+        binding.descriptionText.setText(R.string.no_data_available);
+        binding.riskText.setText("-");
+        binding.videoView.stopPlayback();
+    }
+}
+```
+
+### 2. Create `LivePostureViewModel.java`
+
+```java
+public class LivePostureViewModel extends AndroidViewModel {
+    private final ReceivedBtDataDao dao;
+    private final MonitoredPersonDao personDao;
+    private final PersonNameManager personNameManager;
+    
+    private final MutableLiveData<String> selectedSensorId = new MutableLiveData<>();
+    private final LiveData<Posture> currentPosture;
+    private final LiveData<Long> lastUpdateTime;
+    private final LiveData<String> selectedPersonName;
+    private final LiveData<List<MonitoredPerson>> availablePersons;
+    
+    public LivePostureViewModel(@NonNull Application application) {
+        super(application);
+        
+        InnovaDatabase db = InnovaDatabase.getInstance(application);
+        dao = db.receivedBtDataDao();
+        personDao = db.monitoredPersonDao();
+        personNameManager = PersonNameManager.getInstance(application);
+        
+        // Available persons for dropdown
+        availablePersons = personDao.getAllMonitoredPersons();
+        
+        // Current posture based on selected sensor
+        LiveData<ReceivedBtDataEntity> latestReading = Transformations.switchMap(
+            selectedSensorId, 
+            sensorId -> {
+                if (sensorId == null || sensorId.isEmpty()) {
+                    return new MutableLiveData<>(null);
+                }
+                return dao.getLatestForSensor(sensorId);
+            }
+        );
+        
+        // Transform reading to Posture
+        currentPosture = Transformations.map(latestReading, entity -> {
+            if (entity == null) return null;
+            return PostureFactory.createPosture(entity.getReceivedMsg());
+        });
+        
+        // Extract timestamp
+        lastUpdateTime = Transformations.map(latestReading, entity -> {
+            if (entity == null) return null;
+            return entity.getTimestamp();
+        });
+        
+        // Selected person name
+        selectedPersonName = Transformations.map(selectedSensorId, sensorId -> {
+            if (sensorId == null) return "";
+            return personNameManager.getDisplayName(sensorId);
+        });
+    }
+    
+    public void selectPerson(String sensorId) {
+        selectedSensorId.setValue(sensorId);
+    }
+    
+    public LiveData<List<MonitoredPerson>> getAvailablePersons() {
+        return availablePersons;
+    }
+    
+    public LiveData<Posture> getCurrentPosture() {
+        return currentPosture;
+    }
+    
+    public LiveData<Long> getLastUpdateTime() {
+        return lastUpdateTime;
+    }
+    
+    public LiveData<String> getSelectedPersonName() {
+        return selectedPersonName;
+    }
+}
+```
+
+### 3. Create layout `fragment_live_posture.xml`
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:padding="16dp">
+    
+    <!-- Person Selector -->
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:gravity="center_vertical">
+        
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/select_person"
+            android:textStyle="bold" />
+        
+        <Spinner
+            android:id="@+id/personSpinner"
+            android:layout_width="0dp"
+            android:layout_weight="1"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp" />
+    </LinearLayout>
+    
+    <!-- Person Name (large display) -->
+    <TextView
+        android:id="@+id/personNameText"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textSize="24sp"
+        android:textStyle="bold"
+        android:gravity="center"
+        android:layout_marginTop="16dp" />
+    
+    <!-- Posture Video/Animation -->
+    <VideoView
+        android:id="@+id/videoView"
+        android:layout_width="match_parent"
+        android:layout_height="0dp"
+        android:layout_weight="1"
+        android:layout_marginTop="16dp" />
+    
+    <!-- Posture Description -->
+    <TextView
+        android:id="@+id/descriptionText"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textSize="18sp"
+        android:gravity="center"
+        android:layout_marginTop="16dp" />
+    
+    <!-- Risk Level -->
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:gravity="center"
+        android:layout_marginTop="8dp">
+        
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/risk_level" />
+        
+        <TextView
+            android:id="@+id/riskText"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="8dp"
+            android:textStyle="bold" />
+    </LinearLayout>
+    
+    <!-- Last Update Time -->
+    <TextView
+        android:id="@+id/lastUpdateText"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textSize="12sp"
+        android:gravity="center"
+        android:textColor="@android:color/darker_gray"
+        android:layout_marginTop="8dp" />
+        
+</LinearLayout>
+```
+
+---
+
+## Reuse Existing Components
+
+Reference these files for posture display logic:
+
+- [`BtConnectedActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java) - `displayPostureData()` method
+- [`PostureFactory.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/posture/PostureFactory.java) - hex to Posture conversion
+- Existing video resources in `res/raw/`
+
+---
+
+## Files to Create
+
+- `app/src/main/java/com/melisa/innovamotionapp/ui/fragments/LivePostureFragment.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/LivePostureViewModel.java`
+- `app/src/main/res/layout/fragment_live_posture.xml`
+
+---
+
+## Acceptance Criteria
+
+- [ ] Person dropdown populated with all monitored persons
+- [ ] Selecting a person shows their latest posture
+- [ ] Posture animation/video plays correctly
+- [ ] Description and risk level displayed
+- [ ] Last update timestamp shown
+- [ ] Updates in real-time as new data arrives
+- [ ] Graceful handling when no data available
+- [ ] Reuses existing posture display logic (DRY)
diff --git a/InnovaMotionApp/docs/tasks/07-name-management-ui.md b/InnovaMotionApp/docs/tasks/07-name-management-ui.md
index fa8b960..14b11f9 100644
--- a/InnovaMotionApp/docs/tasks/07-name-management-ui.md
+++ b/InnovaMotionApp/docs/tasks/07-name-management-ui.md
@@ -1,390 +1,390 @@
-# TASK 7: Person Name Management UI
-
-**Assigned To:** UI Developer  
-**Estimated Effort:** 2 days  
-**Dependencies:** Task 3 (Person Name backend)  
-**Status:** Pending
-
----
-
-## Context
-
-Aggregator users need UI to assign friendly names to sensor IDs. Example: Map `sensor001` to "Ion Popescu".
-
----
-
-## Deliverables
-
-### 1. Create `PersonNamesActivity.java` or integrate into Settings
-
-```java
-public class PersonNamesActivity extends BaseActivity {
-    private ActivityPersonNamesBinding binding;
-    private PersonNamesViewModel viewModel;
-    private PersonNamesAdapter adapter;
-    
-    @Override
-    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
-        binding = ActivityPersonNamesBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-        
-        viewModel = new ViewModelProvider(this).get(PersonNamesViewModel.class);
-        
-        setupToolbar();
-        setupRecyclerView();
-        observeData();
-    }
-    
-    private void setupToolbar() {
-        setSupportActionBar(binding.toolbar);
-        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
-        getSupportActionBar().setTitle(R.string.manage_person_names);
-    }
-    
-    private void setupRecyclerView() {
-        adapter = new PersonNamesAdapter(person -> {
-            // Show edit dialog when row clicked
-            showEditDialog(person);
-        });
-        binding.recyclerView.setLayoutManager(new LinearLayoutManager(this));
-        binding.recyclerView.setAdapter(adapter);
-    }
-    
-    private void observeData() {
-        viewModel.getAllPersons().observe(this, persons -> {
-            adapter.submitList(persons);
-            
-            // Show empty state if no persons
-            binding.emptyState.setVisibility(
-                persons.isEmpty() ? View.VISIBLE : View.GONE
-            );
-        });
-    }
-    
-    private void showEditDialog(MonitoredPerson person) {
-        PersonNameEditDialog dialog = PersonNameEditDialog.newInstance(
-            person.getSensorId(),
-            person.getDisplayName()
-        );
-        dialog.setOnSaveListener((sensorId, newName) -> {
-            viewModel.updateDisplayName(sensorId, newName);
-        });
-        dialog.show(getSupportFragmentManager(), "edit_name");
-    }
-}
-```
-
-### 2. Create `PersonNameEditDialog.java`
-
-```java
-public class PersonNameEditDialog extends DialogFragment {
-    private static final String ARG_SENSOR_ID = "sensor_id";
-    private static final String ARG_CURRENT_NAME = "current_name";
-    
-    private DialogPersonNameEditBinding binding;
-    private OnSaveListener saveListener;
-    
-    public interface OnSaveListener {
-        void onSave(String sensorId, String newName);
-    }
-    
-    public static PersonNameEditDialog newInstance(String sensorId, String currentName) {
-        PersonNameEditDialog dialog = new PersonNameEditDialog();
-        Bundle args = new Bundle();
-        args.putString(ARG_SENSOR_ID, sensorId);
-        args.putString(ARG_CURRENT_NAME, currentName);
-        dialog.setArguments(args);
-        return dialog;
-    }
-    
-    public void setOnSaveListener(OnSaveListener listener) {
-        this.saveListener = listener;
-    }
-    
-    @NonNull
-    @Override
-    public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {
-        binding = DialogPersonNameEditBinding.inflate(getLayoutInflater());
-        
-        String sensorId = getArguments().getString(ARG_SENSOR_ID);
-        String currentName = getArguments().getString(ARG_CURRENT_NAME);
-        
-        binding.sensorIdText.setText(sensorId);
-        binding.nameInput.setText(currentName);
-        binding.nameInput.setSelection(currentName.length()); // Cursor at end
-        
-        return new MaterialAlertDialogBuilder(requireContext())
-            .setTitle(R.string.edit_person_name)
-            .setView(binding.getRoot())
-            .setPositiveButton(R.string.save, (dialog, which) -> {
-                String newName = binding.nameInput.getText().toString().trim();
-                if (!newName.isEmpty() && saveListener != null) {
-                    saveListener.onSave(sensorId, newName);
-                }
-            })
-            .setNegativeButton(R.string.cancel, null)
-            .create();
-    }
-}
-```
-
-### 3. Create `PersonNamesAdapter.java`
-
-```java
-public class PersonNamesAdapter extends ListAdapter<MonitoredPerson, PersonNamesAdapter.ViewHolder> {
-    
-    private final OnItemClickListener clickListener;
-    
-    public interface OnItemClickListener {
-        void onClick(MonitoredPerson person);
-    }
-    
-    public PersonNamesAdapter(OnItemClickListener listener) {
-        super(new DiffCallback());
-        this.clickListener = listener;
-    }
-    
-    @NonNull
-    @Override
-    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
-        ItemPersonNameBinding binding = ItemPersonNameBinding.inflate(
-            LayoutInflater.from(parent.getContext()), parent, false);
-        return new ViewHolder(binding);
-    }
-    
-    @Override
-    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
-        holder.bind(getItem(position), clickListener);
-    }
-    
-    static class ViewHolder extends RecyclerView.ViewHolder {
-        private final ItemPersonNameBinding binding;
-        
-        ViewHolder(ItemPersonNameBinding binding) {
-            super(binding.getRoot());
-            this.binding = binding;
-        }
-        
-        void bind(MonitoredPerson person, OnItemClickListener listener) {
-            binding.displayNameText.setText(person.getDisplayName());
-            binding.sensorIdText.setText(person.getSensorId());
-            
-            binding.editButton.setOnClickListener(v -> listener.onClick(person));
-            binding.getRoot().setOnClickListener(v -> listener.onClick(person));
-        }
-    }
-    
-    static class DiffCallback extends DiffUtil.ItemCallback<MonitoredPerson> {
-        @Override
-        public boolean areItemsTheSame(@NonNull MonitoredPerson oldItem, @NonNull MonitoredPerson newItem) {
-            return oldItem.getSensorId().equals(newItem.getSensorId());
-        }
-        
-        @Override
-        public boolean areContentsTheSame(@NonNull MonitoredPerson oldItem, @NonNull MonitoredPerson newItem) {
-            return oldItem.getDisplayName().equals(newItem.getDisplayName());
-        }
-    }
-}
-```
-
-### 4. Create `PersonNamesViewModel.java`
-
-```java
-public class PersonNamesViewModel extends AndroidViewModel {
-    private final PersonNameManager personNameManager;
-    private final LiveData<List<MonitoredPerson>> allPersons;
-    
-    public PersonNamesViewModel(@NonNull Application application) {
-        super(application);
-        personNameManager = PersonNameManager.getInstance(application);
-        allPersons = personNameManager.getAllPersonsLive();
-    }
-    
-    public LiveData<List<MonitoredPerson>> getAllPersons() {
-        return allPersons;
-    }
-    
-    public void updateDisplayName(String sensorId, String newName) {
-        personNameManager.setDisplayName(sensorId, newName);
-    }
-}
-```
-
-### 5. Create layouts
-
-**`activity_person_names.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical">
-    
-    <com.google.android.material.appbar.MaterialToolbar
-        android:id="@+id/toolbar"
-        android:layout_width="match_parent"
-        android:layout_height="?attr/actionBarSize" />
-    
-    <FrameLayout
-        android:layout_width="match_parent"
-        android:layout_height="match_parent">
-        
-        <androidx.recyclerview.widget.RecyclerView
-            android:id="@+id/recyclerView"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent" />
-        
-        <!-- Empty State -->
-        <LinearLayout
-            android:id="@+id/emptyState"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center"
-            android:orientation="vertical"
-            android:gravity="center"
-            android:visibility="gone">
-            
-            <ImageView
-                android:layout_width="80dp"
-                android:layout_height="80dp"
-                android:src="@drawable/ic_people"
-                android:tint="@android:color/darker_gray" />
-            
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="@string/no_monitored_persons"
-                android:layout_marginTop="16dp" />
-                
-        </LinearLayout>
-    </FrameLayout>
-</LinearLayout>
-```
-
-**`item_person_name.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:orientation="horizontal"
-    android:padding="16dp"
-    android:gravity="center_vertical"
-    android:background="?attr/selectableItemBackground">
-    
-    <LinearLayout
-        android:layout_width="0dp"
-        android:layout_weight="1"
-        android:layout_height="wrap_content"
-        android:orientation="vertical">
-        
-        <TextView
-            android:id="@+id/displayNameText"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:textSize="16sp"
-            android:textStyle="bold" />
-        
-        <TextView
-            android:id="@+id/sensorIdText"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:textSize="12sp"
-            android:textColor="@android:color/darker_gray" />
-    </LinearLayout>
-    
-    <ImageButton
-        android:id="@+id/editButton"
-        android:layout_width="48dp"
-        android:layout_height="48dp"
-        android:src="@drawable/ic_edit"
-        android:background="?attr/selectableItemBackgroundBorderless"
-        android:contentDescription="@string/edit" />
-        
-</LinearLayout>
-```
-
-**`dialog_person_name_edit.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:orientation="vertical"
-    android:padding="24dp">
-    
-    <TextView
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:text="@string/sensor_id_label"
-        android:textSize="12sp" />
-    
-    <TextView
-        android:id="@+id/sensorIdText"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:textSize="14sp"
-        android:fontFamily="monospace"
-        android:layout_marginBottom="16dp" />
-    
-    <com.google.android.material.textfield.TextInputLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content">
-        
-        <com.google.android.material.textfield.TextInputEditText
-            android:id="@+id/nameInput"
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:hint="@string/display_name_hint"
-            android:inputType="textPersonName"
-            android:maxLength="50" />
-            
-    </com.google.android.material.textfield.TextInputLayout>
-</LinearLayout>
-```
-
-### 6. Add navigation entry
-
-In `AggregatorDashboardActivity`, add menu or button:
-
-```java
-@Override
-public boolean onCreateOptionsMenu(Menu menu) {
-    getMenuInflater().inflate(R.menu.aggregator_dashboard_menu, menu);
-    return true;
-}
-
-@Override
-public boolean onOptionsItemSelected(@NonNull MenuItem item) {
-    if (item.getItemId() == R.id.action_manage_names) {
-        startActivity(new Intent(this, PersonNamesActivity.class));
-        return true;
-    }
-    return super.onOptionsItemSelected(item);
-}
-```
-
----
-
-## Files to Create
-
-- `app/src/main/java/com/melisa/innovamotionapp/activities/PersonNamesActivity.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/dialogs/PersonNameEditDialog.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonNamesAdapter.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModel.java`
-- `app/src/main/res/layout/activity_person_names.xml`
-- `app/src/main/res/layout/item_person_name.xml`
-- `app/src/main/res/layout/dialog_person_name_edit.xml`
-- `app/src/main/res/menu/aggregator_dashboard_menu.xml`
-
----
-
-## Acceptance Criteria
-
-- [ ] List displays all known sensor IDs with their display names
-- [ ] Tap or edit button opens dialog to change name
-- [ ] Changes are saved immediately and reflected in list
-- [ ] Empty state shown when no persons are registered
-- [ ] Names are synced to cloud (via PersonNamesFirestoreSync from Task 3)
-- [ ] Navigation accessible from Aggregator Dashboard
+# TASK 7: Person Name Management UI
+
+**Assigned To:** UI Developer  
+**Estimated Effort:** 2 days  
+**Dependencies:** Task 3 (Person Name backend)  
+**Status:** Pending
+
+---
+
+## Context
+
+Aggregator users need UI to assign friendly names to sensor IDs. Example: Map `sensor001` to "Ion Popescu".
+
+---
+
+## Deliverables
+
+### 1. Create `PersonNamesActivity.java` or integrate into Settings
+
+```java
+public class PersonNamesActivity extends BaseActivity {
+    private ActivityPersonNamesBinding binding;
+    private PersonNamesViewModel viewModel;
+    private PersonNamesAdapter adapter;
+    
+    @Override
+    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
+        binding = ActivityPersonNamesBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+        
+        viewModel = new ViewModelProvider(this).get(PersonNamesViewModel.class);
+        
+        setupToolbar();
+        setupRecyclerView();
+        observeData();
+    }
+    
+    private void setupToolbar() {
+        setSupportActionBar(binding.toolbar);
+        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
+        getSupportActionBar().setTitle(R.string.manage_person_names);
+    }
+    
+    private void setupRecyclerView() {
+        adapter = new PersonNamesAdapter(person -> {
+            // Show edit dialog when row clicked
+            showEditDialog(person);
+        });
+        binding.recyclerView.setLayoutManager(new LinearLayoutManager(this));
+        binding.recyclerView.setAdapter(adapter);
+    }
+    
+    private void observeData() {
+        viewModel.getAllPersons().observe(this, persons -> {
+            adapter.submitList(persons);
+            
+            // Show empty state if no persons
+            binding.emptyState.setVisibility(
+                persons.isEmpty() ? View.VISIBLE : View.GONE
+            );
+        });
+    }
+    
+    private void showEditDialog(MonitoredPerson person) {
+        PersonNameEditDialog dialog = PersonNameEditDialog.newInstance(
+            person.getSensorId(),
+            person.getDisplayName()
+        );
+        dialog.setOnSaveListener((sensorId, newName) -> {
+            viewModel.updateDisplayName(sensorId, newName);
+        });
+        dialog.show(getSupportFragmentManager(), "edit_name");
+    }
+}
+```
+
+### 2. Create `PersonNameEditDialog.java`
+
+```java
+public class PersonNameEditDialog extends DialogFragment {
+    private static final String ARG_SENSOR_ID = "sensor_id";
+    private static final String ARG_CURRENT_NAME = "current_name";
+    
+    private DialogPersonNameEditBinding binding;
+    private OnSaveListener saveListener;
+    
+    public interface OnSaveListener {
+        void onSave(String sensorId, String newName);
+    }
+    
+    public static PersonNameEditDialog newInstance(String sensorId, String currentName) {
+        PersonNameEditDialog dialog = new PersonNameEditDialog();
+        Bundle args = new Bundle();
+        args.putString(ARG_SENSOR_ID, sensorId);
+        args.putString(ARG_CURRENT_NAME, currentName);
+        dialog.setArguments(args);
+        return dialog;
+    }
+    
+    public void setOnSaveListener(OnSaveListener listener) {
+        this.saveListener = listener;
+    }
+    
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(@Nullable Bundle savedInstanceState) {
+        binding = DialogPersonNameEditBinding.inflate(getLayoutInflater());
+        
+        String sensorId = getArguments().getString(ARG_SENSOR_ID);
+        String currentName = getArguments().getString(ARG_CURRENT_NAME);
+        
+        binding.sensorIdText.setText(sensorId);
+        binding.nameInput.setText(currentName);
+        binding.nameInput.setSelection(currentName.length()); // Cursor at end
+        
+        return new MaterialAlertDialogBuilder(requireContext())
+            .setTitle(R.string.edit_person_name)
+            .setView(binding.getRoot())
+            .setPositiveButton(R.string.save, (dialog, which) -> {
+                String newName = binding.nameInput.getText().toString().trim();
+                if (!newName.isEmpty() && saveListener != null) {
+                    saveListener.onSave(sensorId, newName);
+                }
+            })
+            .setNegativeButton(R.string.cancel, null)
+            .create();
+    }
+}
+```
+
+### 3. Create `PersonNamesAdapter.java`
+
+```java
+public class PersonNamesAdapter extends ListAdapter<MonitoredPerson, PersonNamesAdapter.ViewHolder> {
+    
+    private final OnItemClickListener clickListener;
+    
+    public interface OnItemClickListener {
+        void onClick(MonitoredPerson person);
+    }
+    
+    public PersonNamesAdapter(OnItemClickListener listener) {
+        super(new DiffCallback());
+        this.clickListener = listener;
+    }
+    
+    @NonNull
+    @Override
+    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        ItemPersonNameBinding binding = ItemPersonNameBinding.inflate(
+            LayoutInflater.from(parent.getContext()), parent, false);
+        return new ViewHolder(binding);
+    }
+    
+    @Override
+    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
+        holder.bind(getItem(position), clickListener);
+    }
+    
+    static class ViewHolder extends RecyclerView.ViewHolder {
+        private final ItemPersonNameBinding binding;
+        
+        ViewHolder(ItemPersonNameBinding binding) {
+            super(binding.getRoot());
+            this.binding = binding;
+        }
+        
+        void bind(MonitoredPerson person, OnItemClickListener listener) {
+            binding.displayNameText.setText(person.getDisplayName());
+            binding.sensorIdText.setText(person.getSensorId());
+            
+            binding.editButton.setOnClickListener(v -> listener.onClick(person));
+            binding.getRoot().setOnClickListener(v -> listener.onClick(person));
+        }
+    }
+    
+    static class DiffCallback extends DiffUtil.ItemCallback<MonitoredPerson> {
+        @Override
+        public boolean areItemsTheSame(@NonNull MonitoredPerson oldItem, @NonNull MonitoredPerson newItem) {
+            return oldItem.getSensorId().equals(newItem.getSensorId());
+        }
+        
+        @Override
+        public boolean areContentsTheSame(@NonNull MonitoredPerson oldItem, @NonNull MonitoredPerson newItem) {
+            return oldItem.getDisplayName().equals(newItem.getDisplayName());
+        }
+    }
+}
+```
+
+### 4. Create `PersonNamesViewModel.java`
+
+```java
+public class PersonNamesViewModel extends AndroidViewModel {
+    private final PersonNameManager personNameManager;
+    private final LiveData<List<MonitoredPerson>> allPersons;
+    
+    public PersonNamesViewModel(@NonNull Application application) {
+        super(application);
+        personNameManager = PersonNameManager.getInstance(application);
+        allPersons = personNameManager.getAllPersonsLive();
+    }
+    
+    public LiveData<List<MonitoredPerson>> getAllPersons() {
+        return allPersons;
+    }
+    
+    public void updateDisplayName(String sensorId, String newName) {
+        personNameManager.setDisplayName(sensorId, newName);
+    }
+}
+```
+
+### 5. Create layouts
+
+**`activity_person_names.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical">
+    
+    <com.google.android.material.appbar.MaterialToolbar
+        android:id="@+id/toolbar"
+        android:layout_width="match_parent"
+        android:layout_height="?attr/actionBarSize" />
+    
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+        
+        <androidx.recyclerview.widget.RecyclerView
+            android:id="@+id/recyclerView"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent" />
+        
+        <!-- Empty State -->
+        <LinearLayout
+            android:id="@+id/emptyState"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:orientation="vertical"
+            android:gravity="center"
+            android:visibility="gone">
+            
+            <ImageView
+                android:layout_width="80dp"
+                android:layout_height="80dp"
+                android:src="@drawable/ic_people"
+                android:tint="@android:color/darker_gray" />
+            
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/no_monitored_persons"
+                android:layout_marginTop="16dp" />
+                
+        </LinearLayout>
+    </FrameLayout>
+</LinearLayout>
+```
+
+**`item_person_name.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="horizontal"
+    android:padding="16dp"
+    android:gravity="center_vertical"
+    android:background="?attr/selectableItemBackground">
+    
+    <LinearLayout
+        android:layout_width="0dp"
+        android:layout_weight="1"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+        
+        <TextView
+            android:id="@+id/displayNameText"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="16sp"
+            android:textStyle="bold" />
+        
+        <TextView
+            android:id="@+id/sensorIdText"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textSize="12sp"
+            android:textColor="@android:color/darker_gray" />
+    </LinearLayout>
+    
+    <ImageButton
+        android:id="@+id/editButton"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
+        android:src="@drawable/ic_edit"
+        android:background="?attr/selectableItemBackgroundBorderless"
+        android:contentDescription="@string/edit" />
+        
+</LinearLayout>
+```
+
+**`dialog_person_name_edit.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:orientation="vertical"
+    android:padding="24dp">
+    
+    <TextView
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="@string/sensor_id_label"
+        android:textSize="12sp" />
+    
+    <TextView
+        android:id="@+id/sensorIdText"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textSize="14sp"
+        android:fontFamily="monospace"
+        android:layout_marginBottom="16dp" />
+    
+    <com.google.android.material.textfield.TextInputLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        
+        <com.google.android.material.textfield.TextInputEditText
+            android:id="@+id/nameInput"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:hint="@string/display_name_hint"
+            android:inputType="textPersonName"
+            android:maxLength="50" />
+            
+    </com.google.android.material.textfield.TextInputLayout>
+</LinearLayout>
+```
+
+### 6. Add navigation entry
+
+In `AggregatorDashboardActivity`, add menu or button:
+
+```java
+@Override
+public boolean onCreateOptionsMenu(Menu menu) {
+    getMenuInflater().inflate(R.menu.aggregator_dashboard_menu, menu);
+    return true;
+}
+
+@Override
+public boolean onOptionsItemSelected(@NonNull MenuItem item) {
+    if (item.getItemId() == R.id.action_manage_names) {
+        startActivity(new Intent(this, PersonNamesActivity.class));
+        return true;
+    }
+    return super.onOptionsItemSelected(item);
+}
+```
+
+---
+
+## Files to Create
+
+- `app/src/main/java/com/melisa/innovamotionapp/activities/PersonNamesActivity.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/dialogs/PersonNameEditDialog.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonNamesAdapter.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/PersonNamesViewModel.java`
+- `app/src/main/res/layout/activity_person_names.xml`
+- `app/src/main/res/layout/item_person_name.xml`
+- `app/src/main/res/layout/dialog_person_name_edit.xml`
+- `app/src/main/res/menu/aggregator_dashboard_menu.xml`
+
+---
+
+## Acceptance Criteria
+
+- [ ] List displays all known sensor IDs with their display names
+- [ ] Tap or edit button opens dialog to change name
+- [ ] Changes are saved immediately and reflected in list
+- [ ] Empty state shown when no persons are registered
+- [ ] Names are synced to cloud (via PersonNamesFirestoreSync from Task 3)
+- [ ] Navigation accessible from Aggregator Dashboard
diff --git a/InnovaMotionApp/docs/tasks/08-supervisor-dashboard.md b/InnovaMotionApp/docs/tasks/08-supervisor-dashboard.md
index 89b9ed3..f37b0f1 100644
--- a/InnovaMotionApp/docs/tasks/08-supervisor-dashboard.md
+++ b/InnovaMotionApp/docs/tasks/08-supervisor-dashboard.md
@@ -1,465 +1,465 @@
-# TASK 8: Supervisor Multi-Person Dashboard
-
-**Assigned To:** UI Developer  
-**Estimated Effort:** 3-4 days  
-**Dependencies:** Task 2 (Data Model), Task 3 (Person Names sync)  
-**Status:** Pending
-
----
-
-## Context
-
-Supervisors currently see one person. New dashboard shows ALL monitored persons at once with real-time status.
-
----
-
-## Deliverables
-
-### 1. Create `SupervisorDashboardActivity.java` in `activities/`
-
-```java
-public class SupervisorDashboardActivity extends BaseActivity {
-    private ActivitySupervisorDashboardBinding binding;
-    private SupervisorDashboardViewModel viewModel;
-    private PersonCardAdapter adapter;
-    
-    @Override
-    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
-        binding = ActivitySupervisorDashboardBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-        
-        viewModel = new ViewModelProvider(this).get(SupervisorDashboardViewModel.class);
-        
-        setupToolbar();
-        setupRecyclerView();
-        setupSwipeRefresh();
-        observeData();
-    }
-    
-    private void setupToolbar() {
-        setSupportActionBar(binding.toolbar);
-        getSupportActionBar().setTitle(R.string.supervisor_dashboard);
-    }
-    
-    private void setupRecyclerView() {
-        adapter = new PersonCardAdapter(personStatus -> {
-            // Navigate to detail view
-            Intent intent = new Intent(this, BtConnectedActivity.class);
-            intent.putExtra(BtConnectedActivity.EXTRA_SENSOR_ID, personStatus.getSensorId());
-            intent.putExtra(BtConnectedActivity.EXTRA_PERSON_NAME, personStatus.getDisplayName());
-            startActivity(intent);
-        });
-        
-        // Grid layout for cards (2 columns on phones, 3 on tablets)
-        int spanCount = getResources().getInteger(R.integer.dashboard_span_count);
-        binding.recyclerView.setLayoutManager(new GridLayoutManager(this, spanCount));
-        binding.recyclerView.setAdapter(adapter);
-    }
-    
-    private void setupSwipeRefresh() {
-        binding.swipeRefresh.setOnRefreshListener(() -> {
-            viewModel.refreshData();
-        });
-    }
-    
-    private void observeData() {
-        viewModel.getPersonStatuses().observe(this, statuses -> {
-            adapter.submitList(statuses);
-            binding.swipeRefresh.setRefreshing(false);
-            
-            // Show empty state
-            binding.emptyState.setVisibility(
-                statuses.isEmpty() ? View.VISIBLE : View.GONE
-            );
-        });
-        
-        viewModel.getIsLoading().observe(this, isLoading -> {
-            binding.progressBar.setVisibility(isLoading ? View.VISIBLE : View.GONE);
-        });
-    }
-}
-```
-
-### 2. Create `PersonCardAdapter.java` in `ui/adapters/`
-
-```java
-public class PersonCardAdapter extends ListAdapter<PersonStatus, PersonCardAdapter.ViewHolder> {
-    
-    private static final long STALE_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes
-    
-    private final OnPersonClickListener clickListener;
-    
-    public interface OnPersonClickListener {
-        void onClick(PersonStatus person);
-    }
-    
-    public PersonCardAdapter(OnPersonClickListener listener) {
-        super(new DiffCallback());
-        this.clickListener = listener;
-    }
-    
-    @NonNull
-    @Override
-    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
-        ItemPersonCardBinding binding = ItemPersonCardBinding.inflate(
-            LayoutInflater.from(parent.getContext()), parent, false);
-        return new ViewHolder(binding);
-    }
-    
-    @Override
-    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
-        holder.bind(getItem(position), clickListener);
-    }
-    
-    class ViewHolder extends RecyclerView.ViewHolder {
-        private final ItemPersonCardBinding binding;
-        
-        ViewHolder(ItemPersonCardBinding binding) {
-            super(binding.getRoot());
-            this.binding = binding;
-        }
-        
-        void bind(PersonStatus person, OnPersonClickListener listener) {
-            Context ctx = itemView.getContext();
-            
-            // Person name
-            binding.personNameText.setText(person.getDisplayName());
-            
-            // Posture icon
-            binding.postureIcon.setImageResource(person.getPostureIconRes());
-            
-            // Last update time
-            String timeAgo = formatTimeAgo(person.getLastUpdateTime());
-            binding.lastUpdateText.setText(timeAgo);
-            
-            // Status indicator color
-            int statusColor;
-            if (person.isAlert()) {
-                // Red for falls
-                statusColor = ContextCompat.getColor(ctx, R.color.status_alert);
-                binding.alertBadge.setVisibility(View.VISIBLE);
-            } else if (isStale(person.getLastUpdateTime())) {
-                // Yellow for stale data
-                statusColor = ContextCompat.getColor(ctx, R.color.status_stale);
-                binding.alertBadge.setVisibility(View.GONE);
-            } else {
-                // Green for active
-                statusColor = ContextCompat.getColor(ctx, R.color.status_active);
-                binding.alertBadge.setVisibility(View.GONE);
-            }
-            binding.statusIndicator.setBackgroundColor(statusColor);
-            
-            // Click handler
-            binding.cardView.setOnClickListener(v -> listener.onClick(person));
-        }
-        
-        private boolean isStale(long timestamp) {
-            return System.currentTimeMillis() - timestamp > STALE_THRESHOLD_MS;
-        }
-        
-        private String formatTimeAgo(long timestamp) {
-            long diff = System.currentTimeMillis() - timestamp;
-            if (diff < 60_000) return "Just now";
-            if (diff < 3600_000) return (diff / 60_000) + "m ago";
-            if (diff < 86400_000) return (diff / 3600_000) + "h ago";
-            return (diff / 86400_000) + "d ago";
-        }
-    }
-    
-    static class DiffCallback extends DiffUtil.ItemCallback<PersonStatus> {
-        @Override
-        public boolean areItemsTheSame(@NonNull PersonStatus oldItem, @NonNull PersonStatus newItem) {
-            return oldItem.getSensorId().equals(newItem.getSensorId());
-        }
-        
-        @Override
-        public boolean areContentsTheSame(@NonNull PersonStatus oldItem, @NonNull PersonStatus newItem) {
-            return oldItem.equals(newItem);
-        }
-    }
-}
-```
-
-### 3. Create `PersonStatus.java` model
-
-```java
-public class PersonStatus {
-    private final String sensorId;
-    private final String displayName;
-    private final Posture currentPosture;
-    private final long lastUpdateTime;
-    private final boolean isAlert;
-    
-    // Constructor, getters, equals, hashCode
-    
-    public int getPostureIconRes() {
-        return currentPosture.getPictureCode();
-    }
-}
-```
-
-### 4. Create `SupervisorDashboardViewModel.java`
-
-```java
-public class SupervisorDashboardViewModel extends AndroidViewModel {
-    private final ReceivedBtDataDao dao;
-    private final PersonNameManager personNameManager;
-    private final MutableLiveData<Boolean> isLoading = new MutableLiveData<>(false);
-    
-    private final LiveData<List<PersonStatus>> personStatuses;
-    
-    public SupervisorDashboardViewModel(@NonNull Application application) {
-        super(application);
-        
-        dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
-        personNameManager = PersonNameManager.getInstance(application);
-        
-        // Get latest reading for each sensor
-        LiveData<List<ReceivedBtDataEntity>> latestPerSensor = dao.getLatestForEachSensor();
-        
-        // Transform to PersonStatus with display names
-        personStatuses = Transformations.map(latestPerSensor, entities -> {
-            List<PersonStatus> statuses = new ArrayList<>();
-            for (ReceivedBtDataEntity entity : entities) {
-                String sensorId = entity.getSensorId();
-                if (sensorId == null) continue;
-                
-                String displayName = personNameManager.getDisplayName(sensorId);
-                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
-                boolean isAlert = posture instanceof FallingPosture;
-                
-                statuses.add(new PersonStatus(
-                    sensorId,
-                    displayName,
-                    posture,
-                    entity.getTimestamp(),
-                    isAlert
-                ));
-            }
-            
-            // Sort: alerts first, then by name
-            Collections.sort(statuses, (a, b) -> {
-                if (a.isAlert() != b.isAlert()) {
-                    return a.isAlert() ? -1 : 1;
-                }
-                return a.getDisplayName().compareToIgnoreCase(b.getDisplayName());
-            });
-            
-            return statuses;
-        });
-    }
-    
-    public LiveData<List<PersonStatus>> getPersonStatuses() {
-        return personStatuses;
-    }
-    
-    public LiveData<Boolean> getIsLoading() {
-        return isLoading;
-    }
-    
-    public void refreshData() {
-        // Trigger Firestore sync refresh
-        isLoading.setValue(true);
-        // ... sync logic ...
-        isLoading.setValue(false);
-    }
-}
-```
-
-### 5. Create layouts
-
-**`activity_supervisor_dashboard.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.coordinatorlayout.widget.CoordinatorLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent">
-    
-    <com.google.android.material.appbar.AppBarLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content">
-        
-        <com.google.android.material.appbar.MaterialToolbar
-            android:id="@+id/toolbar"
-            android:layout_width="match_parent"
-            android:layout_height="?attr/actionBarSize" />
-    </com.google.android.material.appbar.AppBarLayout>
-    
-    <FrameLayout
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        app:layout_behavior="@string/appbar_scrolling_view_behavior">
-        
-        <androidx.swiperefreshlayout.widget.SwipeRefreshLayout
-            android:id="@+id/swipeRefresh"
-            android:layout_width="match_parent"
-            android:layout_height="match_parent">
-            
-            <androidx.recyclerview.widget.RecyclerView
-                android:id="@+id/recyclerView"
-                android:layout_width="match_parent"
-                android:layout_height="match_parent"
-                android:padding="8dp"
-                android:clipToPadding="false" />
-        </androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
-        
-        <!-- Empty State -->
-        <LinearLayout
-            android:id="@+id/emptyState"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center"
-            android:orientation="vertical"
-            android:gravity="center"
-            android:visibility="gone">
-            
-            <ImageView
-                android:layout_width="100dp"
-                android:layout_height="100dp"
-                android:src="@drawable/ic_people_outline" />
-            
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:text="@string/no_monitored_persons_supervisor"
-                android:layout_marginTop="16dp" />
-        </LinearLayout>
-        
-        <ProgressBar
-            android:id="@+id/progressBar"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center"
-            android:visibility="gone" />
-    </FrameLayout>
-</androidx.coordinatorlayout.widget.CoordinatorLayout>
-```
-
-**`item_person_card.xml`**
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<com.google.android.material.card.MaterialCardView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/cardView"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:layout_margin="4dp"
-    app:cardElevation="4dp">
-    
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:orientation="vertical">
-        
-        <!-- Status indicator bar at top -->
-        <View
-            android:id="@+id/statusIndicator"
-            android:layout_width="match_parent"
-            android:layout_height="4dp" />
-        
-        <FrameLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:padding="12dp">
-            
-            <LinearLayout
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:orientation="vertical"
-                android:gravity="center">
-                
-                <!-- Posture Icon -->
-                <ImageView
-                    android:id="@+id/postureIcon"
-                    android:layout_width="60dp"
-                    android:layout_height="60dp" />
-                
-                <!-- Person Name -->
-                <TextView
-                    android:id="@+id/personNameText"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:textSize="14sp"
-                    android:textStyle="bold"
-                    android:gravity="center"
-                    android:maxLines="2"
-                    android:ellipsize="end"
-                    android:layout_marginTop="8dp" />
-                
-                <!-- Last Update -->
-                <TextView
-                    android:id="@+id/lastUpdateText"
-                    android:layout_width="wrap_content"
-                    android:layout_height="wrap_content"
-                    android:textSize="11sp"
-                    android:textColor="@android:color/darker_gray"
-                    android:layout_marginTop="4dp" />
-            </LinearLayout>
-            
-            <!-- Alert Badge (for falls) -->
-            <ImageView
-                android:id="@+id/alertBadge"
-                android:layout_width="24dp"
-                android:layout_height="24dp"
-                android:layout_gravity="top|end"
-                android:src="@drawable/ic_warning"
-                android:visibility="gone" />
-        </FrameLayout>
-    </LinearLayout>
-</com.google.android.material.card.MaterialCardView>
-```
-
-### 6. Update navigation in `MainActivity.java`
-
-```java
-public void LaunchMonitoring(View view) {
-    SessionGate.getInstance(this).waitForSessionReady(new SessionGate.SessionReadyCallback() {
-        @Override
-        public void onSessionReady(String userId, String role, List<String> supervisedUserIds) {
-            runOnUiThread(() -> {
-                if ("supervisor".equals(role)) {
-                    // NEW: Route to multi-person dashboard
-                    Intent intent = new Intent(MainActivity.this, SupervisorDashboardActivity.class);
-                    startActivity(intent);
-                } else {
-                    // Aggregator: go to aggregator dashboard
-                    Intent intent = new Intent(MainActivity.this, AggregatorDashboardActivity.class);
-                    startActivity(intent);
-                }
-            });
-        }
-        // ...
-    });
-}
-```
-
----
-
-## Files to Create
-
-- `app/src/main/java/com/melisa/innovamotionapp/activities/SupervisorDashboardActivity.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonCardAdapter.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/models/PersonStatus.java`
-- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorDashboardViewModel.java`
-- `app/src/main/res/layout/activity_supervisor_dashboard.xml`
-- `app/src/main/res/layout/item_person_card.xml`
-- `app/src/main/res/values/integers.xml` (for dashboard_span_count)
-
-## Files to Modify
-
-- [`MainActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/MainActivity.java) - update `LaunchMonitoring()` routing
-
----
-
-## Acceptance Criteria
-
-- [ ] Grid of cards showing all monitored persons
-- [ ] Each card shows: name, posture icon, last update time
-- [ ] Status colors: green (active), yellow (stale > 5min), red (alert/fall)
-- [ ] Alert badge visible for fall postures
-- [ ] Tap card navigates to detail view (Task 9)
-- [ ] Swipe-to-refresh triggers data sync
-- [ ] Empty state when no persons
-- [ ] Real-time updates as new data arrives
-- [ ] Supervisors routed here from MainActivity
+# TASK 8: Supervisor Multi-Person Dashboard
+
+**Assigned To:** UI Developer  
+**Estimated Effort:** 3-4 days  
+**Dependencies:** Task 2 (Data Model), Task 3 (Person Names sync)  
+**Status:** Pending
+
+---
+
+## Context
+
+Supervisors currently see one person. New dashboard shows ALL monitored persons at once with real-time status.
+
+---
+
+## Deliverables
+
+### 1. Create `SupervisorDashboardActivity.java` in `activities/`
+
+```java
+public class SupervisorDashboardActivity extends BaseActivity {
+    private ActivitySupervisorDashboardBinding binding;
+    private SupervisorDashboardViewModel viewModel;
+    private PersonCardAdapter adapter;
+    
+    @Override
+    protected void onBaseCreate(@Nullable Bundle savedInstanceState) {
+        binding = ActivitySupervisorDashboardBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+        
+        viewModel = new ViewModelProvider(this).get(SupervisorDashboardViewModel.class);
+        
+        setupToolbar();
+        setupRecyclerView();
+        setupSwipeRefresh();
+        observeData();
+    }
+    
+    private void setupToolbar() {
+        setSupportActionBar(binding.toolbar);
+        getSupportActionBar().setTitle(R.string.supervisor_dashboard);
+    }
+    
+    private void setupRecyclerView() {
+        adapter = new PersonCardAdapter(personStatus -> {
+            // Navigate to detail view
+            Intent intent = new Intent(this, BtConnectedActivity.class);
+            intent.putExtra(BtConnectedActivity.EXTRA_SENSOR_ID, personStatus.getSensorId());
+            intent.putExtra(BtConnectedActivity.EXTRA_PERSON_NAME, personStatus.getDisplayName());
+            startActivity(intent);
+        });
+        
+        // Grid layout for cards (2 columns on phones, 3 on tablets)
+        int spanCount = getResources().getInteger(R.integer.dashboard_span_count);
+        binding.recyclerView.setLayoutManager(new GridLayoutManager(this, spanCount));
+        binding.recyclerView.setAdapter(adapter);
+    }
+    
+    private void setupSwipeRefresh() {
+        binding.swipeRefresh.setOnRefreshListener(() -> {
+            viewModel.refreshData();
+        });
+    }
+    
+    private void observeData() {
+        viewModel.getPersonStatuses().observe(this, statuses -> {
+            adapter.submitList(statuses);
+            binding.swipeRefresh.setRefreshing(false);
+            
+            // Show empty state
+            binding.emptyState.setVisibility(
+                statuses.isEmpty() ? View.VISIBLE : View.GONE
+            );
+        });
+        
+        viewModel.getIsLoading().observe(this, isLoading -> {
+            binding.progressBar.setVisibility(isLoading ? View.VISIBLE : View.GONE);
+        });
+    }
+}
+```
+
+### 2. Create `PersonCardAdapter.java` in `ui/adapters/`
+
+```java
+public class PersonCardAdapter extends ListAdapter<PersonStatus, PersonCardAdapter.ViewHolder> {
+    
+    private static final long STALE_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes
+    
+    private final OnPersonClickListener clickListener;
+    
+    public interface OnPersonClickListener {
+        void onClick(PersonStatus person);
+    }
+    
+    public PersonCardAdapter(OnPersonClickListener listener) {
+        super(new DiffCallback());
+        this.clickListener = listener;
+    }
+    
+    @NonNull
+    @Override
+    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        ItemPersonCardBinding binding = ItemPersonCardBinding.inflate(
+            LayoutInflater.from(parent.getContext()), parent, false);
+        return new ViewHolder(binding);
+    }
+    
+    @Override
+    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
+        holder.bind(getItem(position), clickListener);
+    }
+    
+    class ViewHolder extends RecyclerView.ViewHolder {
+        private final ItemPersonCardBinding binding;
+        
+        ViewHolder(ItemPersonCardBinding binding) {
+            super(binding.getRoot());
+            this.binding = binding;
+        }
+        
+        void bind(PersonStatus person, OnPersonClickListener listener) {
+            Context ctx = itemView.getContext();
+            
+            // Person name
+            binding.personNameText.setText(person.getDisplayName());
+            
+            // Posture icon
+            binding.postureIcon.setImageResource(person.getPostureIconRes());
+            
+            // Last update time
+            String timeAgo = formatTimeAgo(person.getLastUpdateTime());
+            binding.lastUpdateText.setText(timeAgo);
+            
+            // Status indicator color
+            int statusColor;
+            if (person.isAlert()) {
+                // Red for falls
+                statusColor = ContextCompat.getColor(ctx, R.color.status_alert);
+                binding.alertBadge.setVisibility(View.VISIBLE);
+            } else if (isStale(person.getLastUpdateTime())) {
+                // Yellow for stale data
+                statusColor = ContextCompat.getColor(ctx, R.color.status_stale);
+                binding.alertBadge.setVisibility(View.GONE);
+            } else {
+                // Green for active
+                statusColor = ContextCompat.getColor(ctx, R.color.status_active);
+                binding.alertBadge.setVisibility(View.GONE);
+            }
+            binding.statusIndicator.setBackgroundColor(statusColor);
+            
+            // Click handler
+            binding.cardView.setOnClickListener(v -> listener.onClick(person));
+        }
+        
+        private boolean isStale(long timestamp) {
+            return System.currentTimeMillis() - timestamp > STALE_THRESHOLD_MS;
+        }
+        
+        private String formatTimeAgo(long timestamp) {
+            long diff = System.currentTimeMillis() - timestamp;
+            if (diff < 60_000) return "Just now";
+            if (diff < 3600_000) return (diff / 60_000) + "m ago";
+            if (diff < 86400_000) return (diff / 3600_000) + "h ago";
+            return (diff / 86400_000) + "d ago";
+        }
+    }
+    
+    static class DiffCallback extends DiffUtil.ItemCallback<PersonStatus> {
+        @Override
+        public boolean areItemsTheSame(@NonNull PersonStatus oldItem, @NonNull PersonStatus newItem) {
+            return oldItem.getSensorId().equals(newItem.getSensorId());
+        }
+        
+        @Override
+        public boolean areContentsTheSame(@NonNull PersonStatus oldItem, @NonNull PersonStatus newItem) {
+            return oldItem.equals(newItem);
+        }
+    }
+}
+```
+
+### 3. Create `PersonStatus.java` model
+
+```java
+public class PersonStatus {
+    private final String sensorId;
+    private final String displayName;
+    private final Posture currentPosture;
+    private final long lastUpdateTime;
+    private final boolean isAlert;
+    
+    // Constructor, getters, equals, hashCode
+    
+    public int getPostureIconRes() {
+        return currentPosture.getPictureCode();
+    }
+}
+```
+
+### 4. Create `SupervisorDashboardViewModel.java`
+
+```java
+public class SupervisorDashboardViewModel extends AndroidViewModel {
+    private final ReceivedBtDataDao dao;
+    private final PersonNameManager personNameManager;
+    private final MutableLiveData<Boolean> isLoading = new MutableLiveData<>(false);
+    
+    private final LiveData<List<PersonStatus>> personStatuses;
+    
+    public SupervisorDashboardViewModel(@NonNull Application application) {
+        super(application);
+        
+        dao = InnovaDatabase.getInstance(application).receivedBtDataDao();
+        personNameManager = PersonNameManager.getInstance(application);
+        
+        // Get latest reading for each sensor
+        LiveData<List<ReceivedBtDataEntity>> latestPerSensor = dao.getLatestForEachSensor();
+        
+        // Transform to PersonStatus with display names
+        personStatuses = Transformations.map(latestPerSensor, entities -> {
+            List<PersonStatus> statuses = new ArrayList<>();
+            for (ReceivedBtDataEntity entity : entities) {
+                String sensorId = entity.getSensorId();
+                if (sensorId == null) continue;
+                
+                String displayName = personNameManager.getDisplayName(sensorId);
+                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
+                boolean isAlert = posture instanceof FallingPosture;
+                
+                statuses.add(new PersonStatus(
+                    sensorId,
+                    displayName,
+                    posture,
+                    entity.getTimestamp(),
+                    isAlert
+                ));
+            }
+            
+            // Sort: alerts first, then by name
+            Collections.sort(statuses, (a, b) -> {
+                if (a.isAlert() != b.isAlert()) {
+                    return a.isAlert() ? -1 : 1;
+                }
+                return a.getDisplayName().compareToIgnoreCase(b.getDisplayName());
+            });
+            
+            return statuses;
+        });
+    }
+    
+    public LiveData<List<PersonStatus>> getPersonStatuses() {
+        return personStatuses;
+    }
+    
+    public LiveData<Boolean> getIsLoading() {
+        return isLoading;
+    }
+    
+    public void refreshData() {
+        // Trigger Firestore sync refresh
+        isLoading.setValue(true);
+        // ... sync logic ...
+        isLoading.setValue(false);
+    }
+}
+```
+
+### 5. Create layouts
+
+**`activity_supervisor_dashboard.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.coordinatorlayout.widget.CoordinatorLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    
+    <com.google.android.material.appbar.AppBarLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content">
+        
+        <com.google.android.material.appbar.MaterialToolbar
+            android:id="@+id/toolbar"
+            android:layout_width="match_parent"
+            android:layout_height="?attr/actionBarSize" />
+    </com.google.android.material.appbar.AppBarLayout>
+    
+    <FrameLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        app:layout_behavior="@string/appbar_scrolling_view_behavior">
+        
+        <androidx.swiperefreshlayout.widget.SwipeRefreshLayout
+            android:id="@+id/swipeRefresh"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent">
+            
+            <androidx.recyclerview.widget.RecyclerView
+                android:id="@+id/recyclerView"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:padding="8dp"
+                android:clipToPadding="false" />
+        </androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
+        
+        <!-- Empty State -->
+        <LinearLayout
+            android:id="@+id/emptyState"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:orientation="vertical"
+            android:gravity="center"
+            android:visibility="gone">
+            
+            <ImageView
+                android:layout_width="100dp"
+                android:layout_height="100dp"
+                android:src="@drawable/ic_people_outline" />
+            
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:text="@string/no_monitored_persons_supervisor"
+                android:layout_marginTop="16dp" />
+        </LinearLayout>
+        
+        <ProgressBar
+            android:id="@+id/progressBar"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:visibility="gone" />
+    </FrameLayout>
+</androidx.coordinatorlayout.widget.CoordinatorLayout>
+```
+
+**`item_person_card.xml`**
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<com.google.android.material.card.MaterialCardView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/cardView"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:layout_margin="4dp"
+    app:cardElevation="4dp">
+    
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical">
+        
+        <!-- Status indicator bar at top -->
+        <View
+            android:id="@+id/statusIndicator"
+            android:layout_width="match_parent"
+            android:layout_height="4dp" />
+        
+        <FrameLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:padding="12dp">
+            
+            <LinearLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:orientation="vertical"
+                android:gravity="center">
+                
+                <!-- Posture Icon -->
+                <ImageView
+                    android:id="@+id/postureIcon"
+                    android:layout_width="60dp"
+                    android:layout_height="60dp" />
+                
+                <!-- Person Name -->
+                <TextView
+                    android:id="@+id/personNameText"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textSize="14sp"
+                    android:textStyle="bold"
+                    android:gravity="center"
+                    android:maxLines="2"
+                    android:ellipsize="end"
+                    android:layout_marginTop="8dp" />
+                
+                <!-- Last Update -->
+                <TextView
+                    android:id="@+id/lastUpdateText"
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:textSize="11sp"
+                    android:textColor="@android:color/darker_gray"
+                    android:layout_marginTop="4dp" />
+            </LinearLayout>
+            
+            <!-- Alert Badge (for falls) -->
+            <ImageView
+                android:id="@+id/alertBadge"
+                android:layout_width="24dp"
+                android:layout_height="24dp"
+                android:layout_gravity="top|end"
+                android:src="@drawable/ic_warning"
+                android:visibility="gone" />
+        </FrameLayout>
+    </LinearLayout>
+</com.google.android.material.card.MaterialCardView>
+```
+
+### 6. Update navigation in `MainActivity.java`
+
+```java
+public void LaunchMonitoring(View view) {
+    SessionGate.getInstance(this).waitForSessionReady(new SessionGate.SessionReadyCallback() {
+        @Override
+        public void onSessionReady(String userId, String role, List<String> supervisedUserIds) {
+            runOnUiThread(() -> {
+                if ("supervisor".equals(role)) {
+                    // NEW: Route to multi-person dashboard
+                    Intent intent = new Intent(MainActivity.this, SupervisorDashboardActivity.class);
+                    startActivity(intent);
+                } else {
+                    // Aggregator: go to aggregator dashboard
+                    Intent intent = new Intent(MainActivity.this, AggregatorDashboardActivity.class);
+                    startActivity(intent);
+                }
+            });
+        }
+        // ...
+    });
+}
+```
+
+---
+
+## Files to Create
+
+- `app/src/main/java/com/melisa/innovamotionapp/activities/SupervisorDashboardActivity.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/adapters/PersonCardAdapter.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/models/PersonStatus.java`
+- `app/src/main/java/com/melisa/innovamotionapp/ui/viewmodels/SupervisorDashboardViewModel.java`
+- `app/src/main/res/layout/activity_supervisor_dashboard.xml`
+- `app/src/main/res/layout/item_person_card.xml`
+- `app/src/main/res/values/integers.xml` (for dashboard_span_count)
+
+## Files to Modify
+
+- [`MainActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/MainActivity.java) - update `LaunchMonitoring()` routing
+
+---
+
+## Acceptance Criteria
+
+- [ ] Grid of cards showing all monitored persons
+- [ ] Each card shows: name, posture icon, last update time
+- [ ] Status colors: green (active), yellow (stale > 5min), red (alert/fall)
+- [ ] Alert badge visible for fall postures
+- [ ] Tap card navigates to detail view (Task 9)
+- [ ] Swipe-to-refresh triggers data sync
+- [ ] Empty state when no persons
+- [ ] Real-time updates as new data arrives
+- [ ] Supervisors routed here from MainActivity
diff --git a/InnovaMotionApp/docs/tasks/09-person-detail-view.md b/InnovaMotionApp/docs/tasks/09-person-detail-view.md
index a1bf7b1..266d2ae 100644
--- a/InnovaMotionApp/docs/tasks/09-person-detail-view.md
+++ b/InnovaMotionApp/docs/tasks/09-person-detail-view.md
@@ -1,114 +1,114 @@
-# TASK 9: Individual Person Detail View (Supervisor)
-
-**Assigned To:** UI Developer  
-**Estimated Effort:** 1-2 days  
-**Dependencies:** Task 8 (Dashboard), existing views  
-**Status:** Pending
-
----
-
-## Context
-
-Reuse existing single-person view (`BtConnectedActivity`) for detailed monitoring of one selected person.
-
----
-
-## Deliverables
-
-### 1. Modify `BtConnectedActivity.java`
-
-Add support for sensor-specific filtering:
-
-```java
-public class BtConnectedActivity extends AppCompatActivity {
-    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
-    public static final String EXTRA_PERSON_NAME = "extra_person_name";
-    
-    private String sensorId; // null = show all (legacy behavior)
-    private String personName;
-    
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        
-        // Get intent extras
-        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
-        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
-        
-        // Update title if person name provided
-        if (personName != null && !personName.isEmpty()) {
-            binding.descriptionTextView.setText(personName);
-        }
-        
-        // Modify observer based on whether sensorId is provided
-        if (sensorId != null && RoleProvider.isSupervisor()) {
-            // Supervisor viewing specific person
-            observeSensorSpecificData();
-        } else {
-            // Existing behavior
-            observeGlobalData();
-        }
-    }
-    
-    private void observeSensorSpecificData() {
-        ReceivedBtDataDao dao = InnovaDatabase.getInstance(this).receivedBtDataDao();
-        dao.getLatestForSensor(sensorId).observe(this, entity -> {
-            if (entity != null) {
-                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
-                displayPostureData(posture);
-            }
-        });
-    }
-    
-    private void observeGlobalData() {
-        // Existing GlobalData observer code
-        globalData.getReceivedPosture().observe(this, this::displayPostureData);
-    }
-}
-```
-
-### 2. OR Create `PersonDetailActivity.java` (if heavy modifications needed)
-
-Only if modifying `BtConnectedActivity` becomes too complex:
-- Clone existing layout and logic
-- Add sensor-specific filtering from start
-- Clean separation from BT-connected flow
-
-### 3. Ensure existing features work per-person
-
-Pass `sensorId` to other activities:
-
-```java
-// From detail view, navigate to statistics
-public void LaunchStatistics(View view) {
-    Intent intent = new Intent(this, StatisticsActivity.class);
-    if (sensorId != null) {
-        intent.putExtra(StatisticsActivity.EXTRA_SENSOR_ID, sensorId);
-        intent.putExtra(StatisticsActivity.EXTRA_PERSON_NAME, personName);
-    }
-    startActivity(intent);
-}
-```
-
-Update `StatisticsActivity` and `EnergyConsumptionActivity` to filter by sensorId when provided.
-
----
-
-## Files to Modify or Reference
-
-- [`BtConnectedActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java)
-- [`StatisticsActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/StatisticsActivity.java)
-- [`EnergyConsumptionActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/EnergyConsumptionActivity.java)
-- [`TimeLapseActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/TimeLapseActivity.java)
-
----
-
-## Acceptance Criteria
-
-- [ ] Detail view accepts `sensorId` and `personName` via intent extras
-- [ ] Title shows person's display name
-- [ ] Posture data filtered to specific sensor
-- [ ] Statistics work per-person when sensorId provided
-- [ ] Energy consumption works per-person when sensorId provided
-- [ ] Back navigation returns to dashboard
-- [ ] Legacy behavior preserved when no sensorId provided
+# TASK 9: Individual Person Detail View (Supervisor)
+
+**Assigned To:** UI Developer  
+**Estimated Effort:** 1-2 days  
+**Dependencies:** Task 8 (Dashboard), existing views  
+**Status:** Pending
+
+---
+
+## Context
+
+Reuse existing single-person view (`BtConnectedActivity`) for detailed monitoring of one selected person.
+
+---
+
+## Deliverables
+
+### 1. Modify `BtConnectedActivity.java`
+
+Add support for sensor-specific filtering:
+
+```java
+public class BtConnectedActivity extends AppCompatActivity {
+    public static final String EXTRA_SENSOR_ID = "extra_sensor_id";
+    public static final String EXTRA_PERSON_NAME = "extra_person_name";
+    
+    private String sensorId; // null = show all (legacy behavior)
+    private String personName;
+    
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        
+        // Get intent extras
+        sensorId = getIntent().getStringExtra(EXTRA_SENSOR_ID);
+        personName = getIntent().getStringExtra(EXTRA_PERSON_NAME);
+        
+        // Update title if person name provided
+        if (personName != null && !personName.isEmpty()) {
+            binding.descriptionTextView.setText(personName);
+        }
+        
+        // Modify observer based on whether sensorId is provided
+        if (sensorId != null && RoleProvider.isSupervisor()) {
+            // Supervisor viewing specific person
+            observeSensorSpecificData();
+        } else {
+            // Existing behavior
+            observeGlobalData();
+        }
+    }
+    
+    private void observeSensorSpecificData() {
+        ReceivedBtDataDao dao = InnovaDatabase.getInstance(this).receivedBtDataDao();
+        dao.getLatestForSensor(sensorId).observe(this, entity -> {
+            if (entity != null) {
+                Posture posture = PostureFactory.createPosture(entity.getReceivedMsg());
+                displayPostureData(posture);
+            }
+        });
+    }
+    
+    private void observeGlobalData() {
+        // Existing GlobalData observer code
+        globalData.getReceivedPosture().observe(this, this::displayPostureData);
+    }
+}
+```
+
+### 2. OR Create `PersonDetailActivity.java` (if heavy modifications needed)
+
+Only if modifying `BtConnectedActivity` becomes too complex:
+- Clone existing layout and logic
+- Add sensor-specific filtering from start
+- Clean separation from BT-connected flow
+
+### 3. Ensure existing features work per-person
+
+Pass `sensorId` to other activities:
+
+```java
+// From detail view, navigate to statistics
+public void LaunchStatistics(View view) {
+    Intent intent = new Intent(this, StatisticsActivity.class);
+    if (sensorId != null) {
+        intent.putExtra(StatisticsActivity.EXTRA_SENSOR_ID, sensorId);
+        intent.putExtra(StatisticsActivity.EXTRA_PERSON_NAME, personName);
+    }
+    startActivity(intent);
+}
+```
+
+Update `StatisticsActivity` and `EnergyConsumptionActivity` to filter by sensorId when provided.
+
+---
+
+## Files to Modify or Reference
+
+- [`BtConnectedActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/BtConnectedActivity.java)
+- [`StatisticsActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/StatisticsActivity.java)
+- [`EnergyConsumptionActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/EnergyConsumptionActivity.java)
+- [`TimeLapseActivity.java`](../../app/src/main/java/com/melisa/innovamotionapp/activities/TimeLapseActivity.java)
+
+---
+
+## Acceptance Criteria
+
+- [ ] Detail view accepts `sensorId` and `personName` via intent extras
+- [ ] Title shows person's display name
+- [ ] Posture data filtered to specific sensor
+- [ ] Statistics work per-person when sensorId provided
+- [ ] Energy consumption works per-person when sensorId provided
+- [ ] Back navigation returns to dashboard
+- [ ] Legacy behavior preserved when no sensorId provided
diff --git a/InnovaMotionApp/docs/tasks/10-batch-upload.md b/InnovaMotionApp/docs/tasks/10-batch-upload.md
index 4dc8b3a..1a385bf 100644
--- a/InnovaMotionApp/docs/tasks/10-batch-upload.md
+++ b/InnovaMotionApp/docs/tasks/10-batch-upload.md
@@ -1,145 +1,145 @@
-# TASK 10: Firestore Batch Upload Optimization
-
-**Assigned To:** Backend Developer  
-**Estimated Effort:** 2-3 days  
-**Dependencies:** Task 2 (Data Model), Task 4 (Service Integration)  
-**Status:** Pending
-
----
-
-## Context
-
-Current system syncs messages one-by-one. New system should upload entire packets as batches for better performance.
-
----
-
-## Deliverables
-
-### 1. Modify `FirestoreSyncService.java`
-
-Add batch sync method:
-
-```java
-/**
- * Sync an entire packet as a batch write.
- * More efficient than individual writes.
- */
-public void syncPacketBatch(List<ReceivedBtDataEntity> packet, SyncCallback callback) {
-    if (!isUserAuthenticated() || !userSession.isSupervised()) {
-        callback.onSuccess("Not supervised user, skipping sync");
-        return;
-    }
-    
-    if (!connectivityMonitor.isConnected()) {
-        // Queue for later
-        queuePacketForLaterSync(packet);
-        callback.onSuccess("Offline, queued for later sync");
-        return;
-    }
-    
-    executorService.execute(() -> {
-        FirebaseUser user = auth.getCurrentUser();
-        WriteBatch batch = firestore.batch();
-        
-        for (ReceivedBtDataEntity entity : packet) {
-            FirestoreDataModel model = new FirestoreDataModel(
-                entity.getDeviceAddress(),
-                entity.getTimestamp(),
-                entity.getReceivedMsg(),
-                user.getUid(),
-                entity.getSensorId()
-            );
-            
-            DocumentReference docRef = firestore
-                .collection(COLLECTION_BT_DATA)
-                .document(model.getDocumentId());
-            
-            batch.set(docRef, model.toFirestoreDocument());
-        }
-        
-        batch.commit()
-            .addOnSuccessListener(v -> callback.onSuccess("Batch synced: " + packet.size()))
-            .addOnFailureListener(e -> callback.onError(e.getMessage()));
-    });
-}
-```
-
-### 2. Add offline queue management
-
-```java
-private final Queue<List<ReceivedBtDataEntity>> offlineQueue = new ConcurrentLinkedQueue<>();
-
-private void queuePacketForLaterSync(List<ReceivedBtDataEntity> packet) {
-    offlineQueue.add(new ArrayList<>(packet));
-    Log.d(TAG, "Queued packet for later sync. Queue size: " + offlineQueue.size());
-}
-
-/**
- * Process queued packets when connectivity is restored.
- * Called from handleConnectivityRestored()
- */
-private void processOfflineQueue() {
-    if (offlineQueue.isEmpty()) return;
-    
-    Log.i(TAG, "Processing offline queue: " + offlineQueue.size() + " packets");
-    
-    while (!offlineQueue.isEmpty()) {
-        List<ReceivedBtDataEntity> packet = offlineQueue.poll();
-        if (packet != null) {
-            syncPacketBatch(packet, new SyncCallback() {
-                @Override public void onSuccess(String msg) { 
-                    Log.d(TAG, "Queued packet synced: " + msg); 
-                }
-                @Override public void onError(String err) { 
-                    Log.w(TAG, "Failed to sync queued packet: " + err);
-                    // Re-queue on failure? Consider retry limits.
-                }
-                @Override public void onProgress(int c, int t) {}
-            });
-        }
-    }
-}
-```
-
-### 3. Update `DeviceCommunicationService.java`
-
-Trigger batch sync after packet processing:
-
-```java
-private void processPacket(BluetoothDevice device, List<ParsedReading> readings) {
-    // ... create entities list ...
-    
-    // Batch insert to Room
-    synchronized (lock) {
-        temporaryReceivedBtDataListToSave.addAll(entities);
-    }
-    
-    // Trigger batch sync to Firestore
-    firestoreSyncService.syncPacketBatch(entities, new SyncCallback() {
-        @Override public void onSuccess(String msg) { 
-            Log.d(TAG, "Packet synced: " + msg); 
-        }
-        @Override public void onError(String err) { 
-            Log.w(TAG, "Packet sync error: " + err); 
-        }
-        @Override public void onProgress(int c, int t) {}
-    });
-}
-```
-
----
-
-## Files to Modify
-
-- [`FirestoreSyncService.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java)
-- [`DeviceCommunicationService.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java)
-
----
-
-## Acceptance Criteria
-
-- [ ] Packets are uploaded as single Firestore batch write
-- [ ] Offline packets are queued and processed when online
-- [ ] Single network round-trip per packet (not per message)
-- [ ] WriteBatch limit (500 docs) is respected for large packets
-- [ ] Error handling and retry logic for failed batches
+# TASK 10: Firestore Batch Upload Optimization
+
+**Assigned To:** Backend Developer  
+**Estimated Effort:** 2-3 days  
+**Dependencies:** Task 2 (Data Model), Task 4 (Service Integration)  
+**Status:** Pending
+
+---
+
+## Context
+
+Current system syncs messages one-by-one. New system should upload entire packets as batches for better performance.
+
+---
+
+## Deliverables
+
+### 1. Modify `FirestoreSyncService.java`
+
+Add batch sync method:
+
+```java
+/**
+ * Sync an entire packet as a batch write.
+ * More efficient than individual writes.
+ */
+public void syncPacketBatch(List<ReceivedBtDataEntity> packet, SyncCallback callback) {
+    if (!isUserAuthenticated() || !userSession.isSupervised()) {
+        callback.onSuccess("Not supervised user, skipping sync");
+        return;
+    }
+    
+    if (!connectivityMonitor.isConnected()) {
+        // Queue for later
+        queuePacketForLaterSync(packet);
+        callback.onSuccess("Offline, queued for later sync");
+        return;
+    }
+    
+    executorService.execute(() -> {
+        FirebaseUser user = auth.getCurrentUser();
+        WriteBatch batch = firestore.batch();
+        
+        for (ReceivedBtDataEntity entity : packet) {
+            FirestoreDataModel model = new FirestoreDataModel(
+                entity.getDeviceAddress(),
+                entity.getTimestamp(),
+                entity.getReceivedMsg(),
+                user.getUid(),
+                entity.getSensorId()
+            );
+            
+            DocumentReference docRef = firestore
+                .collection(COLLECTION_BT_DATA)
+                .document(model.getDocumentId());
+            
+            batch.set(docRef, model.toFirestoreDocument());
+        }
+        
+        batch.commit()
+            .addOnSuccessListener(v -> callback.onSuccess("Batch synced: " + packet.size()))
+            .addOnFailureListener(e -> callback.onError(e.getMessage()));
+    });
+}
+```
+
+### 2. Add offline queue management
+
+```java
+private final Queue<List<ReceivedBtDataEntity>> offlineQueue = new ConcurrentLinkedQueue<>();
+
+private void queuePacketForLaterSync(List<ReceivedBtDataEntity> packet) {
+    offlineQueue.add(new ArrayList<>(packet));
+    Log.d(TAG, "Queued packet for later sync. Queue size: " + offlineQueue.size());
+}
+
+/**
+ * Process queued packets when connectivity is restored.
+ * Called from handleConnectivityRestored()
+ */
+private void processOfflineQueue() {
+    if (offlineQueue.isEmpty()) return;
+    
+    Log.i(TAG, "Processing offline queue: " + offlineQueue.size() + " packets");
+    
+    while (!offlineQueue.isEmpty()) {
+        List<ReceivedBtDataEntity> packet = offlineQueue.poll();
+        if (packet != null) {
+            syncPacketBatch(packet, new SyncCallback() {
+                @Override public void onSuccess(String msg) { 
+                    Log.d(TAG, "Queued packet synced: " + msg); 
+                }
+                @Override public void onError(String err) { 
+                    Log.w(TAG, "Failed to sync queued packet: " + err);
+                    // Re-queue on failure? Consider retry limits.
+                }
+                @Override public void onProgress(int c, int t) {}
+            });
+        }
+    }
+}
+```
+
+### 3. Update `DeviceCommunicationService.java`
+
+Trigger batch sync after packet processing:
+
+```java
+private void processPacket(BluetoothDevice device, List<ParsedReading> readings) {
+    // ... create entities list ...
+    
+    // Batch insert to Room
+    synchronized (lock) {
+        temporaryReceivedBtDataListToSave.addAll(entities);
+    }
+    
+    // Trigger batch sync to Firestore
+    firestoreSyncService.syncPacketBatch(entities, new SyncCallback() {
+        @Override public void onSuccess(String msg) { 
+            Log.d(TAG, "Packet synced: " + msg); 
+        }
+        @Override public void onError(String err) { 
+            Log.w(TAG, "Packet sync error: " + err); 
+        }
+        @Override public void onProgress(int c, int t) {}
+    });
+}
+```
+
+---
+
+## Files to Modify
+
+- [`FirestoreSyncService.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java)
+- [`DeviceCommunicationService.java`](../../app/src/main/java/com/melisa/innovamotionapp/bluetooth/DeviceCommunicationService.java)
+
+---
+
+## Acceptance Criteria
+
+- [ ] Packets are uploaded as single Firestore batch write
+- [ ] Offline packets are queued and processed when online
+- [ ] Single network round-trip per packet (not per message)
+- [ ] WriteBatch limit (500 docs) is respected for large packets
+- [ ] Error handling and retry logic for failed batches
diff --git a/InnovaMotionApp/docs/tasks/11-query-optimization.md b/InnovaMotionApp/docs/tasks/11-query-optimization.md
index 9295df4..dbfe5d8 100644
--- a/InnovaMotionApp/docs/tasks/11-query-optimization.md
+++ b/InnovaMotionApp/docs/tasks/11-query-optimization.md
@@ -1,115 +1,115 @@
-# TASK 11: Supervisor Query Optimization
-
-**Assigned To:** Backend Developer  
-**Estimated Effort:** 1-2 days  
-**Dependencies:** Task 2 (Data Model)  
-**Status:** Pending
-
----
-
-## Context
-
-Current system queries Firestore separately for each supervised user. Optimize to single query where possible.
-
----
-
-## Deliverables
-
-### 1. Update `FirestoreSyncService.java`
-
-Replace multiple queries with compound query:
-
-```java
-/**
- * Sync data from multiple supervised users in single query.
- * Note: Firestore whereIn limit is 10 values, so batch if more.
- */
-private void syncFromMultipleUsers(List<String> userIds, SyncCallback callback) {
-    if (userIds.isEmpty()) {
-        callback.onSuccess("No users to sync");
-        return;
-    }
-    
-    // Firestore whereIn limit is 10
-    final int BATCH_SIZE = 10;
-    
-    for (int i = 0; i < userIds.size(); i += BATCH_SIZE) {
-        List<String> batch = userIds.subList(i, Math.min(i + BATCH_SIZE, userIds.size()));
-        
-        firestore.collection(COLLECTION_BT_DATA)
-            .whereIn("userId", batch)
-            .orderBy("timestamp", Query.Direction.DESCENDING)
-            .limit(100) // Limit per query
-            .get()
-            .addOnSuccessListener(snapshot -> {
-                processQueryResults(snapshot, callback);
-            })
-            .addOnFailureListener(e -> {
-                callback.onError("Query failed: " + e.getMessage());
-            });
-    }
-}
-```
-
-### 2. Update supervisor mirror setup
-
-Consider trade-offs:
-
-**Option A: Single compound listener (recommended for <10 users)**
-```java
-public void startCompoundMirror(List<String> supervisedUserIds) {
-    if (supervisedUserIds.size() > 10) {
-        // Fall back to per-user listeners
-        startSupervisorMirrors(supervisedUserIds);
-        return;
-    }
-    
-    ListenerRegistration listener = firestore.collection(COLLECTION_BT_DATA)
-        .whereIn("userId", supervisedUserIds)
-        .orderBy("timestamp", Query.Direction.ASCENDING)
-        .addSnapshotListener((snapshot, e) -> {
-            if (e != null) return;
-            handleCompoundDocumentChanges(snapshot.getDocumentChanges());
-        });
-    
-    // Store single listener reference
-    compoundMirrorListener = listener;
-}
-```
-
-**Option B: Keep per-user listeners (current approach)**
-- Better for >10 users
-- More granular error handling per user
-- Document decision in code comments
-
-### 3. Update Room queries
-
-Ensure efficient queries exist:
-
-```java
-// Already efficient - single query, not N queries
-@Query("SELECT * FROM received_bt_data WHERE sensor_id IS NOT NULL " +
-       "GROUP BY sensor_id HAVING timestamp = MAX(timestamp)")
-LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensor();
-
-// Ensure proper indexes exist
-@Query("CREATE INDEX IF NOT EXISTS idx_sensor_timestamp ON received_bt_data(sensor_id, timestamp)")
-void createSensorTimestampIndex();
-```
-
----
-
-## Files to Modify
-
-- [`FirestoreSyncService.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java)
-- [`ReceivedBtDataDao.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java) (add indexes if needed)
-
----
-
-## Acceptance Criteria
-
-- [ ] Compound queries used for <10 supervised users
-- [ ] Batching implemented for >10 users (Firestore whereIn limit)
-- [ ] Room queries are efficient (single query per operation)
-- [ ] Trade-off between single vs. per-user listeners documented
-- [ ] Performance improvement measurable in logs
+# TASK 11: Supervisor Query Optimization
+
+**Assigned To:** Backend Developer  
+**Estimated Effort:** 1-2 days  
+**Dependencies:** Task 2 (Data Model)  
+**Status:** Pending
+
+---
+
+## Context
+
+Current system queries Firestore separately for each supervised user. Optimize to single query where possible.
+
+---
+
+## Deliverables
+
+### 1. Update `FirestoreSyncService.java`
+
+Replace multiple queries with compound query:
+
+```java
+/**
+ * Sync data from multiple supervised users in single query.
+ * Note: Firestore whereIn limit is 10 values, so batch if more.
+ */
+private void syncFromMultipleUsers(List<String> userIds, SyncCallback callback) {
+    if (userIds.isEmpty()) {
+        callback.onSuccess("No users to sync");
+        return;
+    }
+    
+    // Firestore whereIn limit is 10
+    final int BATCH_SIZE = 10;
+    
+    for (int i = 0; i < userIds.size(); i += BATCH_SIZE) {
+        List<String> batch = userIds.subList(i, Math.min(i + BATCH_SIZE, userIds.size()));
+        
+        firestore.collection(COLLECTION_BT_DATA)
+            .whereIn("userId", batch)
+            .orderBy("timestamp", Query.Direction.DESCENDING)
+            .limit(100) // Limit per query
+            .get()
+            .addOnSuccessListener(snapshot -> {
+                processQueryResults(snapshot, callback);
+            })
+            .addOnFailureListener(e -> {
+                callback.onError("Query failed: " + e.getMessage());
+            });
+    }
+}
+```
+
+### 2. Update supervisor mirror setup
+
+Consider trade-offs:
+
+**Option A: Single compound listener (recommended for <10 users)**
+```java
+public void startCompoundMirror(List<String> supervisedUserIds) {
+    if (supervisedUserIds.size() > 10) {
+        // Fall back to per-user listeners
+        startSupervisorMirrors(supervisedUserIds);
+        return;
+    }
+    
+    ListenerRegistration listener = firestore.collection(COLLECTION_BT_DATA)
+        .whereIn("userId", supervisedUserIds)
+        .orderBy("timestamp", Query.Direction.ASCENDING)
+        .addSnapshotListener((snapshot, e) -> {
+            if (e != null) return;
+            handleCompoundDocumentChanges(snapshot.getDocumentChanges());
+        });
+    
+    // Store single listener reference
+    compoundMirrorListener = listener;
+}
+```
+
+**Option B: Keep per-user listeners (current approach)**
+- Better for >10 users
+- More granular error handling per user
+- Document decision in code comments
+
+### 3. Update Room queries
+
+Ensure efficient queries exist:
+
+```java
+// Already efficient - single query, not N queries
+@Query("SELECT * FROM received_bt_data WHERE sensor_id IS NOT NULL " +
+       "GROUP BY sensor_id HAVING timestamp = MAX(timestamp)")
+LiveData<List<ReceivedBtDataEntity>> getLatestForEachSensor();
+
+// Ensure proper indexes exist
+@Query("CREATE INDEX IF NOT EXISTS idx_sensor_timestamp ON received_bt_data(sensor_id, timestamp)")
+void createSensorTimestampIndex();
+```
+
+---
+
+## Files to Modify
+
+- [`FirestoreSyncService.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/FirestoreSyncService.java)
+- [`ReceivedBtDataDao.java`](../../app/src/main/java/com/melisa/innovamotionapp/data/database/ReceivedBtDataDao.java) (add indexes if needed)
+
+---
+
+## Acceptance Criteria
+
+- [ ] Compound queries used for <10 supervised users
+- [ ] Batching implemented for >10 users (Firestore whereIn limit)
+- [ ] Room queries are efficient (single query per operation)
+- [ ] Trade-off between single vs. per-user listeners documented
+- [ ] Performance improvement measurable in logs
diff --git a/InnovaMotionApp/docs/tasks/12-role-terminology.md b/InnovaMotionApp/docs/tasks/12-role-terminology.md
index 3e99ab5..f6590ec 100644
--- a/InnovaMotionApp/docs/tasks/12-role-terminology.md
+++ b/InnovaMotionApp/docs/tasks/12-role-terminology.md
@@ -1,105 +1,105 @@
-# TASK 12: Role Terminology Update (Supervised â†’ Aggregator)
-
-**Assigned To:** Any Developer (cleanup task)  
-**Estimated Effort:** 1 day  
-**Dependencies:** None (can be done last)  
-**Status:** Pending
-
----
-
-## Context
-
-The specification renames "Supervised" role to "Aggregator" for clarity. The old name was confusing because supervised users aren't being supervised - they aggregate data from multiple monitored persons.
-
----
-
-## Deliverables
-
-### 1. Update `RoleProvider.java`
-
-```java
-public enum Role { 
-    AGGREGATOR,   // NEW: Data collection role (formerly SUPERVISED)
-    SUPERVISOR, 
-    UNKNOWN,
-    
-    @Deprecated
-    SUPERVISED    // Keep for backward compatibility, maps to AGGREGATOR
-}
-
-public static Role getCurrentRole() {
-    String role = GlobalData.getInstance().currentUserRole;
-    if ("supervised".equalsIgnoreCase(role) || "aggregator".equalsIgnoreCase(role)) {
-        return Role.AGGREGATOR;
-    }
-    if ("supervisor".equalsIgnoreCase(role)) {
-        return Role.SUPERVISOR;
-    }
-    return Role.UNKNOWN;
-}
-
-public static boolean isAggregator() {
-    return getCurrentRole() == Role.AGGREGATOR;
-}
-
-@Deprecated
-public static boolean isSupervised() {
-    return isAggregator(); // Alias for backward compatibility
-}
-```
-
-### 2. Update Firestore user documents
-
-**Decision needed:** Use new role name or keep backward compatible?
-
-**Option A: Backward compatible (recommended)**
-- Accept both "supervised" and "aggregator" in code
-- New signups use "aggregator"
-- Existing users continue to work
-
-**Option B: Migration**
-- Run one-time Firestore migration script
-- Update all `role: "supervised"` to `role: "aggregator"`
-
-### 3. Update UI strings
-
-In `strings.xml`:
-
-```xml
-<!-- Old -->
-<string name="role_supervised">Supervised</string>
-
-<!-- New -->
-<string name="role_aggregator">Aggregator</string>
-<string name="aggregator_description">Collects posture data from monitored persons</string>
-```
-
-Update any user-facing text that mentions "supervised user" to "aggregator".
-
-### 4. Update code comments and documentation
-
-Search and replace in codebase:
-- "supervised user" â†’ "aggregator"
-- "Supervised" â†’ "Aggregator" (in comments)
-
-Keep functional code backward compatible.
-
----
-
-## Files to Modify
-
-- [`RoleProvider.java`](../../app/src/main/java/com/melisa/innovamotionapp/utils/RoleProvider.java)
-- [`UserSession.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/UserSession.java)
-- `app/src/main/res/values/strings.xml`
-- Various code comments throughout the codebase
-
----
-
-## Acceptance Criteria
-
-- [ ] `Role.AGGREGATOR` enum added
-- [ ] `isAggregator()` method works
-- [ ] Old "supervised" role value still accepted (backward compatible)
-- [ ] UI shows "Aggregator" terminology
-- [ ] Code comments updated where appropriate
-- [ ] No breaking changes to existing functionality
+# TASK 12: Role Terminology Update (Supervised â†’ Aggregator)
+
+**Assigned To:** Any Developer (cleanup task)  
+**Estimated Effort:** 1 day  
+**Dependencies:** None (can be done last)  
+**Status:** Pending
+
+---
+
+## Context
+
+The specification renames "Supervised" role to "Aggregator" for clarity. The old name was confusing because supervised users aren't being supervised - they aggregate data from multiple monitored persons.
+
+---
+
+## Deliverables
+
+### 1. Update `RoleProvider.java`
+
+```java
+public enum Role { 
+    AGGREGATOR,   // NEW: Data collection role (formerly SUPERVISED)
+    SUPERVISOR, 
+    UNKNOWN,
+    
+    @Deprecated
+    SUPERVISED    // Keep for backward compatibility, maps to AGGREGATOR
+}
+
+public static Role getCurrentRole() {
+    String role = GlobalData.getInstance().currentUserRole;
+    if ("supervised".equalsIgnoreCase(role) || "aggregator".equalsIgnoreCase(role)) {
+        return Role.AGGREGATOR;
+    }
+    if ("supervisor".equalsIgnoreCase(role)) {
+        return Role.SUPERVISOR;
+    }
+    return Role.UNKNOWN;
+}
+
+public static boolean isAggregator() {
+    return getCurrentRole() == Role.AGGREGATOR;
+}
+
+@Deprecated
+public static boolean isSupervised() {
+    return isAggregator(); // Alias for backward compatibility
+}
+```
+
+### 2. Update Firestore user documents
+
+**Decision needed:** Use new role name or keep backward compatible?
+
+**Option A: Backward compatible (recommended)**
+- Accept both "supervised" and "aggregator" in code
+- New signups use "aggregator"
+- Existing users continue to work
+
+**Option B: Migration**
+- Run one-time Firestore migration script
+- Update all `role: "supervised"` to `role: "aggregator"`
+
+### 3. Update UI strings
+
+In `strings.xml`:
+
+```xml
+<!-- Old -->
+<string name="role_supervised">Supervised</string>
+
+<!-- New -->
+<string name="role_aggregator">Aggregator</string>
+<string name="aggregator_description">Collects posture data from monitored persons</string>
+```
+
+Update any user-facing text that mentions "supervised user" to "aggregator".
+
+### 4. Update code comments and documentation
+
+Search and replace in codebase:
+- "supervised user" â†’ "aggregator"
+- "Supervised" â†’ "Aggregator" (in comments)
+
+Keep functional code backward compatible.
+
+---
+
+## Files to Modify
+
+- [`RoleProvider.java`](../../app/src/main/java/com/melisa/innovamotionapp/utils/RoleProvider.java)
+- [`UserSession.java`](../../app/src/main/java/com/melisa/innovamotionapp/sync/UserSession.java)
+- `app/src/main/res/values/strings.xml`
+- Various code comments throughout the codebase
+
+---
+
+## Acceptance Criteria
+
+- [ ] `Role.AGGREGATOR` enum added
+- [ ] `isAggregator()` method works
+- [ ] Old "supervised" role value still accepted (backward compatible)
+- [ ] UI shows "Aggregator" terminology
+- [ ] Code comments updated where appropriate
+- [ ] No breaking changes to existing functionality
diff --git a/InnovaMotionApp/docs/tasks/13-constants.md b/InnovaMotionApp/docs/tasks/13-constants.md
index 3e68bb1..e564c18 100644
--- a/InnovaMotionApp/docs/tasks/13-constants.md
+++ b/InnovaMotionApp/docs/tasks/13-constants.md
@@ -1,124 +1,124 @@
-# TASK 13: Constants and Configuration Centralization
-
-**Assigned To:** Any Developer  
-**Estimated Effort:** 0.5 days  
-**Dependencies:** All other tasks (cleanup at end)  
-**Status:** Pending
-
----
-
-## Context
-
-Ensure all new constants are centralized and configurable. This enables easy tuning and consistent behavior across the app.
-
----
-
-## Deliverables
-
-### 1. Update `Constants.java`
-
-Add new protocol and configuration constants:
-
-```java
-public final class Constants {
-    // ... existing constants ...
-    
-    // ===== Multi-User Protocol =====
-    
-    /** Terminator line that marks end of a packet */
-    public static final String PACKET_TERMINATOR = "END_PACKET";
-    
-    /** Delimiter between sensor ID and hex code in packet lines */
-    public static final String SENSOR_ID_DELIMITER = ";";
-    
-    /** Maximum readings allowed per packet (safety limit) */
-    public static final int MAX_READINGS_PER_PACKET = 1000;
-    
-    // ===== UI Configuration =====
-    
-    /** Maximum messages to display in message log */
-    public static final int MESSAGE_LOG_MAX_ITEMS = 500;
-    
-    /** Threshold (ms) after which data is considered stale in dashboard */
-    public static final long STALE_DATA_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes
-    
-    /** Dashboard grid columns (phones) */
-    public static final int DASHBOARD_SPAN_COUNT_PHONE = 2;
-    
-    /** Dashboard grid columns (tablets) */
-    public static final int DASHBOARD_SPAN_COUNT_TABLET = 3;
-    
-    // ===== Sync Configuration =====
-    
-    /** Firestore whereIn query limit */
-    public static final int FIRESTORE_WHERE_IN_LIMIT = 10;
-    
-    /** WriteBatch document limit */
-    public static final int FIRESTORE_BATCH_LIMIT = 500;
-    
-    private Constants() {} // Prevent instantiation
-}
-```
-
-### 2. Create `FeatureFlags.java` (optional)
-
-For gradual rollout and A/B testing:
-
-```java
-public final class FeatureFlags {
-    
-    /** Enable multi-user packet protocol */
-    public static final boolean MULTI_USER_PROTOCOL_ENABLED = true;
-    
-    /** Enable new aggregator dashboard UI */
-    public static final boolean AGGREGATOR_DASHBOARD_ENABLED = true;
-    
-    /** Enable new supervisor multi-person dashboard */
-    public static final boolean SUPERVISOR_DASHBOARD_ENABLED = true;
-    
-    /** Use compound Firestore queries for supervisor */
-    public static final boolean COMPOUND_QUERIES_ENABLED = true;
-    
-    private FeatureFlags() {}
-}
-```
-
-Usage:
-```java
-if (FeatureFlags.MULTI_USER_PROTOCOL_ENABLED) {
-    // Use new packet parser
-} else {
-    // Fall back to legacy single-line handling
-}
-```
-
-### 3. Move any scattered magic numbers
-
-Search codebase for:
-- Hardcoded timeouts
-- Buffer sizes
-- Retry counts
-- UI dimensions
-
-Move to `Constants.java` with descriptive names.
-
----
-
-## Files to Modify
-
-- [`Constants.java`](../../app/src/main/java/com/melisa/innovamotionapp/utils/Constants.java)
-
-## Files to Create (optional)
-
-- `app/src/main/java/com/melisa/innovamotionapp/utils/FeatureFlags.java`
-
----
-
-## Acceptance Criteria
-
-- [ ] All protocol constants in Constants.java
-- [ ] All UI configuration values centralized
-- [ ] All sync configuration values centralized
-- [ ] No magic numbers scattered in code
-- [ ] FeatureFlags enables gradual rollout (optional)
-- [ ] Constants have descriptive Javadoc comments
+# TASK 13: Constants and Configuration Centralization
+
+**Assigned To:** Any Developer  
+**Estimated Effort:** 0.5 days  
+**Dependencies:** All other tasks (cleanup at end)  
+**Status:** Pending
+
+---
+
+## Context
+
+Ensure all new constants are centralized and configurable. This enables easy tuning and consistent behavior across the app.
+
+---
+
+## Deliverables
+
+### 1. Update `Constants.java`
+
+Add new protocol and configuration constants:
+
+```java
+public final class Constants {
+    // ... existing constants ...
+    
+    // ===== Multi-User Protocol =====
+    
+    /** Terminator line that marks end of a packet */
+    public static final String PACKET_TERMINATOR = "END_PACKET";
+    
+    /** Delimiter between sensor ID and hex code in packet lines */
+    public static final String SENSOR_ID_DELIMITER = ";";
+    
+    /** Maximum readings allowed per packet (safety limit) */
+    public static final int MAX_READINGS_PER_PACKET = 1000;
+    
+    // ===== UI Configuration =====
+    
+    /** Maximum messages to display in message log */
+    public static final int MESSAGE_LOG_MAX_ITEMS = 500;
+    
+    /** Threshold (ms) after which data is considered stale in dashboard */
+    public static final long STALE_DATA_THRESHOLD_MS = 5 * 60 * 1000; // 5 minutes
+    
+    /** Dashboard grid columns (phones) */
+    public static final int DASHBOARD_SPAN_COUNT_PHONE = 2;
+    
+    /** Dashboard grid columns (tablets) */
+    public static final int DASHBOARD_SPAN_COUNT_TABLET = 3;
+    
+    // ===== Sync Configuration =====
+    
+    /** Firestore whereIn query limit */
+    public static final int FIRESTORE_WHERE_IN_LIMIT = 10;
+    
+    /** WriteBatch document limit */
+    public static final int FIRESTORE_BATCH_LIMIT = 500;
+    
+    private Constants() {} // Prevent instantiation
+}
+```
+
+### 2. Create `FeatureFlags.java` (optional)
+
+For gradual rollout and A/B testing:
+
+```java
+public final class FeatureFlags {
+    
+    /** Enable multi-user packet protocol */
+    public static final boolean MULTI_USER_PROTOCOL_ENABLED = true;
+    
+    /** Enable new aggregator dashboard UI */
+    public static final boolean AGGREGATOR_DASHBOARD_ENABLED = true;
+    
+    /** Enable new supervisor multi-person dashboard */
+    public static final boolean SUPERVISOR_DASHBOARD_ENABLED = true;
+    
+    /** Use compound Firestore queries for supervisor */
+    public static final boolean COMPOUND_QUERIES_ENABLED = true;
+    
+    private FeatureFlags() {}
+}
+```
+
+Usage:
+```java
+if (FeatureFlags.MULTI_USER_PROTOCOL_ENABLED) {
+    // Use new packet parser
+} else {
+    // Fall back to legacy single-line handling
+}
+```
+
+### 3. Move any scattered magic numbers
+
+Search codebase for:
+- Hardcoded timeouts
+- Buffer sizes
+- Retry counts
+- UI dimensions
+
+Move to `Constants.java` with descriptive names.
+
+---
+
+## Files to Modify
+
+- [`Constants.java`](../../app/src/main/java/com/melisa/innovamotionapp/utils/Constants.java)
+
+## Files to Create (optional)
+
+- `app/src/main/java/com/melisa/innovamotionapp/utils/FeatureFlags.java`
+
+---
+
+## Acceptance Criteria
+
+- [ ] All protocol constants in Constants.java
+- [ ] All UI configuration values centralized
+- [ ] All sync configuration values centralized
+- [ ] No magic numbers scattered in code
+- [ ] FeatureFlags enables gradual rollout (optional)
+- [ ] Constants have descriptive Javadoc comments
diff --git a/InnovaMotionApp/gradle.properties b/InnovaMotionApp/gradle.properties
index 4387edc..f9c348f 100644
--- a/InnovaMotionApp/gradle.properties
+++ b/InnovaMotionApp/gradle.properties
@@ -1,21 +1,21 @@
-# Project-wide Gradle settings.
-# IDE (e.g. Android Studio) users:
-# Gradle settings configured through the IDE *will override*
-# any settings specified in this file.
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. For more details, visit
-# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
-# org.gradle.parallel=true
-# AndroidX package structure to make it clearer which packages are bundled with the
-# Android operating system, and which are packaged with your app's APK
-# https://developer.android.com/topic/libraries/support-library/androidx-rn
-android.useAndroidX=true
-# Enables namespacing of each library's R class so that its R class includes only the
-# resources declared in the library itself and none from the library's dependencies,
-# thereby reducing the size of the R class for that library
+# Project-wide Gradle settings.
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. For more details, visit
+# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
+# org.gradle.parallel=true
+# AndroidX package structure to make it clearer which packages are bundled with the
+# Android operating system, and which are packaged with your app's APK
+# https://developer.android.com/topic/libraries/support-library/androidx-rn
+android.useAndroidX=true
+# Enables namespacing of each library's R class so that its R class includes only the
+# resources declared in the library itself and none from the library's dependencies,
+# thereby reducing the size of the R class for that library
 android.nonTransitiveRClass=true
\ No newline at end of file
diff --git a/InnovaMotionApp/gradle/libs.versions.toml b/InnovaMotionApp/gradle/libs.versions.toml
index fdbadce..975fa86 100644
--- a/InnovaMotionApp/gradle/libs.versions.toml
+++ b/InnovaMotionApp/gradle/libs.versions.toml
@@ -1,58 +1,58 @@
-[versions]
-agp = "8.8.2"
-junit = "4.13.2"
-junitVersion = "1.3.0"
-espressoCore = "3.7.0"
-appcompat = "1.7.1"
-material = "1.12.0"
-activity = "1.9.2"
-constraintlayout = "2.2.1"
-mpandroidchart = "3.1.0"
-navigationFragment = "2.9.3"
-navigationUi = "2.9.3"
-annotation = "1.8.2"
-lifecycleLivedataKtx = "2.9.2"
-lifecycleViewmodelKtx = "2.9.2"
-roomRuntime = "2.7.0-alpha12"
-materialVersion = "1.13.0-alpha09"
-roomCompilerVersion = "2.7.0-alpha12"
-googleGmsGoogleServices = "4.4.3"
-credentials = "1.5.0"
-credentialsPlayServicesAuth = "1.5.0"
-googleid = "1.1.1"
-firebaseAuth = "24.0.1"
-firebaseDatabase = "21.0.0"
-firebaseBom = "34.1.0"
-recyclerview = "1.4.0"
-swiperefreshlayout = "1.1.0"
-
-[libraries]
-googleid = { module = "com.google.android.libraries.identity.googleid:googleid", version.ref = "googleid" }
-junit = { group = "junit", name = "junit", version.ref = "junit" }
-ext-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
-appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
-material = { group = "com.google.android.material", name = "material", version.ref = "material" }
-activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
-constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
-mpandroidchart = { module = "com.github.PhilJay:MPAndroidChart", version.ref = "mpandroidchart" }
-navigation-fragment = { group = "androidx.navigation", name = "navigation-fragment", version.ref = "navigationFragment" }
-navigation-ui = { group = "androidx.navigation", name = "navigation-ui", version.ref = "navigationUi" }
-annotation = { group = "androidx.annotation", name = "annotation", version.ref = "annotation" }
-lifecycle-livedata-ktx = { group = "androidx.lifecycle", name = "lifecycle-livedata-ktx", version.ref = "lifecycleLivedataKtx" }
-lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleViewmodelKtx" }
-room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "roomRuntime" }
-google-material = { group = "com.google.android.material", name = "material", version.ref = "materialVersion" }
-androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "roomCompilerVersion" }
-firebase-auth = { group = "com.google.firebase", name = "firebase-auth", version.ref = "firebaseAuth" }
-firebase-database = { group = "com.google.firebase", name = "firebase-database", version.ref = "firebaseDatabase" }
-credentials = { group = "androidx.credentials", name = "credentials", version.ref = "credentials" }
-credentials-play-services-auth = { group = "androidx.credentials", name = "credentials-play-services-auth", version.ref = "credentialsPlayServicesAuth" }
-firebase-bom = { module = "com.google.firebase:firebase-bom", version.ref = "firebaseBom" }
-firebase-firestore = { group = "com.google.firebase", name = "firebase-firestore" }
-recyclerview = { group = "androidx.recyclerview", name = "recyclerview", version.ref = "recyclerview" }
-swiperefreshlayout = { group = "androidx.swiperefreshlayout", name = "swiperefreshlayout", version.ref = "swiperefreshlayout" }
-
-[plugins]
-android-application = { id = "com.android.application", version.ref = "agp" }
+[versions]
+agp = "8.8.2"
+junit = "4.13.2"
+junitVersion = "1.3.0"
+espressoCore = "3.7.0"
+appcompat = "1.7.1"
+material = "1.12.0"
+activity = "1.9.2"
+constraintlayout = "2.2.1"
+mpandroidchart = "3.1.0"
+navigationFragment = "2.9.3"
+navigationUi = "2.9.3"
+annotation = "1.8.2"
+lifecycleLivedataKtx = "2.9.2"
+lifecycleViewmodelKtx = "2.9.2"
+roomRuntime = "2.7.0-alpha12"
+materialVersion = "1.13.0-alpha09"
+roomCompilerVersion = "2.7.0-alpha12"
+googleGmsGoogleServices = "4.4.3"
+credentials = "1.5.0"
+credentialsPlayServicesAuth = "1.5.0"
+googleid = "1.1.1"
+firebaseAuth = "24.0.1"
+firebaseDatabase = "21.0.0"
+firebaseBom = "34.1.0"
+recyclerview = "1.4.0"
+swiperefreshlayout = "1.1.0"
+
+[libraries]
+googleid = { module = "com.google.android.libraries.identity.googleid:googleid", version.ref = "googleid" }
+junit = { group = "junit", name = "junit", version.ref = "junit" }
+ext-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
+espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
+appcompat = { group = "androidx.appcompat", name = "appcompat", version.ref = "appcompat" }
+material = { group = "com.google.android.material", name = "material", version.ref = "material" }
+activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
+constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
+mpandroidchart = { module = "com.github.PhilJay:MPAndroidChart", version.ref = "mpandroidchart" }
+navigation-fragment = { group = "androidx.navigation", name = "navigation-fragment", version.ref = "navigationFragment" }
+navigation-ui = { group = "androidx.navigation", name = "navigation-ui", version.ref = "navigationUi" }
+annotation = { group = "androidx.annotation", name = "annotation", version.ref = "annotation" }
+lifecycle-livedata-ktx = { group = "androidx.lifecycle", name = "lifecycle-livedata-ktx", version.ref = "lifecycleLivedataKtx" }
+lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleViewmodelKtx" }
+room-runtime = { group = "androidx.room", name = "room-runtime", version.ref = "roomRuntime" }
+google-material = { group = "com.google.android.material", name = "material", version.ref = "materialVersion" }
+androidx-room-compiler = { group = "androidx.room", name = "room-compiler", version.ref = "roomCompilerVersion" }
+firebase-auth = { group = "com.google.firebase", name = "firebase-auth", version.ref = "firebaseAuth" }
+firebase-database = { group = "com.google.firebase", name = "firebase-database", version.ref = "firebaseDatabase" }
+credentials = { group = "androidx.credentials", name = "credentials", version.ref = "credentials" }
+credentials-play-services-auth = { group = "androidx.credentials", name = "credentials-play-services-auth", version.ref = "credentialsPlayServicesAuth" }
+firebase-bom = { module = "com.google.firebase:firebase-bom", version.ref = "firebaseBom" }
+firebase-firestore = { group = "com.google.firebase", name = "firebase-firestore" }
+recyclerview = { group = "androidx.recyclerview", name = "recyclerview", version.ref = "recyclerview" }
+swiperefreshlayout = { group = "androidx.swiperefreshlayout", name = "swiperefreshlayout", version.ref = "swiperefreshlayout" }
+
+[plugins]
+android-application = { id = "com.android.application", version.ref = "agp" }
 google-gms-google-services = { id = "com.google.gms.google-services", version.ref = "googleGmsGoogleServices" }
\ No newline at end of file
diff --git a/InnovaMotionApp/gradle/wrapper/gradle-wrapper.properties b/InnovaMotionApp/gradle/wrapper/gradle-wrapper.properties
index 2676e1b..a504527 100644
--- a/InnovaMotionApp/gradle/wrapper/gradle-wrapper.properties
+++ b/InnovaMotionApp/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sun Aug 10 20:55:06 EEST 2025
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
+#Sun Aug 10 20:55:06 EEST 2025
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/InnovaMotionApp/gradlew.bat b/InnovaMotionApp/gradlew.bat
index 107acd3..ac1b06f 100644
--- a/InnovaMotionApp/gradlew.bat
+++ b/InnovaMotionApp/gradlew.bat
@@ -1,89 +1,89 @@
-@rem
-@rem Copyright 2015 the original author or authors.
-@rem
-@rem Licensed under the Apache License, Version 2.0 (the "License");
-@rem you may not use this file except in compliance with the License.
-@rem You may obtain a copy of the License at
-@rem
-@rem      https://www.apache.org/licenses/LICENSE-2.0
-@rem
-@rem Unless required by applicable law or agreed to in writing, software
-@rem distributed under the License is distributed on an "AS IS" BASIS,
-@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@rem See the License for the specific language governing permissions and
-@rem limitations under the License.
-@rem
-
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Resolve any "." and ".." in APP_HOME to make it shorter.
-for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto execute
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto execute
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/InnovaMotionApp/settings.gradle.kts b/InnovaMotionApp/settings.gradle.kts
index 258b77c..bc93e68 100644
--- a/InnovaMotionApp/settings.gradle.kts
+++ b/InnovaMotionApp/settings.gradle.kts
@@ -1,26 +1,26 @@
-pluginManagement {
-    repositories {
-        google {
-            content {
-                includeGroupByRegex("com\\.github.*")
-                includeGroupByRegex("com\\.android.*")
-                includeGroupByRegex("com\\.google.*")
-                includeGroupByRegex("androidx.*")
-            }
-        }
-        mavenCentral()
-        gradlePluginPortal()
-    }
-}
-dependencyResolutionManagement {
-    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
-    repositories {
-        google()
-        mavenCentral()
-        maven(url = "https://jitpack.io")
-    }
-}
-
-rootProject.name = "InnovaMotionApp"
-include(":app")
+pluginManagement {
+    repositories {
+        google {
+            content {
+                includeGroupByRegex("com\\.github.*")
+                includeGroupByRegex("com\\.android.*")
+                includeGroupByRegex("com\\.google.*")
+                includeGroupByRegex("androidx.*")
+            }
+        }
+        mavenCentral()
+        gradlePluginPortal()
+    }
+}
+dependencyResolutionManagement {
+    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+    repositories {
+        google()
+        mavenCentral()
+        maven(url = "https://jitpack.io")
+    }
+}
+
+rootProject.name = "InnovaMotionApp"
+include(":app")
  
\ No newline at end of file
diff --git a/_old_Pedonovation/.gitignore b/_old_Pedonovation/.gitignore
index 8cacfbd..e0a659e 100644
--- a/_old_Pedonovation/.gitignore
+++ b/_old_Pedonovation/.gitignore
@@ -1,10 +1,10 @@
-*.iml
-.gradle
-.idea
-/local.properties
-.DS_Store
-/build
-/captures
-.externalNativeBuild
-.cxx
-local.properties
+*.iml
+.gradle
+.idea
+/local.properties
+.DS_Store
+/build
+/captures
+.externalNativeBuild
+.cxx
+local.properties
diff --git a/_old_Pedonovation/app/build.gradle.kts b/_old_Pedonovation/app/build.gradle.kts
index cc02f98..80be972 100644
--- a/_old_Pedonovation/app/build.gradle.kts
+++ b/_old_Pedonovation/app/build.gradle.kts
@@ -1,58 +1,58 @@
-plugins {
-    alias(libs.plugins.android.application)
-}
-
-android {
-    namespace = "com.melisa.pedonovation"
-    compileSdk = 34
-
-    defaultConfig {
-        applicationId = "com.melisa.pedonovation"
-        minSdk = 26
-        targetSdk = 34
-        versionCode = 1
-        versionName = "1.0"
-
-        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
-        externalNativeBuild {
-            cmake {
-                cppFlags += "-std=c++11"
-            }
-        }
-    }
-
-    buildTypes {
-        release {
-            isMinifyEnabled = false
-            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
-        }
-    }
-    compileOptions {
-        sourceCompatibility = JavaVersion.VERSION_1_8
-        targetCompatibility = JavaVersion.VERSION_1_8
-    }
-    externalNativeBuild {
-        cmake {
-            path = file("src/main/cpp/CMakeLists.txt")
-            version = "3.22.1"
-        }
-    }
-    buildFeatures {
-        viewBinding = true
-    }
-}
-
-dependencies {
-
-    implementation(libs.appcompat)
-    implementation(libs.material)
-    implementation(libs.constraintlayout)
-    implementation(libs.graphview)
-    implementation(libs.activity)
-    implementation(libs.annotation)
-    implementation(libs.lifecycle.livedata.ktx)
-    implementation(libs.lifecycle.viewmodel.ktx)
-    testImplementation(libs.junit)
-    androidTestImplementation(libs.ext.junit)
-    androidTestImplementation(libs.espresso.core)
+plugins {
+    alias(libs.plugins.android.application)
+}
+
+android {
+    namespace = "com.melisa.pedonovation"
+    compileSdk = 34
+
+    defaultConfig {
+        applicationId = "com.melisa.pedonovation"
+        minSdk = 26
+        targetSdk = 34
+        versionCode = 1
+        versionName = "1.0"
+
+        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
+        externalNativeBuild {
+            cmake {
+                cppFlags += "-std=c++11"
+            }
+        }
+    }
+
+    buildTypes {
+        release {
+            isMinifyEnabled = false
+            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
+        }
+    }
+    compileOptions {
+        sourceCompatibility = JavaVersion.VERSION_1_8
+        targetCompatibility = JavaVersion.VERSION_1_8
+    }
+    externalNativeBuild {
+        cmake {
+            path = file("src/main/cpp/CMakeLists.txt")
+            version = "3.22.1"
+        }
+    }
+    buildFeatures {
+        viewBinding = true
+    }
+}
+
+dependencies {
+
+    implementation(libs.appcompat)
+    implementation(libs.material)
+    implementation(libs.constraintlayout)
+    implementation(libs.graphview)
+    implementation(libs.activity)
+    implementation(libs.annotation)
+    implementation(libs.lifecycle.livedata.ktx)
+    implementation(libs.lifecycle.viewmodel.ktx)
+    testImplementation(libs.junit)
+    androidTestImplementation(libs.ext.junit)
+    androidTestImplementation(libs.espresso.core)
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/proguard-rules.pro b/_old_Pedonovation/app/proguard-rules.pro
index 481bb43..64b4a05 100644
--- a/_old_Pedonovation/app/proguard-rules.pro
+++ b/_old_Pedonovation/app/proguard-rules.pro
@@ -1,21 +1,21 @@
-# Add project specific ProGuard rules here.
-# You can control the set of applied configuration files using the
-# proguardFiles setting in build.gradle.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
-
-# Uncomment this to preserve the line number information for
-# debugging stack traces.
-#-keepattributes SourceFile,LineNumberTable
-
-# If you keep the line number information, uncomment this to
-# hide the original source file name.
+# Add project specific ProGuard rules here.
+# You can control the set of applied configuration files using the
+# proguardFiles setting in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
+
+# Uncomment this to preserve the line number information for
+# debugging stack traces.
+#-keepattributes SourceFile,LineNumberTable
+
+# If you keep the line number information, uncomment this to
+# hide the original source file name.
 #-renamesourcefileattribute SourceFile
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/androidTest/java/com/melisa/pedonovation/ExampleInstrumentedTest.java b/_old_Pedonovation/app/src/androidTest/java/com/melisa/pedonovation/ExampleInstrumentedTest.java
index b23a1ca..286961a 100644
--- a/_old_Pedonovation/app/src/androidTest/java/com/melisa/pedonovation/ExampleInstrumentedTest.java
+++ b/_old_Pedonovation/app/src/androidTest/java/com/melisa/pedonovation/ExampleInstrumentedTest.java
@@ -1,21 +1,21 @@
-package com.melisa.pedonovation;
-
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/**
- * Instrumented test, which will execute on an Android device.
- *
- * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
- */
-@RunWith(AndroidJUnit4.class)
-public class ExampleInstrumentedTest {
-    @Test
-    public void useAppContext() {
-        // Context of the app under test.
-//        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
-//        assertEquals("com.melisa.myapplicationsc", appContext.getPackageName());
-    }
+package com.melisa.pedonovation;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() {
+        // Context of the app under test.
+//        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+//        assertEquals("com.melisa.myapplicationsc", appContext.getPackageName());
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/AndroidManifest.xml b/_old_Pedonovation/app/src/main/AndroidManifest.xml
index e99cabd..66dd140 100644
--- a/_old_Pedonovation/app/src/main/AndroidManifest.xml
+++ b/_old_Pedonovation/app/src/main/AndroidManifest.xml
@@ -1,62 +1,62 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools">
-
-    <uses-permission android:name="android.permission.BLUETOOTH" />
-    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
-    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
-    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
-    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
-    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
-
-    <uses-feature
-        android:name="android.hardware.bluetooth"
-        android:required="true" />
-
-    <application
-        android:name=".GlobalData"
-        android:allowBackup="true"
-        android:dataExtractionRules="@xml/data_extraction_rules"
-        android:fullBackupContent="@xml/backup_rules"
-        android:icon="@mipmap/ic_launcher"
-        android:label="@string/app_name"
-        android:roundIcon="@mipmap/ic_launcher_round"
-        android:supportsRtl="true"
-        android:theme="@style/Theme.PedometricSole"
-        tools:targetApi="31">
-        <activity
-            android:name=".AppActivities.LoginActivity"
-            android:exported="false" />
-        <activity
-            android:name=".ui.login.LoginActivity"
-            android:exported="false"
-            android:label="@string/title_activity_login" />
-        <activity
-            android:name=".AppActivities.StartActivity"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-        <activity
-            android:name=".AppActivities.GraphActivity"
-            android:exported="false"
-            android:parentActivityName=".AppActivities.MainActivity" />
-        <activity
-            android:name=".AppActivities.BtSettingsActivity"
-            android:exported="false"
-            android:parentActivityName=".AppActivities.MainActivity" />
-        <activity
-            android:name=".AppActivities.MainActivity"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="android.intent.action.MAIN" />
-
-                <category android:name="android.intent.category.LAUNCHER" />
-            </intent-filter>
-        </activity>
-    </application>
-
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools">
+
+    <uses-permission android:name="android.permission.BLUETOOTH" />
+    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
+    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
+    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
+
+    <uses-feature
+        android:name="android.hardware.bluetooth"
+        android:required="true" />
+
+    <application
+        android:name=".GlobalData"
+        android:allowBackup="true"
+        android:dataExtractionRules="@xml/data_extraction_rules"
+        android:fullBackupContent="@xml/backup_rules"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:roundIcon="@mipmap/ic_launcher_round"
+        android:supportsRtl="true"
+        android:theme="@style/Theme.PedometricSole"
+        tools:targetApi="31">
+        <activity
+            android:name=".AppActivities.LoginActivity"
+            android:exported="false" />
+        <activity
+            android:name=".ui.login.LoginActivity"
+            android:exported="false"
+            android:label="@string/title_activity_login" />
+        <activity
+            android:name=".AppActivities.StartActivity"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity
+            android:name=".AppActivities.GraphActivity"
+            android:exported="false"
+            android:parentActivityName=".AppActivities.MainActivity" />
+        <activity
+            android:name=".AppActivities.BtSettingsActivity"
+            android:exported="false"
+            android:parentActivityName=".AppActivities.MainActivity" />
+        <activity
+            android:name=".AppActivities.MainActivity"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+
 </manifest>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/cpp/CMakeLists.txt b/_old_Pedonovation/app/src/main/cpp/CMakeLists.txt
index eac6f53..de000a7 100644
--- a/_old_Pedonovation/app/src/main/cpp/CMakeLists.txt
+++ b/_old_Pedonovation/app/src/main/cpp/CMakeLists.txt
@@ -1,37 +1,37 @@
-# For more information about using CMake with Android Studio, read the
-# documentation: https://d.android.com/studio/projects/add-native-code.html.
-# For more examples on how to use CMake, see https://github.com/android/ndk-samples.
-
-# Sets the minimum CMake version required for this project.
-cmake_minimum_required(VERSION 3.22.1)
-
-# Declares the project name. The project name can be accessed via ${ PROJECT_NAME},
-# Since this is the top level CMakeLists.txt, the project name is also accessible
-# with ${CMAKE_PROJECT_NAME} (both CMake variables are in-sync within the top level
-# build script scope).
-project("app")
-
-# Creates and names a library, sets it as either STATIC
-# or SHARED, and provides the relative paths to its source code.
-# You can define multiple libraries, and CMake builds them for you.
-# Gradle automatically packages shared libraries with your APK.
-#
-# In this top level CMakeLists.txt, ${CMAKE_PROJECT_NAME} is used to define
-# the target library name; in the sub-module's CMakeLists.txt, ${PROJECT_NAME}
-# is preferred for the same purpose.
-#
-# In order to load a library into your app from Java/Kotlin, you must call
-# System.loadLibrary() and pass the name of the library defined here;
-# for GameActivity/NativeActivity derived applications, the same library name must be
-# used in the AndroidManifest.xml file.
-add_library(${CMAKE_PROJECT_NAME} SHARED
-        # List C/C++ source files with relative paths to this CMakeLists.txt.
-        native-lib.cpp)
-
-# Specifies libraries CMake should link to your target library. You
-# can link libraries from various origins, such as libraries defined in this
-# build script, prebuilt third-party libraries, or Android system libraries.
-target_link_libraries(${CMAKE_PROJECT_NAME}
-        # List libraries link to the target library
-        android
+# For more information about using CMake with Android Studio, read the
+# documentation: https://d.android.com/studio/projects/add-native-code.html.
+# For more examples on how to use CMake, see https://github.com/android/ndk-samples.
+
+# Sets the minimum CMake version required for this project.
+cmake_minimum_required(VERSION 3.22.1)
+
+# Declares the project name. The project name can be accessed via ${ PROJECT_NAME},
+# Since this is the top level CMakeLists.txt, the project name is also accessible
+# with ${CMAKE_PROJECT_NAME} (both CMake variables are in-sync within the top level
+# build script scope).
+project("app")
+
+# Creates and names a library, sets it as either STATIC
+# or SHARED, and provides the relative paths to its source code.
+# You can define multiple libraries, and CMake builds them for you.
+# Gradle automatically packages shared libraries with your APK.
+#
+# In this top level CMakeLists.txt, ${CMAKE_PROJECT_NAME} is used to define
+# the target library name; in the sub-module's CMakeLists.txt, ${PROJECT_NAME}
+# is preferred for the same purpose.
+#
+# In order to load a library into your app from Java/Kotlin, you must call
+# System.loadLibrary() and pass the name of the library defined here;
+# for GameActivity/NativeActivity derived applications, the same library name must be
+# used in the AndroidManifest.xml file.
+add_library(${CMAKE_PROJECT_NAME} SHARED
+        # List C/C++ source files with relative paths to this CMakeLists.txt.
+        native-lib.cpp)
+
+# Specifies libraries CMake should link to your target library. You
+# can link libraries from various origins, such as libraries defined in this
+# build script, prebuilt third-party libraries, or Android system libraries.
+target_link_libraries(${CMAKE_PROJECT_NAME}
+        # List libraries link to the target library
+        android
         log)
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/cpp/native-lib.cpp b/_old_Pedonovation/app/src/main/cpp/native-lib.cpp
index 38bc322..196ff91 100644
--- a/_old_Pedonovation/app/src/main/cpp/native-lib.cpp
+++ b/_old_Pedonovation/app/src/main/cpp/native-lib.cpp
@@ -1,10 +1,10 @@
-#include <jni.h>
-#include <string>
-
-extern "C" JNIEXPORT jstring JNICALL
-Java_com_melisa_myapplicationsc_MainActivity_stringFromJNI(
-        JNIEnv* env,
-        jobject /* this */) {
-    std::string hello = "Hello from C++";
-    return env->NewStringUTF(hello.c_str());
+#include <jni.h>
+#include <string>
+
+extern "C" JNIEXPORT jstring JNICALL
+Java_com_melisa_myapplicationsc_MainActivity_stringFromJNI(
+        JNIEnv* env,
+        jobject /* this */) {
+    std::string hello = "Hello from C++";
+    return env->NewStringUTF(hello.c_str());
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/BtSettingsActivity.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/BtSettingsActivity.java
index 93be6e5..5a4efb7 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/BtSettingsActivity.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/BtSettingsActivity.java
@@ -1,68 +1,68 @@
-package com.melisa.pedonovation.AppActivities;
-
-import android.os.Bundle;
-
-import androidx.appcompat.app.AppCompatActivity;
-
-import com.melisa.pedonovation.BluetoothCore.BluetoothHelper;
-import com.melisa.pedonovation.BluetoothCore.Receivers.BluetoothStateReceiver;
-import com.melisa.pedonovation.BluetoothCore.Receivers.DiscoverReceiver;
-import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
-import com.melisa.pedonovation.GlobalData;
-import com.melisa.pedonovation.databinding.ActivityBtsettingsBinding;
-
-public class BtSettingsActivity extends AppCompatActivity {
-
-
-    public ActivityBtsettingsBinding binding;
-    private BtSettingsManager btSettingsManager;
-    private BluetoothHelper bluetoothHelper;
-    private GlobalData globalData;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        binding = ActivityBtsettingsBinding.inflate(getLayoutInflater());
-        setContentView(binding.getRoot());
-
-        // Retrieve the BluetoothHelper instance from the global application context
-        globalData = ((GlobalData) this.getApplicationContext());
-
-        bluetoothHelper = new BluetoothHelper(this);
-
-        BluetoothStateReceiver bluetoothStateReceiver = new BluetoothStateReceiver(btSettingsManager);
-
-        btSettingsManager = new BtSettingsManager(this, bluetoothHelper, globalData);
-
-        DiscoverReceiver discoverReceiver = new DiscoverReceiver(btSettingsManager);
-        bluetoothHelper.bluetoothStateReceiver = bluetoothStateReceiver;
-        bluetoothHelper.discoverReceiver = discoverReceiver;
-        bluetoothHelper.setLogger(btSettingsManager);
-
-    }
-
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        bluetoothHelper.registerReceivers(this);
-
-
-        // Change the manager to btSettingsManager that handles the Thread messages
-        globalData.setActivityManagerForHandler(btSettingsManager);
-
-        // Update inApp bluetooth state
-        btSettingsManager.updateBluetoothUI();
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        bluetoothHelper.unregisterReceivers(this);
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-    }
-}
+package com.melisa.pedonovation.AppActivities;
+
+import android.os.Bundle;
+
+import androidx.appcompat.app.AppCompatActivity;
+
+import com.melisa.pedonovation.BluetoothCore.BluetoothHelper;
+import com.melisa.pedonovation.BluetoothCore.Receivers.BluetoothStateReceiver;
+import com.melisa.pedonovation.BluetoothCore.Receivers.DiscoverReceiver;
+import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
+import com.melisa.pedonovation.GlobalData;
+import com.melisa.pedonovation.databinding.ActivityBtsettingsBinding;
+
+public class BtSettingsActivity extends AppCompatActivity {
+
+
+    public ActivityBtsettingsBinding binding;
+    private BtSettingsManager btSettingsManager;
+    private BluetoothHelper bluetoothHelper;
+    private GlobalData globalData;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        binding = ActivityBtsettingsBinding.inflate(getLayoutInflater());
+        setContentView(binding.getRoot());
+
+        // Retrieve the BluetoothHelper instance from the global application context
+        globalData = ((GlobalData) this.getApplicationContext());
+
+        bluetoothHelper = new BluetoothHelper(this);
+
+        BluetoothStateReceiver bluetoothStateReceiver = new BluetoothStateReceiver(btSettingsManager);
+
+        btSettingsManager = new BtSettingsManager(this, bluetoothHelper, globalData);
+
+        DiscoverReceiver discoverReceiver = new DiscoverReceiver(btSettingsManager);
+        bluetoothHelper.bluetoothStateReceiver = bluetoothStateReceiver;
+        bluetoothHelper.discoverReceiver = discoverReceiver;
+        bluetoothHelper.setLogger(btSettingsManager);
+
+    }
+
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        bluetoothHelper.registerReceivers(this);
+
+
+        // Change the manager to btSettingsManager that handles the Thread messages
+        globalData.setActivityManagerForHandler(btSettingsManager);
+
+        // Update inApp bluetooth state
+        btSettingsManager.updateBluetoothUI();
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        bluetoothHelper.unregisterReceivers(this);
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+    }
+}
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/LoginActivity.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/LoginActivity.java
index 5e6c899..7a477b6 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/LoginActivity.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/LoginActivity.java
@@ -1,26 +1,26 @@
-package com.melisa.pedonovation.AppActivities;
-
-import android.os.Bundle;
-
-import androidx.activity.EdgeToEdge;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.core.graphics.Insets;
-import androidx.core.view.ViewCompat;
-import androidx.core.view.WindowInsetsCompat;
-
-import com.melisa.pedonovation.R;
-
-public class LoginActivity extends AppCompatActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        EdgeToEdge.enable(this);
-        setContentView(R.layout.activity_login);
-        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
-            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
-            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
-            return insets;
-        });
-    }
+package com.melisa.pedonovation.AppActivities;
+
+import android.os.Bundle;
+
+import androidx.activity.EdgeToEdge;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.graphics.Insets;
+import androidx.core.view.ViewCompat;
+import androidx.core.view.WindowInsetsCompat;
+
+import com.melisa.pedonovation.R;
+
+public class LoginActivity extends AppCompatActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        EdgeToEdge.enable(this);
+        setContentView(R.layout.activity_login);
+        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
+            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
+            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
+            return insets;
+        });
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/MainActivity.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/MainActivity.java
index dd798e8..f2ed87a 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/MainActivity.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/MainActivity.java
@@ -1,60 +1,60 @@
-package com.melisa.pedonovation.AppActivities;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.appcompat.app.AppCompatDelegate;
-
-import com.melisa.pedonovation.GlobalData;
-import com.melisa.pedonovation.databinding.ActivityMainBinding;
-
-public class MainActivity extends AppCompatActivity {
-
-    // Binding object for accessing views in activity_main.xml
-    public ActivityMainBinding binding;
-
-    private GlobalData globalData;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        // Inflate the layout using view binding
-        binding = ActivityMainBinding.inflate(getLayoutInflater());
-        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);
-        // Set the content view to the root of the binding
-        setContentView(binding.getRoot());
-
-        globalData = ((GlobalData) this.getApplicationContext());
-
-    }
-
-
-    // Launches the BtSettingsActivity when called
-    public void LaunchSettings(View view) {
-        Intent i = new Intent(this, BtSettingsActivity.class);
-        startActivity(i);
-    }
-
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        // Change the manager to mainManager that handles the Thread messages
-       // globalData.setActivityManagerForHandler(mainManager);
-
-        // Update Main UI elements
-        //mainManager.updateUI();
-    }
-
-    public void startCommand(View view) {
-        String startMsg = "s";
-        globalData.connectionData1.connectionThread.write(startMsg.getBytes());
-        globalData.connectionData2.connectionThread.write(startMsg.getBytes());
-    }
-
-}
-
+package com.melisa.pedonovation.AppActivities;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.appcompat.app.AppCompatDelegate;
+
+import com.melisa.pedonovation.GlobalData;
+import com.melisa.pedonovation.databinding.ActivityMainBinding;
+
+public class MainActivity extends AppCompatActivity {
+
+    // Binding object for accessing views in activity_main.xml
+    public ActivityMainBinding binding;
+
+    private GlobalData globalData;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Inflate the layout using view binding
+        binding = ActivityMainBinding.inflate(getLayoutInflater());
+        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO);
+        // Set the content view to the root of the binding
+        setContentView(binding.getRoot());
+
+        globalData = ((GlobalData) this.getApplicationContext());
+
+    }
+
+
+    // Launches the BtSettingsActivity when called
+    public void LaunchSettings(View view) {
+        Intent i = new Intent(this, BtSettingsActivity.class);
+        startActivity(i);
+    }
+
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        // Change the manager to mainManager that handles the Thread messages
+       // globalData.setActivityManagerForHandler(mainManager);
+
+        // Update Main UI elements
+        //mainManager.updateUI();
+    }
+
+    public void startCommand(View view) {
+        String startMsg = "s";
+        globalData.connectionData1.connectionThread.write(startMsg.getBytes());
+        globalData.connectionData2.connectionThread.write(startMsg.getBytes());
+    }
+
+}
+
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/Managers/BtSettingsManager.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/Managers/BtSettingsManager.java
index 65687fd..6b5bad6 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/Managers/BtSettingsManager.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/Managers/BtSettingsManager.java
@@ -1,285 +1,285 @@
-package com.melisa.pedonovation.AppActivities.Managers;
-
-import static android.content.ContentValues.TAG;
-import static com.melisa.pedonovation.Utilities.setVisibility;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.content.DialogInterface;
-import android.util.ArraySet;
-import android.util.Log;
-import android.view.View;
-import android.widget.Button;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import androidx.appcompat.app.AlertDialog;
-
-import com.melisa.pedonovation.AppActivities.BtSettingsActivity;
-//import com.melisa.pedonovation.BluetoothCore.BluetoothDeviceReceivedData;
-import com.melisa.pedonovation.BluetoothCore.BluetoothHelper;
-import com.melisa.pedonovation.BluetoothCore.ConnectionData;
-import com.melisa.pedonovation.BluetoothCore.ConnectionThread;
-import com.melisa.pedonovation.BluetoothCore.DeviceListAdapter;
-import com.melisa.pedonovation.GlobalData;
-import com.melisa.pedonovation.Interfaces.ICurrentActivityManager;
-import com.melisa.pedonovation.R;
-import com.melisa.pedonovation.Interfaces.UILogger;
-
-import java.util.ArrayList;
-import java.util.Objects;
-import java.util.Set;
-
-public class BtSettingsManager implements UILogger, ICurrentActivityManager {
-    private final BtSettingsActivity activity;
-    private final BluetoothHelper bluetoothHelper;
-    private final TextView bluetoothStatusTv, device1Tv, device2Tv;
-    private final Button btnTurnOnBluetooth, btnDevice1, btnDevice2, btnScanDevices;
-    public final ListView unconnectedLv;
-    public ArraySet<BluetoothDevice> nearbyBtDevices = new ArraySet<>();
-    public GlobalData globalData;
-    public DeviceListAdapter mDeviceListAdapter;
-
-    private final String BT_STATUS_NOT_SUPPORTED_TEXT = "Bluetooth not supported";
-    private final String BT_STATUS_ON_TEXT = "Bluetooth Status: On";
-    private final String BT_STATUS_OFF_TEXT = "Bluetooth Status: Off";
-
-    public BtSettingsManager(BtSettingsActivity activity, BluetoothHelper bluetoothHelper, GlobalData globalData) {
-        this.activity = activity;
-        this.bluetoothHelper = bluetoothHelper;
-
-        bluetoothStatusTv = activity.binding.bluetoothStatusTv;
-        device1Tv = activity.binding.device1Tv;
-        device2Tv = activity.binding.device2Tv;
-        btnTurnOnBluetooth = activity.binding.btnTurnOnBluetooth;
-        btnDevice1 = activity.binding.btnDevice1;
-        btnDevice2 = activity.binding.btnDevice2;
-        btnScanDevices = activity.binding.btnScanDevices;
-        unconnectedLv = activity.binding.unconnectedLv;
-
-        btnTurnOnBluetooth.setOnClickListener(v -> bluetoothHelper.tryTurnOnBluetooth());
-        btnDevice1.setOnClickListener(v -> showDeviceListDialog(1));
-        btnDevice2.setOnClickListener(v -> showDeviceListDialog(2));
-        btnScanDevices.setOnClickListener(v -> scanDevices());
-
-        this.globalData = globalData;
-    }
-
-    private void scanDevices() {
-        // Do not keep bt nearby devices
-        nearbyBtDevices.clear();
-        bluetoothHelper.scanDevices();
-    }
-
-
-    @SuppressLint("MissingPermission")
-    private void showDeviceListDialog(final int deviceNumber) {
-        // Get paired devices
-        final Set<BluetoothDevice> pairedDevices = bluetoothHelper.getBondedDevices();
-        final ArrayList<String> deviceNames = new ArrayList<>();
-        final ArrayList<BluetoothDevice> devices = new ArrayList<>();
-
-        for (BluetoothDevice device : pairedDevices) {
-            deviceNames.add(device.getName());
-            devices.add(device);
-        }
-
-        AlertDialog.Builder builder = new AlertDialog.Builder(activity);
-        builder.setTitle("Select a Device");
-        builder.setItems(deviceNames.toArray(new String[0]), new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialog, int which) {
-                BluetoothDevice selectedDevice = devices.get(which);
-                connectToDevice(selectedDevice, deviceNumber);
-            }
-        });
-        builder.show();
-    }
-
-    /**
-     * Connects to a specified Bluetooth device and assigns it to the specified device slot.
-     *
-     * @param device       The Bluetooth device to connect to.
-     * @param deviceNumber The device slot number (1 for Device 1, 2 for Device 2).
-     */
-    @SuppressLint("MissingPermission")
-    public void connectToDevice(BluetoothDevice device, int deviceNumber) {
-        if (deviceNumber == 1) {
-            // If the device selected to connect is already assigned as Device 2 -> skip
-            if (device != null && globalData.connectionData2 != null) {
-                if (Objects.equals(device.getAddress(), globalData.connectionData2.device.getAddress())) {
-                    log_and_toast("Device already assigned!");
-                    return;
-                }
-            }
-
-            // Safely close the connection before replacing Device 1
-            if (globalData.isConnection1Alive()) {
-                globalData.connectionData1.cancelConnection();
-            }
-
-            // Initialize and start the connection thread for Device 1
-            ConnectionThread connectionThread = new ConnectionThread(device, globalData.messageHandler);
-            globalData.connectionData1 = new ConnectionData(device, connectionThread);
-
-            // Cancel discovery because it otherwise slows down the connection.
-            bluetoothHelper.bluetoothAdapter.cancelDiscovery();
-            // Start thread execution for Device1
-            globalData.connectionData1.connectionThread.start();
-        } else if (deviceNumber == 2) {
-            // If the device selected to connect is already assigned as Device 1 -> skip
-            if (device != null && globalData.connectionData1 != null) {
-                if (Objects.equals(device.getAddress(), globalData.connectionData1.device.getAddress())) {
-                    log_and_toast("Device already assigned!");
-                    return;
-                }
-            }
-
-            // Safely close the connection before replacing Device 2
-            if (globalData.isConnection2Alive()) {
-                globalData.connectionData2.cancelConnection();
-            }
-
-            // Initialize and start the connection thread for Device 2
-            ConnectionThread connectionThread = new ConnectionThread(device, globalData.messageHandler);
-            globalData.connectionData2 = new ConnectionData(device, connectionThread);
-
-            // Cancel discovery because it otherwise slows down the connection.
-            bluetoothHelper.bluetoothAdapter.cancelDiscovery();
-            // Start thread execution for Device1
-            globalData.connectionData2.connectionThread.start();
-        }
-    }
-
-    /**
-     * Manages the connection to a Bluetooth device, assigning it to either Device 1 or Device 2.
-     *
-     * @param device The Bluetooth device to connect.
-     */
-    public void connectToDevice(BluetoothDevice device) {
-        if (!globalData.isConnection1Alive()) {
-            // If Device 1 is not assigned, connect to Device 1
-            connectToDevice(device, 1);
-        } else if (!globalData.isConnection2Alive()) {
-            // If Device 2 is not assigned, connect to Device 2
-            connectToDevice(device, 2);
-
-        } else {
-            // If both devices are selected, replace Device 1
-            connectToDevice(device, 1);
-        }
-    }
-
-    @SuppressLint("MissingPermission")
-    public void updateBluetoothUI() {
-        // Check if bt is available or not
-        if (bluetoothHelper.bluetoothAdapter == null) {
-            bluetoothStatusTv.setText(BT_STATUS_NOT_SUPPORTED_TEXT);
-        } else {
-            // Set UI elements according to bt status (on/off)
-            if (bluetoothHelper.bluetoothAdapter.isEnabled()) {
-                bluetoothStatusTv.setText(BT_STATUS_ON_TEXT);
-                // Hide btn that turn on bluetooth
-                btnTurnOnBluetooth.setVisibility(View.GONE);
-                // Show UI elements, if bt is ON
-                setVisibility(
-                        View.VISIBLE,
-                        device1Tv,
-                        device2Tv,
-                        btnDevice1,
-                        btnDevice2,
-                        btnScanDevices
-                );
-
-                if (globalData.isConnection1Alive()) {
-                    device1Tv.setText("Device 1: " + globalData.connectionData1.device.getName());
-                } else {
-                    device1Tv.setText("Device 1: None");
-                }
-
-                if (globalData.isConnection2Alive()) {
-                    device2Tv.setText("Device 2: " +  globalData.connectionData2.device.getName());
-                } else {
-                    device2Tv.setText("Device 2: None");
-                }
-            } else {
-                bluetoothStatusTv.setText(BT_STATUS_OFF_TEXT);
-                // Show btn that turn on bluetooth
-                btnTurnOnBluetooth.setVisibility(View.VISIBLE);
-                // Hide UI elements, if bt is Off
-                setVisibility(
-                        View.GONE,
-                        device1Tv,
-                        device2Tv,
-                        btnDevice1,
-                        btnDevice2,
-                        btnScanDevices
-                );
-            }
-        }
-    }
-
-    public void showToast(String msg) {
-        Toast.makeText(activity, msg, Toast.LENGTH_SHORT).show();
-    }
-
-    @Override
-    public void log_and_toast(String stringToLog) {
-        Log.d(TAG, String.format("[LOG] %s", stringToLog));
-        showToast(stringToLog);
-    }
-
-    public void deviceFound(BluetoothDevice device) {
-        nearbyBtDevices.add(device);
-        // Convert set to list
-        ArrayList<BluetoothDevice> devices = new ArrayList<>(nearbyBtDevices);
-        mDeviceListAdapter = new DeviceListAdapter(activity, R.layout.device_adapter_view, devices, this);
-        unconnectedLv.setAdapter(mDeviceListAdapter);
-    }
-/*
-    @Override
-    public void handleAnyState(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
-        updateBluetoothUI();
-    }
-
-
-    @SuppressLint("MissingPermission")
-    @Override
-    public void handleConnecting(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
-        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
-        log_and_toast(String.format("Trying to connect to... %s", bluetoothDevice.getName()));
-    }
-
-    @SuppressLint("MissingPermission")
-    @Override
-    public void handleConnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
-        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
-        log_and_toast(String.format("Connection Established %s", bluetoothDevice.getName()));
-    }
-
-    @SuppressLint("MissingPermission")
-    @Override
-    public void handleConnectionFailed(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
-        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
-        log_and_toast(String.format("Connection Failed %s", bluetoothDevice.getName()));
-    }
-
-    @SuppressLint("MissingPermission")
-    @Override
-    public void handleMsgReceived(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
-        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;;
-        String receivedData = bluetoothDeviceReceivedData.receivedData;
-
-        log_and_toast(String.format("[READ][%s] %s", bluetoothDevice.getName(), receivedData));
-    }
-
-    @SuppressLint("MissingPermission")
-    @Override
-    public void handleDisconnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
-        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
-        log_and_toast(String.format("Device Disconnected %s", bluetoothDevice.getName()));
-    }
-
-*/
+package com.melisa.pedonovation.AppActivities.Managers;
+
+import static android.content.ContentValues.TAG;
+import static com.melisa.pedonovation.Utilities.setVisibility;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.content.DialogInterface;
+import android.util.ArraySet;
+import android.util.Log;
+import android.view.View;
+import android.widget.Button;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import androidx.appcompat.app.AlertDialog;
+
+import com.melisa.pedonovation.AppActivities.BtSettingsActivity;
+//import com.melisa.pedonovation.BluetoothCore.BluetoothDeviceReceivedData;
+import com.melisa.pedonovation.BluetoothCore.BluetoothHelper;
+import com.melisa.pedonovation.BluetoothCore.ConnectionData;
+import com.melisa.pedonovation.BluetoothCore.ConnectionThread;
+import com.melisa.pedonovation.BluetoothCore.DeviceListAdapter;
+import com.melisa.pedonovation.GlobalData;
+import com.melisa.pedonovation.Interfaces.ICurrentActivityManager;
+import com.melisa.pedonovation.R;
+import com.melisa.pedonovation.Interfaces.UILogger;
+
+import java.util.ArrayList;
+import java.util.Objects;
+import java.util.Set;
+
+public class BtSettingsManager implements UILogger, ICurrentActivityManager {
+    private final BtSettingsActivity activity;
+    private final BluetoothHelper bluetoothHelper;
+    private final TextView bluetoothStatusTv, device1Tv, device2Tv;
+    private final Button btnTurnOnBluetooth, btnDevice1, btnDevice2, btnScanDevices;
+    public final ListView unconnectedLv;
+    public ArraySet<BluetoothDevice> nearbyBtDevices = new ArraySet<>();
+    public GlobalData globalData;
+    public DeviceListAdapter mDeviceListAdapter;
+
+    private final String BT_STATUS_NOT_SUPPORTED_TEXT = "Bluetooth not supported";
+    private final String BT_STATUS_ON_TEXT = "Bluetooth Status: On";
+    private final String BT_STATUS_OFF_TEXT = "Bluetooth Status: Off";
+
+    public BtSettingsManager(BtSettingsActivity activity, BluetoothHelper bluetoothHelper, GlobalData globalData) {
+        this.activity = activity;
+        this.bluetoothHelper = bluetoothHelper;
+
+        bluetoothStatusTv = activity.binding.bluetoothStatusTv;
+        device1Tv = activity.binding.device1Tv;
+        device2Tv = activity.binding.device2Tv;
+        btnTurnOnBluetooth = activity.binding.btnTurnOnBluetooth;
+        btnDevice1 = activity.binding.btnDevice1;
+        btnDevice2 = activity.binding.btnDevice2;
+        btnScanDevices = activity.binding.btnScanDevices;
+        unconnectedLv = activity.binding.unconnectedLv;
+
+        btnTurnOnBluetooth.setOnClickListener(v -> bluetoothHelper.tryTurnOnBluetooth());
+        btnDevice1.setOnClickListener(v -> showDeviceListDialog(1));
+        btnDevice2.setOnClickListener(v -> showDeviceListDialog(2));
+        btnScanDevices.setOnClickListener(v -> scanDevices());
+
+        this.globalData = globalData;
+    }
+
+    private void scanDevices() {
+        // Do not keep bt nearby devices
+        nearbyBtDevices.clear();
+        bluetoothHelper.scanDevices();
+    }
+
+
+    @SuppressLint("MissingPermission")
+    private void showDeviceListDialog(final int deviceNumber) {
+        // Get paired devices
+        final Set<BluetoothDevice> pairedDevices = bluetoothHelper.getBondedDevices();
+        final ArrayList<String> deviceNames = new ArrayList<>();
+        final ArrayList<BluetoothDevice> devices = new ArrayList<>();
+
+        for (BluetoothDevice device : pairedDevices) {
+            deviceNames.add(device.getName());
+            devices.add(device);
+        }
+
+        AlertDialog.Builder builder = new AlertDialog.Builder(activity);
+        builder.setTitle("Select a Device");
+        builder.setItems(deviceNames.toArray(new String[0]), new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                BluetoothDevice selectedDevice = devices.get(which);
+                connectToDevice(selectedDevice, deviceNumber);
+            }
+        });
+        builder.show();
+    }
+
+    /**
+     * Connects to a specified Bluetooth device and assigns it to the specified device slot.
+     *
+     * @param device       The Bluetooth device to connect to.
+     * @param deviceNumber The device slot number (1 for Device 1, 2 for Device 2).
+     */
+    @SuppressLint("MissingPermission")
+    public void connectToDevice(BluetoothDevice device, int deviceNumber) {
+        if (deviceNumber == 1) {
+            // If the device selected to connect is already assigned as Device 2 -> skip
+            if (device != null && globalData.connectionData2 != null) {
+                if (Objects.equals(device.getAddress(), globalData.connectionData2.device.getAddress())) {
+                    log_and_toast("Device already assigned!");
+                    return;
+                }
+            }
+
+            // Safely close the connection before replacing Device 1
+            if (globalData.isConnection1Alive()) {
+                globalData.connectionData1.cancelConnection();
+            }
+
+            // Initialize and start the connection thread for Device 1
+            ConnectionThread connectionThread = new ConnectionThread(device, globalData.messageHandler);
+            globalData.connectionData1 = new ConnectionData(device, connectionThread);
+
+            // Cancel discovery because it otherwise slows down the connection.
+            bluetoothHelper.bluetoothAdapter.cancelDiscovery();
+            // Start thread execution for Device1
+            globalData.connectionData1.connectionThread.start();
+        } else if (deviceNumber == 2) {
+            // If the device selected to connect is already assigned as Device 1 -> skip
+            if (device != null && globalData.connectionData1 != null) {
+                if (Objects.equals(device.getAddress(), globalData.connectionData1.device.getAddress())) {
+                    log_and_toast("Device already assigned!");
+                    return;
+                }
+            }
+
+            // Safely close the connection before replacing Device 2
+            if (globalData.isConnection2Alive()) {
+                globalData.connectionData2.cancelConnection();
+            }
+
+            // Initialize and start the connection thread for Device 2
+            ConnectionThread connectionThread = new ConnectionThread(device, globalData.messageHandler);
+            globalData.connectionData2 = new ConnectionData(device, connectionThread);
+
+            // Cancel discovery because it otherwise slows down the connection.
+            bluetoothHelper.bluetoothAdapter.cancelDiscovery();
+            // Start thread execution for Device1
+            globalData.connectionData2.connectionThread.start();
+        }
+    }
+
+    /**
+     * Manages the connection to a Bluetooth device, assigning it to either Device 1 or Device 2.
+     *
+     * @param device The Bluetooth device to connect.
+     */
+    public void connectToDevice(BluetoothDevice device) {
+        if (!globalData.isConnection1Alive()) {
+            // If Device 1 is not assigned, connect to Device 1
+            connectToDevice(device, 1);
+        } else if (!globalData.isConnection2Alive()) {
+            // If Device 2 is not assigned, connect to Device 2
+            connectToDevice(device, 2);
+
+        } else {
+            // If both devices are selected, replace Device 1
+            connectToDevice(device, 1);
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    public void updateBluetoothUI() {
+        // Check if bt is available or not
+        if (bluetoothHelper.bluetoothAdapter == null) {
+            bluetoothStatusTv.setText(BT_STATUS_NOT_SUPPORTED_TEXT);
+        } else {
+            // Set UI elements according to bt status (on/off)
+            if (bluetoothHelper.bluetoothAdapter.isEnabled()) {
+                bluetoothStatusTv.setText(BT_STATUS_ON_TEXT);
+                // Hide btn that turn on bluetooth
+                btnTurnOnBluetooth.setVisibility(View.GONE);
+                // Show UI elements, if bt is ON
+                setVisibility(
+                        View.VISIBLE,
+                        device1Tv,
+                        device2Tv,
+                        btnDevice1,
+                        btnDevice2,
+                        btnScanDevices
+                );
+
+                if (globalData.isConnection1Alive()) {
+                    device1Tv.setText("Device 1: " + globalData.connectionData1.device.getName());
+                } else {
+                    device1Tv.setText("Device 1: None");
+                }
+
+                if (globalData.isConnection2Alive()) {
+                    device2Tv.setText("Device 2: " +  globalData.connectionData2.device.getName());
+                } else {
+                    device2Tv.setText("Device 2: None");
+                }
+            } else {
+                bluetoothStatusTv.setText(BT_STATUS_OFF_TEXT);
+                // Show btn that turn on bluetooth
+                btnTurnOnBluetooth.setVisibility(View.VISIBLE);
+                // Hide UI elements, if bt is Off
+                setVisibility(
+                        View.GONE,
+                        device1Tv,
+                        device2Tv,
+                        btnDevice1,
+                        btnDevice2,
+                        btnScanDevices
+                );
+            }
+        }
+    }
+
+    public void showToast(String msg) {
+        Toast.makeText(activity, msg, Toast.LENGTH_SHORT).show();
+    }
+
+    @Override
+    public void log_and_toast(String stringToLog) {
+        Log.d(TAG, String.format("[LOG] %s", stringToLog));
+        showToast(stringToLog);
+    }
+
+    public void deviceFound(BluetoothDevice device) {
+        nearbyBtDevices.add(device);
+        // Convert set to list
+        ArrayList<BluetoothDevice> devices = new ArrayList<>(nearbyBtDevices);
+        mDeviceListAdapter = new DeviceListAdapter(activity, R.layout.device_adapter_view, devices, this);
+        unconnectedLv.setAdapter(mDeviceListAdapter);
+    }
+/*
+    @Override
+    public void handleAnyState(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
+        updateBluetoothUI();
+    }
+
+
+    @SuppressLint("MissingPermission")
+    @Override
+    public void handleConnecting(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
+        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
+        log_and_toast(String.format("Trying to connect to... %s", bluetoothDevice.getName()));
+    }
+
+    @SuppressLint("MissingPermission")
+    @Override
+    public void handleConnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
+        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
+        log_and_toast(String.format("Connection Established %s", bluetoothDevice.getName()));
+    }
+
+    @SuppressLint("MissingPermission")
+    @Override
+    public void handleConnectionFailed(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
+        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
+        log_and_toast(String.format("Connection Failed %s", bluetoothDevice.getName()));
+    }
+
+    @SuppressLint("MissingPermission")
+    @Override
+    public void handleMsgReceived(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
+        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;;
+        String receivedData = bluetoothDeviceReceivedData.receivedData;
+
+        log_and_toast(String.format("[READ][%s] %s", bluetoothDevice.getName(), receivedData));
+    }
+
+    @SuppressLint("MissingPermission")
+    @Override
+    public void handleDisconnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData) {
+        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
+        log_and_toast(String.format("Device Disconnected %s", bluetoothDevice.getName()));
+    }
+
+*/
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/StartActivity.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/StartActivity.java
index 5aeb965..9771f52 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/StartActivity.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/StartActivity.java
@@ -1,47 +1,47 @@
-package com.melisa.pedonovation.AppActivities;
-
-import  android.os.Bundle;
-
-import android.view.View;
-import android.widget.Button;
-import android.content.Intent;
-import androidx.activity.EdgeToEdge;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.core.graphics.Insets;
-import androidx.core.view.ViewCompat;
-import androidx.core.view.WindowInsetsCompat;
-
-import com.melisa.pedonovation.R;
-import com.melisa.pedonovation.databinding.ActivityMainBinding;
-import com.melisa.pedonovation.databinding.ActivityStartBinding;
-
-public class StartActivity extends AppCompatActivity {
-
-    public ActivityStartBinding binding;
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        // Inflate the layout using view binding
-        binding = ActivityStartBinding.inflate(getLayoutInflater());
-        // Set the content view to the root of the binding
-        setContentView(binding.getRoot());
-        EdgeToEdge.enable(this);
-
-        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
-            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
-            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
-            return insets;
-        });
-    }
-
-    // Launches the BtSettingsActivity when called
-    public void LaunchLogin(View view) {
-        Intent i = new Intent(this, LoginActivity.class);
-        startActivity(i);
-    }
-
-    public void mainActivity(View view) {
-        Intent i = new Intent(this, MainActivity.class);
-        startActivity(i);
-    }
+package com.melisa.pedonovation.AppActivities;
+
+import  android.os.Bundle;
+
+import android.view.View;
+import android.widget.Button;
+import android.content.Intent;
+import androidx.activity.EdgeToEdge;
+import androidx.appcompat.app.AppCompatActivity;
+import androidx.core.graphics.Insets;
+import androidx.core.view.ViewCompat;
+import androidx.core.view.WindowInsetsCompat;
+
+import com.melisa.pedonovation.R;
+import com.melisa.pedonovation.databinding.ActivityMainBinding;
+import com.melisa.pedonovation.databinding.ActivityStartBinding;
+
+public class StartActivity extends AppCompatActivity {
+
+    public ActivityStartBinding binding;
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        // Inflate the layout using view binding
+        binding = ActivityStartBinding.inflate(getLayoutInflater());
+        // Set the content view to the root of the binding
+        setContentView(binding.getRoot());
+        EdgeToEdge.enable(this);
+
+        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
+            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
+            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
+            return insets;
+        });
+    }
+
+    // Launches the BtSettingsActivity when called
+    public void LaunchLogin(View view) {
+        Intent i = new Intent(this, LoginActivity.class);
+        startActivity(i);
+    }
+
+    public void mainActivity(View view) {
+        Intent i = new Intent(this, MainActivity.class);
+        startActivity(i);
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginDataSource.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginDataSource.java
index a0aab30..e8601a0 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginDataSource.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginDataSource.java
@@ -1,29 +1,29 @@
-package com.melisa.pedonovation.AppActivities.data;
-
-import com.melisa.pedonovation.AppActivities.data.model.LoggedInUser;
-
-import java.io.IOException;
-
-/**
- * Class that handles authentication w/ login credentials and retrieves user information.
- */
-public class LoginDataSource {
-
-    public Result<LoggedInUser> login(String username, String password) {
-
-        try {
-            // TODO: handle loggedInUser authentication
-            LoggedInUser fakeUser =
-                    new LoggedInUser(
-                            java.util.UUID.randomUUID().toString(),
-                            "Jane Doe");
-            return new Result.Success<>(fakeUser);
-        } catch (Exception e) {
-            return new Result.Error(new IOException("Error logging in", e));
-        }
-    }
-
-    public void logout() {
-        // TODO: revoke authentication
-    }
+package com.melisa.pedonovation.AppActivities.data;
+
+import com.melisa.pedonovation.AppActivities.data.model.LoggedInUser;
+
+import java.io.IOException;
+
+/**
+ * Class that handles authentication w/ login credentials and retrieves user information.
+ */
+public class LoginDataSource {
+
+    public Result<LoggedInUser> login(String username, String password) {
+
+        try {
+            // TODO: handle loggedInUser authentication
+            LoggedInUser fakeUser =
+                    new LoggedInUser(
+                            java.util.UUID.randomUUID().toString(),
+                            "Jane Doe");
+            return new Result.Success<>(fakeUser);
+        } catch (Exception e) {
+            return new Result.Error(new IOException("Error logging in", e));
+        }
+    }
+
+    public void logout() {
+        // TODO: revoke authentication
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginRepository.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginRepository.java
index 851a12d..50e3069 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginRepository.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/LoginRepository.java
@@ -1,54 +1,54 @@
-package com.melisa.pedonovation.AppActivities.data;
-
-import com.melisa.pedonovation.AppActivities.data.model.LoggedInUser;
-
-/**
- * Class that requests authentication and user information from the remote data source and
- * maintains an in-memory cache of login status and user credentials information.
- */
-public class LoginRepository {
-
-    private static volatile LoginRepository instance;
-
-    private LoginDataSource dataSource;
-
-    // If user credentials will be cached in local storage, it is recommended it be encrypted
-    // @see https://developer.android.com/training/articles/keystore
-    private LoggedInUser user = null;
-
-    // private constructor : singleton access
-    private LoginRepository(LoginDataSource dataSource) {
-        this.dataSource = dataSource;
-    }
-
-    public static LoginRepository getInstance(LoginDataSource dataSource) {
-        if (instance == null) {
-            instance = new LoginRepository(dataSource);
-        }
-        return instance;
-    }
-
-    public boolean isLoggedIn() {
-        return user != null;
-    }
-
-    public void logout() {
-        user = null;
-        dataSource.logout();
-    }
-
-    private void setLoggedInUser(LoggedInUser user) {
-        this.user = user;
-        // If user credentials will be cached in local storage, it is recommended it be encrypted
-        // @see https://developer.android.com/training/articles/keystore
-    }
-
-    public Result<LoggedInUser> login(String username, String password) {
-        // handle login
-        Result<LoggedInUser> result = dataSource.login(username, password);
-        if (result instanceof Result.Success) {
-            setLoggedInUser(((Result.Success<LoggedInUser>) result).getData());
-        }
-        return result;
-    }
+package com.melisa.pedonovation.AppActivities.data;
+
+import com.melisa.pedonovation.AppActivities.data.model.LoggedInUser;
+
+/**
+ * Class that requests authentication and user information from the remote data source and
+ * maintains an in-memory cache of login status and user credentials information.
+ */
+public class LoginRepository {
+
+    private static volatile LoginRepository instance;
+
+    private LoginDataSource dataSource;
+
+    // If user credentials will be cached in local storage, it is recommended it be encrypted
+    // @see https://developer.android.com/training/articles/keystore
+    private LoggedInUser user = null;
+
+    // private constructor : singleton access
+    private LoginRepository(LoginDataSource dataSource) {
+        this.dataSource = dataSource;
+    }
+
+    public static LoginRepository getInstance(LoginDataSource dataSource) {
+        if (instance == null) {
+            instance = new LoginRepository(dataSource);
+        }
+        return instance;
+    }
+
+    public boolean isLoggedIn() {
+        return user != null;
+    }
+
+    public void logout() {
+        user = null;
+        dataSource.logout();
+    }
+
+    private void setLoggedInUser(LoggedInUser user) {
+        this.user = user;
+        // If user credentials will be cached in local storage, it is recommended it be encrypted
+        // @see https://developer.android.com/training/articles/keystore
+    }
+
+    public Result<LoggedInUser> login(String username, String password) {
+        // handle login
+        Result<LoggedInUser> result = dataSource.login(username, password);
+        if (result instanceof Result.Success) {
+            setLoggedInUser(((Result.Success<LoggedInUser>) result).getData());
+        }
+        return result;
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/Result.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/Result.java
index 18c38c1..0d5232b 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/Result.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/Result.java
@@ -1,48 +1,48 @@
-package com.melisa.pedonovation.AppActivities.data;
-
-/**
- * A generic class that holds a result success w/ data or an error exception.
- */
-public class Result<T> {
-    // hide the private constructor to limit subclass types (Success, Error)
-    private Result() {
-    }
-
-    @Override
-    public String toString() {
-        if (this instanceof Result.Success) {
-            Result.Success success = (Result.Success) this;
-            return "Success[data=" + success.getData().toString() + "]";
-        } else if (this instanceof Result.Error) {
-            Result.Error error = (Result.Error) this;
-            return "Error[exception=" + error.getError().toString() + "]";
-        }
-        return "";
-    }
-
-    // Success sub-class
-    public final static class Success<T> extends Result {
-        private T data;
-
-        public Success(T data) {
-            this.data = data;
-        }
-
-        public T getData() {
-            return this.data;
-        }
-    }
-
-    // Error sub-class
-    public final static class Error extends Result {
-        private Exception error;
-
-        public Error(Exception error) {
-            this.error = error;
-        }
-
-        public Exception getError() {
-            return this.error;
-        }
-    }
+package com.melisa.pedonovation.AppActivities.data;
+
+/**
+ * A generic class that holds a result success w/ data or an error exception.
+ */
+public class Result<T> {
+    // hide the private constructor to limit subclass types (Success, Error)
+    private Result() {
+    }
+
+    @Override
+    public String toString() {
+        if (this instanceof Result.Success) {
+            Result.Success success = (Result.Success) this;
+            return "Success[data=" + success.getData().toString() + "]";
+        } else if (this instanceof Result.Error) {
+            Result.Error error = (Result.Error) this;
+            return "Error[exception=" + error.getError().toString() + "]";
+        }
+        return "";
+    }
+
+    // Success sub-class
+    public final static class Success<T> extends Result {
+        private T data;
+
+        public Success(T data) {
+            this.data = data;
+        }
+
+        public T getData() {
+            return this.data;
+        }
+    }
+
+    // Error sub-class
+    public final static class Error extends Result {
+        private Exception error;
+
+        public Error(Exception error) {
+            this.error = error;
+        }
+
+        public Exception getError() {
+            return this.error;
+        }
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/model/LoggedInUser.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/model/LoggedInUser.java
index 6c493c9..0445c5a 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/model/LoggedInUser.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/AppActivities/data/model/LoggedInUser.java
@@ -1,23 +1,23 @@
-package com.melisa.pedonovation.AppActivities.data.model;
-
-/**
- * Data class that captures user information for logged in users retrieved from LoginRepository
- */
-public class LoggedInUser {
-
-    private String userId;
-    private String displayName;
-
-    public LoggedInUser(String userId, String displayName) {
-        this.userId = userId;
-        this.displayName = displayName;
-    }
-
-    public String getUserId() {
-        return userId;
-    }
-
-    public String getDisplayName() {
-        return displayName;
-    }
+package com.melisa.pedonovation.AppActivities.data.model;
+
+/**
+ * Data class that captures user information for logged in users retrieved from LoginRepository
+ */
+public class LoggedInUser {
+
+    private String userId;
+    private String displayName;
+
+    public LoggedInUser(String userId, String displayName) {
+        this.userId = userId;
+        this.displayName = displayName;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public String getDisplayName() {
+        return displayName;
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/BluetoothHelper.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/BluetoothHelper.java
index 01b1c67..3ee26d9 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/BluetoothHelper.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/BluetoothHelper.java
@@ -1,125 +1,125 @@
-package com.melisa.pedonovation.BluetoothCore;
-
-import static android.content.ContentValues.TAG;
-
-import android.Manifest;
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.PackageManager;
-import android.os.Build;
-import android.util.Log;
-
-import androidx.appcompat.app.AppCompatActivity;
-
-import com.melisa.pedonovation.Interfaces.UILogger;
-
-import java.util.Set;
-import java.util.UUID;
-
-public class BluetoothHelper {
-    public static UUID APP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
-
-    private final AppCompatActivity context;
-    public BluetoothAdapter bluetoothAdapter;
-    public BroadcastReceiver bluetoothStateReceiver;
-    public BroadcastReceiver discoverReceiver;
-
-
-    private UILogger uiLogger;
-
-    public BluetoothHelper(AppCompatActivity context) {
-        this.context = context;
-
-        // Get phone bt adapter
-        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
-    }
-
-    @SuppressLint("MissingPermission")
-    public Set<BluetoothDevice> getBondedDevices() {
-        return bluetoothAdapter.getBondedDevices();
-    }
-
-    @SuppressLint("MissingPermission")
-    public void scanDevices() {
-        if (validateBluetoothPerms(new String[]{Manifest.permission.BLUETOOTH_SCAN})) {
-            // Safe return in case permissions are not allowed.
-            return;
-        }
-        if (bluetoothAdapter.isDiscovering()) {
-            log("Canceling discovery...");
-            bluetoothAdapter.cancelDiscovery();
-        }
-
-        if (validateBluetoothPerms(new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION})) {
-            // Safe return in case permissions are not allowed.
-            return;
-        }
-        bluetoothAdapter.startDiscovery();
-        log("Start discovery...");
-    }
-
-    public void tryTurnOnBluetooth() {
-        if (!bluetoothAdapter.isEnabled()) {
-            turnOnBluetooth();
-        } else {
-            log("Bluetooth is already enabled");
-        }
-    }
-
-    @SuppressLint("MissingPermission")
-    private void turnOnBluetooth() {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
-            if (validateBluetoothPerms(new String[]{Manifest.permission.BLUETOOTH_CONNECT})) {
-                // Safe return in case permissions are not allowed.
-                return;
-            }
-        } else {
-            Log.d(TAG, "No need to check permissions. SDK version < LOLLIPOP.");
-        }
-        Intent enableBTIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
-        context.startActivity(enableBTIntent);
-        log("Turning On Bluetooth...");
-    }
-
-    protected boolean validateBluetoothPerms(String[] perms) {
-        // Add up permissions check
-        int permissionCheck = 0;
-        for (String perm : perms) {
-            permissionCheck += context.checkSelfPermission(perm);
-        }
-
-        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
-            context.requestPermissions(perms, 1001);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    private void log(String stringToLog) {
-        if (uiLogger != null) {
-            uiLogger.log_and_toast(stringToLog);
-        }
-    }
-
-    public void registerReceivers(Context context) {
-        IntentFilter BTIntent = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
-        context.registerReceiver(bluetoothStateReceiver, BTIntent);
-        IntentFilter discoverDevicesIntent = new IntentFilter(BluetoothDevice.ACTION_FOUND);
-        context.registerReceiver(discoverReceiver, discoverDevicesIntent);
-    }
-
-    public void unregisterReceivers(Context context) {
-        context.unregisterReceiver(bluetoothStateReceiver);
-        context.unregisterReceiver(discoverReceiver);
-    }
-
-    public void setLogger(UILogger uiLogger) {
-        this.uiLogger = uiLogger;
-    }
-}
+package com.melisa.pedonovation.BluetoothCore;
+
+import static android.content.ContentValues.TAG;
+
+import android.Manifest;
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.util.Log;
+
+import androidx.appcompat.app.AppCompatActivity;
+
+import com.melisa.pedonovation.Interfaces.UILogger;
+
+import java.util.Set;
+import java.util.UUID;
+
+public class BluetoothHelper {
+    public static UUID APP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
+
+    private final AppCompatActivity context;
+    public BluetoothAdapter bluetoothAdapter;
+    public BroadcastReceiver bluetoothStateReceiver;
+    public BroadcastReceiver discoverReceiver;
+
+
+    private UILogger uiLogger;
+
+    public BluetoothHelper(AppCompatActivity context) {
+        this.context = context;
+
+        // Get phone bt adapter
+        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+    }
+
+    @SuppressLint("MissingPermission")
+    public Set<BluetoothDevice> getBondedDevices() {
+        return bluetoothAdapter.getBondedDevices();
+    }
+
+    @SuppressLint("MissingPermission")
+    public void scanDevices() {
+        if (validateBluetoothPerms(new String[]{Manifest.permission.BLUETOOTH_SCAN})) {
+            // Safe return in case permissions are not allowed.
+            return;
+        }
+        if (bluetoothAdapter.isDiscovering()) {
+            log("Canceling discovery...");
+            bluetoothAdapter.cancelDiscovery();
+        }
+
+        if (validateBluetoothPerms(new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION})) {
+            // Safe return in case permissions are not allowed.
+            return;
+        }
+        bluetoothAdapter.startDiscovery();
+        log("Start discovery...");
+    }
+
+    public void tryTurnOnBluetooth() {
+        if (!bluetoothAdapter.isEnabled()) {
+            turnOnBluetooth();
+        } else {
+            log("Bluetooth is already enabled");
+        }
+    }
+
+    @SuppressLint("MissingPermission")
+    private void turnOnBluetooth() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
+            if (validateBluetoothPerms(new String[]{Manifest.permission.BLUETOOTH_CONNECT})) {
+                // Safe return in case permissions are not allowed.
+                return;
+            }
+        } else {
+            Log.d(TAG, "No need to check permissions. SDK version < LOLLIPOP.");
+        }
+        Intent enableBTIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
+        context.startActivity(enableBTIntent);
+        log("Turning On Bluetooth...");
+    }
+
+    protected boolean validateBluetoothPerms(String[] perms) {
+        // Add up permissions check
+        int permissionCheck = 0;
+        for (String perm : perms) {
+            permissionCheck += context.checkSelfPermission(perm);
+        }
+
+        if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
+            context.requestPermissions(perms, 1001);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private void log(String stringToLog) {
+        if (uiLogger != null) {
+            uiLogger.log_and_toast(stringToLog);
+        }
+    }
+
+    public void registerReceivers(Context context) {
+        IntentFilter BTIntent = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+        context.registerReceiver(bluetoothStateReceiver, BTIntent);
+        IntentFilter discoverDevicesIntent = new IntentFilter(BluetoothDevice.ACTION_FOUND);
+        context.registerReceiver(discoverReceiver, discoverDevicesIntent);
+    }
+
+    public void unregisterReceivers(Context context) {
+        context.unregisterReceiver(bluetoothStateReceiver);
+        context.unregisterReceiver(discoverReceiver);
+    }
+
+    public void setLogger(UILogger uiLogger) {
+        this.uiLogger = uiLogger;
+    }
+}
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionData.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionData.java
index c809285..c10d9a6 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionData.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionData.java
@@ -1,21 +1,21 @@
-package com.melisa.pedonovation.BluetoothCore;
-
-import android.bluetooth.BluetoothDevice;
-
-import java.util.concurrent.LinkedBlockingQueue;
-
-public class ConnectionData {
-    public final BluetoothDevice device;
-    public final ConnectionThread connectionThread;
-//    public final LinkedBlockingQueue<BluetoothDeviceReceivedData> msgQueue = new LinkedBlockingQueue<>();
-
-    public ConnectionData(BluetoothDevice device, ConnectionThread connectionThread) {
-        this.device = device;
-        this.connectionThread = connectionThread;
-    }
-
-    public void cancelConnection() {
-        connectionThread.cancel();
-    }
-
-}
+package com.melisa.pedonovation.BluetoothCore;
+
+import android.bluetooth.BluetoothDevice;
+
+import java.util.concurrent.LinkedBlockingQueue;
+
+public class ConnectionData {
+    public final BluetoothDevice device;
+    public final ConnectionThread connectionThread;
+//    public final LinkedBlockingQueue<BluetoothDeviceReceivedData> msgQueue = new LinkedBlockingQueue<>();
+
+    public ConnectionData(BluetoothDevice device, ConnectionThread connectionThread) {
+        this.device = device;
+        this.connectionThread = connectionThread;
+    }
+
+    public void cancelConnection() {
+        connectionThread.cancel();
+    }
+
+}
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionThread.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionThread.java
index bcfff19..e9d3572 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionThread.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/ConnectionThread.java
@@ -1,161 +1,161 @@
-package com.melisa.pedonovation.BluetoothCore;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothSocket;
-import android.os.Handler;
-import android.os.Message;
-import android.util.Log;
-import android.util.Pair;
-
-
-//import com.melisa.pedonovation.MessageHandlers.MessageHandler;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.List;
-
-public class ConnectionThread extends Thread {
-    protected final BluetoothSocket socket;
-    protected final BluetoothDevice device;
-    private static final String TAG = "MY_APP_DEBUG_TAG";
-    private Handler handler; // handler that gets info from Bluetooth service
-    InputStream inStream;
-    OutputStream outStream;
-    byte[] receiveBuffer = new byte[1024];
-
-
-    @SuppressLint("MissingPermission")
-    public ConnectionThread(BluetoothDevice device, Handler handler) {
-        this.handler = handler;
-        this.device = device;
-
-        //sendMessageToMainThread(MessageHandler.STATE_CONNECTING, "");
-
-        // Use a temporary object that is later assigned to mmSocket
-        // because mmSocket is final.
-        BluetoothSocket tmp = null;
-
-        try {
-            // Get a BluetoothSocket to connect with the given BluetoothDevice.
-            tmp = device.createRfcommSocketToServiceRecord(BluetoothHelper.APP_UUID);
-        } catch (IOException e) {
-            Log.e(TAG, "Socket's create() method failed", e);
-        }
-        socket = tmp;
-    }
-
-
-    @SuppressLint("MissingPermission")
-    public void run() {
-
-        try {
-            // Connect to the remote device through the socket. This call blocks
-            // until it succeeds or throws an exception.
-            socket.connect();
-            //sendMessageToMainThread(MessageHandler.STATE_CONNECTED, "");
-
-            startReceiving();
-        } catch (IOException connectException) {
-            // Unable to connect; close the socket
-            //sendMessageToMainThread(MessageHandler.STATE_CONNECTION_FAILED, "");
-            cancel();
-        }
-    }
-
-    private void startReceiving() {
-        InputStream tmpIn = null;
-        OutputStream tmpOut = null;
-
-        // Get the input and output streams; using temp objects because
-        // member streams are final.
-        try {
-            tmpIn = socket.getInputStream();
-        } catch (IOException e) {
-            Log.e(TAG, "Error occurred when creating input stream", e);
-        }
-        try {
-            tmpOut = socket.getOutputStream();
-        } catch (IOException e) {
-            Log.e(TAG, "Error occurred when creating output stream", e);
-        }
-
-        inStream = tmpIn;
-        outStream = tmpOut;
-
-        int numBytes; // bytes returned from read()
-
-        // Keep listening to the InputStream until an exception occurs.
-        while (true) {
-            try {
-                // Read from the InputStream.
-                numBytes = inStream.read(receiveBuffer);
-                String receivedData = new String(receiveBuffer, 0, numBytes);
-
-                // Process received data
-                processReceivedData(receivedData);
-            } catch (IOException e) {
-                Log.d(TAG, "Input stream was disconnected", e);
-                //sendMessageToMainThread(MessageHandler.STATE_DISCONNECTED, ":(");
-                break;
-            }
-        }
-    }
-
-    private void processReceivedData(String receivedData) {
-        processAndSend(receivedData);
-    }
-
-    public void sendMessageToMainThread(int what, String data) {
-        //BluetoothDeviceReceivedData bluetoothDeviceReceivedData = new BluetoothDeviceReceivedData(device, pedometricData, data);
-     //   Message message = handler.obtainMessage(what, bluetoothDeviceReceivedData);
-        //handler.sendMessage(message);
-    }
-
-
-    private void processAndSend(String receivedData) {
-
-       /* List<String> lines = pedometricHelper.textToArrayList(receivedData);
-        for (String line : lines) {
-            Pair<SensorTypeData, SensorTypeData> result = pedometricHelper.processPedometricDataLine(line);
-            SensorTypeData accData = result.first;
-            SensorTypeData capData = result.second;
-
-            pedometricData = new PedometricData(accData, capData);
-            sendMessageToMainThread(MessageHandler.STATE_MESSAGE_RECEIVED, line + '\n');
-
-            try {
-                Thread.sleep(50);
-            } catch (InterruptedException e) {
-                e.printStackTrace();
-            }
-        }
-*/
-
-    }
-
-    // Function where the write operation is performed
-    public void write(byte[] bytes) {
-        try {
-            // Write the outputStream value
-            outStream.write(bytes);
-        } catch (IOException e) {
-            // Print the error
-            Log.d(TAG, "Error on writing to connected socket", e);
-        }
-    }
-
-    // Closes the client socket and causes the thread to finish.
-    public void cancel() {
-        try {
-            socket.close();
-        } catch (IOException e) {
-            Log.e(TAG, "Could not close the client socket", e);
-        }
-    }
-
-    public void setHandler(Handler handler) {
-        this.handler = handler;
-    }
-}
+package com.melisa.pedonovation.BluetoothCore;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothSocket;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+import android.util.Pair;
+
+
+//import com.melisa.pedonovation.MessageHandlers.MessageHandler;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.List;
+
+public class ConnectionThread extends Thread {
+    protected final BluetoothSocket socket;
+    protected final BluetoothDevice device;
+    private static final String TAG = "MY_APP_DEBUG_TAG";
+    private Handler handler; // handler that gets info from Bluetooth service
+    InputStream inStream;
+    OutputStream outStream;
+    byte[] receiveBuffer = new byte[1024];
+
+
+    @SuppressLint("MissingPermission")
+    public ConnectionThread(BluetoothDevice device, Handler handler) {
+        this.handler = handler;
+        this.device = device;
+
+        //sendMessageToMainThread(MessageHandler.STATE_CONNECTING, "");
+
+        // Use a temporary object that is later assigned to mmSocket
+        // because mmSocket is final.
+        BluetoothSocket tmp = null;
+
+        try {
+            // Get a BluetoothSocket to connect with the given BluetoothDevice.
+            tmp = device.createRfcommSocketToServiceRecord(BluetoothHelper.APP_UUID);
+        } catch (IOException e) {
+            Log.e(TAG, "Socket's create() method failed", e);
+        }
+        socket = tmp;
+    }
+
+
+    @SuppressLint("MissingPermission")
+    public void run() {
+
+        try {
+            // Connect to the remote device through the socket. This call blocks
+            // until it succeeds or throws an exception.
+            socket.connect();
+            //sendMessageToMainThread(MessageHandler.STATE_CONNECTED, "");
+
+            startReceiving();
+        } catch (IOException connectException) {
+            // Unable to connect; close the socket
+            //sendMessageToMainThread(MessageHandler.STATE_CONNECTION_FAILED, "");
+            cancel();
+        }
+    }
+
+    private void startReceiving() {
+        InputStream tmpIn = null;
+        OutputStream tmpOut = null;
+
+        // Get the input and output streams; using temp objects because
+        // member streams are final.
+        try {
+            tmpIn = socket.getInputStream();
+        } catch (IOException e) {
+            Log.e(TAG, "Error occurred when creating input stream", e);
+        }
+        try {
+            tmpOut = socket.getOutputStream();
+        } catch (IOException e) {
+            Log.e(TAG, "Error occurred when creating output stream", e);
+        }
+
+        inStream = tmpIn;
+        outStream = tmpOut;
+
+        int numBytes; // bytes returned from read()
+
+        // Keep listening to the InputStream until an exception occurs.
+        while (true) {
+            try {
+                // Read from the InputStream.
+                numBytes = inStream.read(receiveBuffer);
+                String receivedData = new String(receiveBuffer, 0, numBytes);
+
+                // Process received data
+                processReceivedData(receivedData);
+            } catch (IOException e) {
+                Log.d(TAG, "Input stream was disconnected", e);
+                //sendMessageToMainThread(MessageHandler.STATE_DISCONNECTED, ":(");
+                break;
+            }
+        }
+    }
+
+    private void processReceivedData(String receivedData) {
+        processAndSend(receivedData);
+    }
+
+    public void sendMessageToMainThread(int what, String data) {
+        //BluetoothDeviceReceivedData bluetoothDeviceReceivedData = new BluetoothDeviceReceivedData(device, pedometricData, data);
+     //   Message message = handler.obtainMessage(what, bluetoothDeviceReceivedData);
+        //handler.sendMessage(message);
+    }
+
+
+    private void processAndSend(String receivedData) {
+
+       /* List<String> lines = pedometricHelper.textToArrayList(receivedData);
+        for (String line : lines) {
+            Pair<SensorTypeData, SensorTypeData> result = pedometricHelper.processPedometricDataLine(line);
+            SensorTypeData accData = result.first;
+            SensorTypeData capData = result.second;
+
+            pedometricData = new PedometricData(accData, capData);
+            sendMessageToMainThread(MessageHandler.STATE_MESSAGE_RECEIVED, line + '\n');
+
+            try {
+                Thread.sleep(50);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        }
+*/
+
+    }
+
+    // Function where the write operation is performed
+    public void write(byte[] bytes) {
+        try {
+            // Write the outputStream value
+            outStream.write(bytes);
+        } catch (IOException e) {
+            // Print the error
+            Log.d(TAG, "Error on writing to connected socket", e);
+        }
+    }
+
+    // Closes the client socket and causes the thread to finish.
+    public void cancel() {
+        try {
+            socket.close();
+        } catch (IOException e) {
+            Log.e(TAG, "Could not close the client socket", e);
+        }
+    }
+
+    public void setHandler(Handler handler) {
+        this.handler = handler;
+    }
+}
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/DeviceListAdapter.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/DeviceListAdapter.java
index d9fb552..ad401f7 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/DeviceListAdapter.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/DeviceListAdapter.java
@@ -1,58 +1,58 @@
-package com.melisa.pedonovation.BluetoothCore;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.content.Context;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-
-import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
-import com.melisa.pedonovation.R;
-
-import java.util.ArrayList;
-
-
-public class DeviceListAdapter extends ArrayAdapter<BluetoothDevice> {
-
-    private LayoutInflater mLayoutInflater;
-    private ArrayList<BluetoothDevice> mDevices;
-    private final BtSettingsManager btSettingsManager;
-    private int mViewResourceId;
-
-    public DeviceListAdapter(Context context, int tvResourceId, ArrayList<BluetoothDevice> devices, BtSettingsManager btSettingsManager) {
-        super(context, tvResourceId, devices);
-        this.mDevices = devices;
-        mLayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        mViewResourceId = tvResourceId;
-        this.btSettingsManager = btSettingsManager;
-    }
-
-    @SuppressLint("MissingPermission")
-    public View getView(int position, View convertView, ViewGroup parent) {
-        convertView = mLayoutInflater.inflate(mViewResourceId, null);
-
-        BluetoothDevice device = mDevices.get(position);
-
-        if (device != null) {
-            TextView deviceName = (TextView) convertView.findViewById(R.id.tvDeviceName);
-            TextView deviceAddress = (TextView) convertView.findViewById(R.id.tvDeviceAddress);
-            LinearLayout scanDeviceContainer = (LinearLayout) convertView.findViewById(R.id.scanDeviceContainer);
-
-            if (deviceName != null) {
-                deviceName.setText(device.getName());
-            }
-            if (deviceAddress != null) {
-                deviceAddress.setText(device.getAddress());
-            }
-
-            scanDeviceContainer.setOnClickListener(v -> btSettingsManager.connectToDevice(device));
-        }
-
-        return convertView;
-    }
-
+package com.melisa.pedonovation.BluetoothCore;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
+import com.melisa.pedonovation.R;
+
+import java.util.ArrayList;
+
+
+public class DeviceListAdapter extends ArrayAdapter<BluetoothDevice> {
+
+    private LayoutInflater mLayoutInflater;
+    private ArrayList<BluetoothDevice> mDevices;
+    private final BtSettingsManager btSettingsManager;
+    private int mViewResourceId;
+
+    public DeviceListAdapter(Context context, int tvResourceId, ArrayList<BluetoothDevice> devices, BtSettingsManager btSettingsManager) {
+        super(context, tvResourceId, devices);
+        this.mDevices = devices;
+        mLayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mViewResourceId = tvResourceId;
+        this.btSettingsManager = btSettingsManager;
+    }
+
+    @SuppressLint("MissingPermission")
+    public View getView(int position, View convertView, ViewGroup parent) {
+        convertView = mLayoutInflater.inflate(mViewResourceId, null);
+
+        BluetoothDevice device = mDevices.get(position);
+
+        if (device != null) {
+            TextView deviceName = (TextView) convertView.findViewById(R.id.tvDeviceName);
+            TextView deviceAddress = (TextView) convertView.findViewById(R.id.tvDeviceAddress);
+            LinearLayout scanDeviceContainer = (LinearLayout) convertView.findViewById(R.id.scanDeviceContainer);
+
+            if (deviceName != null) {
+                deviceName.setText(device.getName());
+            }
+            if (deviceAddress != null) {
+                deviceAddress.setText(device.getAddress());
+            }
+
+            scanDeviceContainer.setOnClickListener(v -> btSettingsManager.connectToDevice(device));
+        }
+
+        return convertView;
+    }
+
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/BluetoothStateReceiver.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/BluetoothStateReceiver.java
index a5147d4..9393005 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/BluetoothStateReceiver.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/BluetoothStateReceiver.java
@@ -1,62 +1,62 @@
-package com.melisa.pedonovation.BluetoothCore.Receivers;
-
-import static android.content.ContentValues.TAG;
-
-import android.bluetooth.BluetoothAdapter;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-
-import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
-
-/**
- * BroadcastReceiver to handle Bluetooth state changes.
- */
-public class BluetoothStateReceiver extends BroadcastReceiver {
-    private final BtSettingsManager btSettingsManager;
-
-    /**
-     * Constructor to initialize BluetoothStateReceiver with a BluetoothHelper instance.
-     *
-     * @param btSettingsManager The BluetoothHelper instance to manage Bluetooth operations.
-     */
-    public BluetoothStateReceiver(BtSettingsManager btSettingsManager) {
-        this.btSettingsManager = btSettingsManager;
-    }
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        // Get the action of the received intent
-        String action = intent.getAction();
-
-        // Check if the action is related to Bluetooth state change
-        if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
-            // Get the current state of the Bluetooth adapter
-            final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
-
-            // Update the UI based on the Bluetooth state
-            btSettingsManager.updateBluetoothUI();
-
-            // Handle different Bluetooth states
-            switch (state) {
-                case BluetoothAdapter.STATE_OFF:
-                    // Log and show a toast message for Bluetooth off state
-                    btSettingsManager.log_and_toast("STATE OFF");
-                    break;
-                case BluetoothAdapter.STATE_TURNING_OFF:
-                    // Log the Bluetooth turning off state
-                    Log.d(TAG, "STATE TURNING OFF");
-                    break;
-                case BluetoothAdapter.STATE_ON:
-                    // Log and show a toast message for Bluetooth on state
-                    btSettingsManager.log_and_toast("STATE ON");
-                    break;
-                case BluetoothAdapter.STATE_TURNING_ON:
-                    // Log and show a toast message for Bluetooth turning on state
-                    btSettingsManager.log_and_toast("STATE TURNING ON");
-                    break;
-            }
-        }
-    }
-}
+package com.melisa.pedonovation.BluetoothCore.Receivers;
+
+import static android.content.ContentValues.TAG;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
+
+/**
+ * BroadcastReceiver to handle Bluetooth state changes.
+ */
+public class BluetoothStateReceiver extends BroadcastReceiver {
+    private final BtSettingsManager btSettingsManager;
+
+    /**
+     * Constructor to initialize BluetoothStateReceiver with a BluetoothHelper instance.
+     *
+     * @param btSettingsManager The BluetoothHelper instance to manage Bluetooth operations.
+     */
+    public BluetoothStateReceiver(BtSettingsManager btSettingsManager) {
+        this.btSettingsManager = btSettingsManager;
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        // Get the action of the received intent
+        String action = intent.getAction();
+
+        // Check if the action is related to Bluetooth state change
+        if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+            // Get the current state of the Bluetooth adapter
+            final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR);
+
+            // Update the UI based on the Bluetooth state
+            btSettingsManager.updateBluetoothUI();
+
+            // Handle different Bluetooth states
+            switch (state) {
+                case BluetoothAdapter.STATE_OFF:
+                    // Log and show a toast message for Bluetooth off state
+                    btSettingsManager.log_and_toast("STATE OFF");
+                    break;
+                case BluetoothAdapter.STATE_TURNING_OFF:
+                    // Log the Bluetooth turning off state
+                    Log.d(TAG, "STATE TURNING OFF");
+                    break;
+                case BluetoothAdapter.STATE_ON:
+                    // Log and show a toast message for Bluetooth on state
+                    btSettingsManager.log_and_toast("STATE ON");
+                    break;
+                case BluetoothAdapter.STATE_TURNING_ON:
+                    // Log and show a toast message for Bluetooth turning on state
+                    btSettingsManager.log_and_toast("STATE TURNING ON");
+                    break;
+            }
+        }
+    }
+}
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/DiscoverReceiver.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/DiscoverReceiver.java
index 5f2c2e1..5fbb0ca 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/DiscoverReceiver.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/BluetoothCore/Receivers/DiscoverReceiver.java
@@ -1,34 +1,34 @@
-package com.melisa.pedonovation.BluetoothCore.Receivers;
-
-import static android.content.ContentValues.TAG;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.util.Log;
-
-import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
-
-public class DiscoverReceiver extends BroadcastReceiver {
-    private final BtSettingsManager btSettingsManager;
-
-    public DiscoverReceiver(BtSettingsManager btSettingsManager) {
-        this.btSettingsManager = btSettingsManager;
-    }
-
-    @SuppressLint("MissingPermission")
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        final String action = intent.getAction();
-        Log.d(TAG, "onReceive: ACTION FOUND.");
-
-        if (action.equals(BluetoothDevice.ACTION_FOUND)){
-            BluetoothDevice device = intent.getParcelableExtra (BluetoothDevice.EXTRA_DEVICE);
-            Log.d(TAG, "onReceive: " + device.getName() + ": " + device.getAddress());
-
-            btSettingsManager.deviceFound(device);
-        }
-    }
-}
+package com.melisa.pedonovation.BluetoothCore.Receivers;
+
+import static android.content.ContentValues.TAG;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+import com.melisa.pedonovation.AppActivities.Managers.BtSettingsManager;
+
+public class DiscoverReceiver extends BroadcastReceiver {
+    private final BtSettingsManager btSettingsManager;
+
+    public DiscoverReceiver(BtSettingsManager btSettingsManager) {
+        this.btSettingsManager = btSettingsManager;
+    }
+
+    @SuppressLint("MissingPermission")
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+        Log.d(TAG, "onReceive: ACTION FOUND.");
+
+        if (action.equals(BluetoothDevice.ACTION_FOUND)){
+            BluetoothDevice device = intent.getParcelableExtra (BluetoothDevice.EXTRA_DEVICE);
+            Log.d(TAG, "onReceive: " + device.getName() + ": " + device.getAddress());
+
+            btSettingsManager.deviceFound(device);
+        }
+    }
+}
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/GlobalData.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/GlobalData.java
index 68d7efc..55c251e 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/GlobalData.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/GlobalData.java
@@ -1,41 +1,41 @@
-package com.melisa.pedonovation;
-
-import android.app.Application;
-import android.os.Handler;
-
-import com.melisa.pedonovation.Interfaces.ICurrentActivityManager;
-import com.melisa.pedonovation.BluetoothCore.ConnectionData;
-//import com.melisa.pedonovation.MessageHandlers.MessageHandler;
-
-public class GlobalData extends Application {
-
-    public ConnectionData connectionData1;
-    public ConnectionData connectionData2;
-    public Handler messageHandler;
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-    }
-
-    public void setActivityManagerForHandler(ICurrentActivityManager activityManager) {
-       // messageHandler = new Handler(new MessageHandler(activityManager));
-
-        if (isConnection1Alive()) {
-            connectionData1.connectionThread.setHandler(messageHandler);
-        }
-
-        if (isConnection2Alive()) {
-            connectionData2.connectionThread.setHandler(messageHandler);
-        }
-    }
-
-    public boolean isConnection1Alive() {
-        return connectionData1 != null && connectionData1.connectionThread.isAlive();
-    }
-
-    public boolean isConnection2Alive() {
-        return connectionData2 != null && connectionData2.connectionThread.isAlive();
-    }
-
+package com.melisa.pedonovation;
+
+import android.app.Application;
+import android.os.Handler;
+
+import com.melisa.pedonovation.Interfaces.ICurrentActivityManager;
+import com.melisa.pedonovation.BluetoothCore.ConnectionData;
+//import com.melisa.pedonovation.MessageHandlers.MessageHandler;
+
+public class GlobalData extends Application {
+
+    public ConnectionData connectionData1;
+    public ConnectionData connectionData2;
+    public Handler messageHandler;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+    }
+
+    public void setActivityManagerForHandler(ICurrentActivityManager activityManager) {
+       // messageHandler = new Handler(new MessageHandler(activityManager));
+
+        if (isConnection1Alive()) {
+            connectionData1.connectionThread.setHandler(messageHandler);
+        }
+
+        if (isConnection2Alive()) {
+            connectionData2.connectionThread.setHandler(messageHandler);
+        }
+    }
+
+    public boolean isConnection1Alive() {
+        return connectionData1 != null && connectionData1.connectionThread.isAlive();
+    }
+
+    public boolean isConnection2Alive() {
+        return connectionData2 != null && connectionData2.connectionThread.isAlive();
+    }
+
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/ICurrentActivityManager.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/ICurrentActivityManager.java
index 2632e6d..9ef2292 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/ICurrentActivityManager.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/ICurrentActivityManager.java
@@ -1,18 +1,18 @@
-package com.melisa.pedonovation.Interfaces;
-
-//import com.melisa.pedonovation.BluetoothCore.BluetoothDeviceReceivedData;
-
-public interface ICurrentActivityManager {
-
-    //void handleAnyState(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
-
-    //void handleConnecting(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
-
-    //void handleConnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
-
-    //void handleConnectionFailed(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
-
-    //void handleMsgReceived(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
-
-    //void handleDisconnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
-}
+package com.melisa.pedonovation.Interfaces;
+
+//import com.melisa.pedonovation.BluetoothCore.BluetoothDeviceReceivedData;
+
+public interface ICurrentActivityManager {
+
+    //void handleAnyState(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
+
+    //void handleConnecting(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
+
+    //void handleConnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
+
+    //void handleConnectionFailed(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
+
+    //void handleMsgReceived(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
+
+    //void handleDisconnected(BluetoothDeviceReceivedData bluetoothDeviceReceivedData);
+}
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/UILogger.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/UILogger.java
index 495c6fd..c947518 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/UILogger.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Interfaces/UILogger.java
@@ -1,6 +1,6 @@
-package com.melisa.pedonovation.Interfaces;
-
-public interface UILogger {
-    void log_and_toast(String event);
-}
-
+package com.melisa.pedonovation.Interfaces;
+
+public interface UILogger {
+    void log_and_toast(String event);
+}
+
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/MessageHandlers/MessageHandler.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/MessageHandlers/MessageHandler.java
index f532ab7..e7af2b0 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/MessageHandlers/MessageHandler.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/MessageHandlers/MessageHandler.java
@@ -1,87 +1,87 @@
-package com.melisa.pedonovation.MessageHandlers;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.os.Handler;
-import android.os.Message;
-
-import com.melisa.pedonovation.Interfaces.ICurrentActivityManager;
-//import com.melisa.pedonovation.BluetoothCore.BluetoothDeviceReceivedData;
-
-/*public class MessageHandler implements Handler.Callback {
-
-    private ICurrentActivityManager iCurrentActivityManager;
-
-    // Constant value for STATE_LISTENING
-    public static final int STATE_LISTENING = 1;
-
-    // Constant value for STATE_CONNECTING
-    public static final int STATE_CONNECTING = 2;
-
-    // Constant value for STATE_CONNECTED
-    public static final int STATE_CONNECTED = 3;
-
-    // Constant value for STATE_CONNECTION_FAILED
-    public static final int STATE_CONNECTION_FAILED = 4;
-
-    // Constant value for STATE_MESSAGE_RECEIVED
-    public static final int STATE_MESSAGE_RECEIVED = 5;
-
-    public static final int STATE_DISCONNECTED = 6;
-
-    public MessageHandler(ICurrentActivityManager iCurrentActivityManager) {
-        this.iCurrentActivityManager = iCurrentActivityManager;
-    }
-
-
-   @SuppressLint({"SetTextI18n", "MissingPermission"})
-   @Override
-    public boolean handleMessage(Message msg) {
-        // If there is no currentActivityManager set then do not handleMessage
-        if (iCurrentActivityManager == null) {
-            return false;
-        }
-
-        BluetoothDeviceReceivedData bluetoothDeviceReceivedData = (BluetoothDeviceReceivedData) msg.obj;
-        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
-        String data = bluetoothDeviceReceivedData.receivedData;
-
-        // Update Main UI elements
-        iCurrentActivityManager.handleAnyState(bluetoothDeviceReceivedData);
-
-        // Handler: A class that allows communication with the UI thread.
-        switch (msg.what) {
-            // If the value is STATE_LISTENING
-            case STATE_LISTENING:
-                break;
-
-            // If the value is STATE_CONNECTING
-            case STATE_CONNECTING:
-                iCurrentActivityManager.handleConnecting(bluetoothDeviceReceivedData);
-                break;
-
-            // If the value is STATE_CONNECTED
-            case STATE_CONNECTED:
-                iCurrentActivityManager.handleConnected(bluetoothDeviceReceivedData);
-                break;
-
-            // If the value is STATE_CONNECTION_FAILED
-            case STATE_CONNECTION_FAILED:
-                iCurrentActivityManager.handleConnectionFailed(bluetoothDeviceReceivedData);
-                break;
-
-            // If the value is STATE_MESSAGE_RECEIVED
-            case STATE_MESSAGE_RECEIVED:
-                iCurrentActivityManager.handleMsgReceived(bluetoothDeviceReceivedData);
-                break;
-
-            case STATE_DISCONNECTED:
-                iCurrentActivityManager.handleDisconnected(bluetoothDeviceReceivedData);
-                break;
-        }
-        // Return true value
-        return true;
-    }
-
-
-}*/
+package com.melisa.pedonovation.MessageHandlers;
+
+import android.annotation.SuppressLint;
+import android.bluetooth.BluetoothDevice;
+import android.os.Handler;
+import android.os.Message;
+
+import com.melisa.pedonovation.Interfaces.ICurrentActivityManager;
+//import com.melisa.pedonovation.BluetoothCore.BluetoothDeviceReceivedData;
+
+/*public class MessageHandler implements Handler.Callback {
+
+    private ICurrentActivityManager iCurrentActivityManager;
+
+    // Constant value for STATE_LISTENING
+    public static final int STATE_LISTENING = 1;
+
+    // Constant value for STATE_CONNECTING
+    public static final int STATE_CONNECTING = 2;
+
+    // Constant value for STATE_CONNECTED
+    public static final int STATE_CONNECTED = 3;
+
+    // Constant value for STATE_CONNECTION_FAILED
+    public static final int STATE_CONNECTION_FAILED = 4;
+
+    // Constant value for STATE_MESSAGE_RECEIVED
+    public static final int STATE_MESSAGE_RECEIVED = 5;
+
+    public static final int STATE_DISCONNECTED = 6;
+
+    public MessageHandler(ICurrentActivityManager iCurrentActivityManager) {
+        this.iCurrentActivityManager = iCurrentActivityManager;
+    }
+
+
+   @SuppressLint({"SetTextI18n", "MissingPermission"})
+   @Override
+    public boolean handleMessage(Message msg) {
+        // If there is no currentActivityManager set then do not handleMessage
+        if (iCurrentActivityManager == null) {
+            return false;
+        }
+
+        BluetoothDeviceReceivedData bluetoothDeviceReceivedData = (BluetoothDeviceReceivedData) msg.obj;
+        BluetoothDevice bluetoothDevice = bluetoothDeviceReceivedData.device;
+        String data = bluetoothDeviceReceivedData.receivedData;
+
+        // Update Main UI elements
+        iCurrentActivityManager.handleAnyState(bluetoothDeviceReceivedData);
+
+        // Handler: A class that allows communication with the UI thread.
+        switch (msg.what) {
+            // If the value is STATE_LISTENING
+            case STATE_LISTENING:
+                break;
+
+            // If the value is STATE_CONNECTING
+            case STATE_CONNECTING:
+                iCurrentActivityManager.handleConnecting(bluetoothDeviceReceivedData);
+                break;
+
+            // If the value is STATE_CONNECTED
+            case STATE_CONNECTED:
+                iCurrentActivityManager.handleConnected(bluetoothDeviceReceivedData);
+                break;
+
+            // If the value is STATE_CONNECTION_FAILED
+            case STATE_CONNECTION_FAILED:
+                iCurrentActivityManager.handleConnectionFailed(bluetoothDeviceReceivedData);
+                break;
+
+            // If the value is STATE_MESSAGE_RECEIVED
+            case STATE_MESSAGE_RECEIVED:
+                iCurrentActivityManager.handleMsgReceived(bluetoothDeviceReceivedData);
+                break;
+
+            case STATE_DISCONNECTED:
+                iCurrentActivityManager.handleDisconnected(bluetoothDeviceReceivedData);
+                break;
+        }
+        // Return true value
+        return true;
+    }
+
+
+}*/
diff --git a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Utilities.java b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Utilities.java
index 59a974f..69cee9e 100644
--- a/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Utilities.java
+++ b/_old_Pedonovation/app/src/main/java/com/melisa/pedonovation/Utilities.java
@@ -1,23 +1,23 @@
-package com.melisa.pedonovation;
-
-import android.view.View;
-
-public class Utilities {
-    public static final String FILE_NAME_FORMAT = "TestData_%s.txt";
-
-    /**
-     * Sets the visibility of multiple UI elements.
-     *
-     * @param visibility The visibility status (View.VISIBLE or View.GONE).
-     * @param views      The UI elements whose visibility will be set.
-     */
-    public static void setVisibility(int visibility, View... views) {
-        for (View view : views) {
-            if (view != null) {
-                view.setVisibility(visibility);
-            }
-        }
-    }
-
-
-}
+package com.melisa.pedonovation;
+
+import android.view.View;
+
+public class Utilities {
+    public static final String FILE_NAME_FORMAT = "TestData_%s.txt";
+
+    /**
+     * Sets the visibility of multiple UI elements.
+     *
+     * @param visibility The visibility status (View.VISIBLE or View.GONE).
+     * @param views      The UI elements whose visibility will be set.
+     */
+    public static void setVisibility(int visibility, View... views) {
+        for (View view : views) {
+            if (view != null) {
+                view.setVisibility(visibility);
+            }
+        }
+    }
+
+
+}
diff --git a/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_off.xml b/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_off.xml
index af3de20..216b84b 100644
--- a/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_off.xml
+++ b/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_off.xml
@@ -1,11 +1,11 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="24dp"
-    android:height="24dp"
-    android:viewportWidth="24"
-    android:viewportHeight="24"
-    android:tint="#33B5E5"
-    android:alpha="0.8">
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M13,5.83l1.88,1.88 -1.6,1.6 1.41,1.41 3.02,-3.02L12,2h-1v5.03l2,2v-3.2zM5.41,4L4,5.41 10.59,12 5,17.59 6.41,19 11,14.41V22h1l4.29,-4.29 2.3,2.29L20,18.59 5.41,4zM13,18.17v-3.76l1.88,1.88L13,18.17z"/>
-</vector>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24"
+    android:tint="#33B5E5"
+    android:alpha="0.8">
+  <path
+      android:fillColor="@android:color/white"
+      android:pathData="M13,5.83l1.88,1.88 -1.6,1.6 1.41,1.41 3.02,-3.02L12,2h-1v5.03l2,2v-3.2zM5.41,4L4,5.41 10.59,12 5,17.59 6.41,19 11,14.41V22h1l4.29,-4.29 2.3,2.29L20,18.59 5.41,4zM13,18.17v-3.76l1.88,1.88L13,18.17z"/>
+</vector>
diff --git a/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_on.xml b/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_on.xml
index 146eaa0..eb23efa 100644
--- a/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_on.xml
+++ b/_old_Pedonovation/app/src/main/res/drawable-anydpi/ic_action_bt_on.xml
@@ -1,11 +1,11 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="24dp"
-    android:height="24dp"
-    android:viewportWidth="24"
-    android:viewportHeight="24"
-    android:tint="#33B5E5"
-    android:alpha="0.8">
-  <path
-      android:fillColor="@android:color/white"
-      android:pathData="M17.71,7.71L12,2h-1v7.59L6.41,5 5,6.41 10.59,12 5,17.59 6.41,19 11,14.41L11,22h1l5.71,-5.71 -4.3,-4.29 4.3,-4.29zM13,5.83l1.88,1.88L13,9.59L13,5.83zM14.88,16.29L13,18.17v-3.76l1.88,1.88z"/>
-</vector>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24"
+    android:tint="#33B5E5"
+    android:alpha="0.8">
+  <path
+      android:fillColor="@android:color/white"
+      android:pathData="M17.71,7.71L12,2h-1v7.59L6.41,5 5,6.41 10.59,12 5,17.59 6.41,19 11,14.41L11,22h1l5.71,-5.71 -4.3,-4.29 4.3,-4.29zM13,5.83l1.88,1.88L13,9.59L13,5.83zM14.88,16.29L13,18.17v-3.76l1.88,1.88z"/>
+</vector>
diff --git a/_old_Pedonovation/app/src/main/res/drawable/baseline_block_24.xml b/_old_Pedonovation/app/src/main/res/drawable/baseline_block_24.xml
index 398aa40..81d2246 100644
--- a/_old_Pedonovation/app/src/main/res/drawable/baseline_block_24.xml
+++ b/_old_Pedonovation/app/src/main/res/drawable/baseline_block_24.xml
@@ -1,5 +1,5 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
-      
-    <path android:fillColor="@android:color/white" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM4,12c0,-4.42 3.58,-8 8,-8 1.85,0 3.55,0.63 4.9,1.69L5.69,16.9C4.63,15.55 4,13.85 4,12zM12,20c-1.85,0 -3.55,-0.63 -4.9,-1.69L18.31,7.1C19.37,8.45 20,10.15 20,12c0,4.42 -3.58,8 -8,8z"/>
-    
-</vector>
+<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
+      
+    <path android:fillColor="@android:color/white" android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM4,12c0,-4.42 3.58,-8 8,-8 1.85,0 3.55,0.63 4.9,1.69L5.69,16.9C4.63,15.55 4,13.85 4,12zM12,20c-1.85,0 -3.55,-0.63 -4.9,-1.69L18.31,7.1C19.37,8.45 20,10.15 20,12c0,4.42 -3.58,8 -8,8z"/>
+    
+</vector>
diff --git a/_old_Pedonovation/app/src/main/res/drawable/baseline_person_24.xml b/_old_Pedonovation/app/src/main/res/drawable/baseline_person_24.xml
index f4cc418..ad6a558 100644
--- a/_old_Pedonovation/app/src/main/res/drawable/baseline_person_24.xml
+++ b/_old_Pedonovation/app/src/main/res/drawable/baseline_person_24.xml
@@ -1,5 +1,5 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
-      
-    <path android:fillColor="@android:color/white" android:pathData="M12,12c2.21,0 4,-1.79 4,-4s-1.79,-4 -4,-4 -4,1.79 -4,4 1.79,4 4,4zM12,14c-2.67,0 -8,1.34 -8,4v2h16v-2c0,-2.66 -5.33,-4 -8,-4z"/>
-    
-</vector>
+<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#000000" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
+      
+    <path android:fillColor="@android:color/white" android:pathData="M12,12c2.21,0 4,-1.79 4,-4s-1.79,-4 -4,-4 -4,1.79 -4,4 1.79,4 4,4zM12,14c-2.67,0 -8,1.34 -8,4v2h16v-2c0,-2.66 -5.33,-4 -8,-4z"/>
+    
+</vector>
diff --git a/_old_Pedonovation/app/src/main/res/drawable/custom_edittext.xml b/_old_Pedonovation/app/src/main/res/drawable/custom_edittext.xml
index 7cf3d40..5da0c7b 100644
--- a/_old_Pedonovation/app/src/main/res/drawable/custom_edittext.xml
+++ b/_old_Pedonovation/app/src/main/res/drawable/custom_edittext.xml
@@ -1,12 +1,12 @@
-<?xml version="1.0" encoding="utf-8"?>
-<shape xmlns:android="http://schemas.android.com/apk/res/android"
-    android:shape="rectangle">
-
-    <stroke
-        android:width="3dp"
-        android:color="@color/purple_700"/>
-
-    <corners
-        android:radius="20dp"/>
-
+<?xml version="1.0" encoding="utf-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android"
+    android:shape="rectangle">
+
+    <stroke
+        android:width="3dp"
+        android:color="@color/purple_700"/>
+
+    <corners
+        android:radius="20dp"/>
+
 </shape>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_background.xml b/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_background.xml
index 07d5da9..a4f78de 100644
--- a/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_background.xml
+++ b/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_background.xml
@@ -1,170 +1,170 @@
-<?xml version="1.0" encoding="utf-8"?>
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    android:width="108dp"
-    android:height="108dp"
-    android:viewportWidth="108"
-    android:viewportHeight="108">
-    <path
-        android:fillColor="#3DDC84"
-        android:pathData="M0,0h108v108h-108z" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M9,0L9,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,0L19,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M29,0L29,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M39,0L39,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M49,0L49,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M59,0L59,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M69,0L69,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M79,0L79,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M89,0L89,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M99,0L99,108"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,9L108,9"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,19L108,19"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,29L108,29"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,39L108,39"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,49L108,49"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,59L108,59"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,69L108,69"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,79L108,79"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,89L108,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M0,99L108,99"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,29L89,29"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,39L89,39"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,49L89,49"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,59L89,59"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,69L89,69"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M19,79L89,79"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M29,19L29,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M39,19L39,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M49,19L49,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M59,19L59,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M69,19L69,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-    <path
-        android:fillColor="#00000000"
-        android:pathData="M79,19L79,89"
-        android:strokeWidth="0.8"
-        android:strokeColor="#33FFFFFF" />
-</vector>
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path
+        android:fillColor="#3DDC84"
+        android:pathData="M0,0h108v108h-108z" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M9,0L9,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,0L19,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,0L29,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,0L39,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,0L49,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,0L59,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,0L69,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,0L79,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M89,0L89,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M99,0L99,108"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,9L108,9"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,19L108,19"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,29L108,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,39L108,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,49L108,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,59L108,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,69L108,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,79L108,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,89L108,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M0,99L108,99"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,29L89,29"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,39L89,39"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,49L89,49"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,59L89,59"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,69L89,69"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M19,79L89,79"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M29,19L29,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M39,19L39,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M49,19L49,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M59,19L59,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M69,19L69,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+    <path
+        android:fillColor="#00000000"
+        android:pathData="M79,19L79,89"
+        android:strokeWidth="0.8"
+        android:strokeColor="#33FFFFFF" />
+</vector>
diff --git a/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_foreground.xml b/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_foreground.xml
index 2b068d1..cc14f03 100644
--- a/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_foreground.xml
+++ b/_old_Pedonovation/app/src/main/res/drawable/ic_launcher_foreground.xml
@@ -1,30 +1,30 @@
-<vector xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:aapt="http://schemas.android.com/aapt"
-    android:width="108dp"
-    android:height="108dp"
-    android:viewportWidth="108"
-    android:viewportHeight="108">
-    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
-        <aapt:attr name="android:fillColor">
-            <gradient
-                android:endX="85.84757"
-                android:endY="92.4963"
-                android:startX="42.9492"
-                android:startY="49.59793"
-                android:type="linear">
-                <item
-                    android:color="#44000000"
-                    android:offset="0.0" />
-                <item
-                    android:color="#00000000"
-                    android:offset="1.0" />
-            </gradient>
-        </aapt:attr>
-    </path>
-    <path
-        android:fillColor="#FFFFFF"
-        android:fillType="nonZero"
-        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
-        android:strokeWidth="1"
-        android:strokeColor="#00000000" />
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:aapt="http://schemas.android.com/aapt"
+    android:width="108dp"
+    android:height="108dp"
+    android:viewportWidth="108"
+    android:viewportHeight="108">
+    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
+        <aapt:attr name="android:fillColor">
+            <gradient
+                android:endX="85.84757"
+                android:endY="92.4963"
+                android:startX="42.9492"
+                android:startY="49.59793"
+                android:type="linear">
+                <item
+                    android:color="#44000000"
+                    android:offset="0.0" />
+                <item
+                    android:color="#00000000"
+                    android:offset="1.0" />
+            </gradient>
+        </aapt:attr>
+    </path>
+    <path
+        android:fillColor="#FFFFFF"
+        android:fillType="nonZero"
+        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
+        android:strokeWidth="1"
+        android:strokeColor="#00000000" />
 </vector>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/layout/activity_btsettings.xml b/_old_Pedonovation/app/src/main/res/layout/activity_btsettings.xml
index 295ed53..e8b813c 100644
--- a/_old_Pedonovation/app/src/main/res/layout/activity_btsettings.xml
+++ b/_old_Pedonovation/app/src/main/res/layout/activity_btsettings.xml
@@ -1,105 +1,105 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:id="@+id/main"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical"
-    android:padding="18dp"
-    tools:context=".AppActivities.BtSettingsActivity">
-
-    <!-- Title -->
-
-
-    <!-- Back Button -->
-    <ImageView
-        android:id="@+id/imageView"
-        android:layout_width="365dp"
-        android:layout_height="74dp"
-        android:layout_marginTop="25sp"
-        app:srcCompat="@drawable/ic_action_bt_on" />
-
-    <!-- Bluetooth Status -->
-    <TextView
-        android:id="@+id/bluetoothStatusTv"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="16dp"
-        android:text="Bluetooth Status: Off"
-        android:textAlignment="center"
-        android:textSize="18sp"
-        android:textStyle="bold" />
-
-    <!-- Turn On Bluetooth Button -->
-    <Button
-        android:id="@+id/btnTurnOnBluetooth"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_gravity="center_horizontal"
-        android:layout_marginTop="16dp"
-        android:text="Turn On Bluetooth" />
-
-    <!-- Device 1 -->
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="16dp"
-        android:gravity="center_vertical"
-        android:orientation="horizontal">
-
-        <TextView
-            android:id="@+id/device1Tv"
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:text="Device 1: None"
-            android:textSize="18sp"
-            android:textStyle="bold" />
-
-        <Button
-            android:id="@+id/btnDevice1"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Select Device 1" />
-    </LinearLayout>
-
-    <!-- Device 2 -->
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:layout_marginTop="16dp"
-        android:gravity="center_vertical"
-        android:orientation="horizontal">
-
-        <TextView
-            android:id="@+id/device2Tv"
-            android:layout_width="0dp"
-            android:layout_height="wrap_content"
-            android:layout_weight="1"
-            android:text="Device 2: None"
-            android:textSize="18sp"
-            android:textStyle="bold" />
-
-        <Button
-            android:id="@+id/btnDevice2"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:text="Select Device 2" />
-    </LinearLayout>
-
-    <!-- Scan Devices Button -->
-    <Button
-        android:id="@+id/btnScanDevices"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_gravity="center_horizontal"
-        android:layout_marginTop="16dp"
-        android:text="Scan Nearby Devices" />
-        
-    <!--  ListView of unconnected devices  -->
-    <ListView
-        android:id="@+id/unconnectedLv"
-        android:layout_width="364dp"
-        android:layout_height="300dp" />
-</LinearLayout>
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/main"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:padding="18dp"
+    tools:context=".AppActivities.BtSettingsActivity">
+
+    <!-- Title -->
+
+
+    <!-- Back Button -->
+    <ImageView
+        android:id="@+id/imageView"
+        android:layout_width="365dp"
+        android:layout_height="74dp"
+        android:layout_marginTop="25sp"
+        app:srcCompat="@drawable/ic_action_bt_on" />
+
+    <!-- Bluetooth Status -->
+    <TextView
+        android:id="@+id/bluetoothStatusTv"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp"
+        android:text="Bluetooth Status: Off"
+        android:textAlignment="center"
+        android:textSize="18sp"
+        android:textStyle="bold" />
+
+    <!-- Turn On Bluetooth Button -->
+    <Button
+        android:id="@+id/btnTurnOnBluetooth"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_horizontal"
+        android:layout_marginTop="16dp"
+        android:text="Turn On Bluetooth" />
+
+    <!-- Device 1 -->
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp"
+        android:gravity="center_vertical"
+        android:orientation="horizontal">
+
+        <TextView
+            android:id="@+id/device1Tv"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="Device 1: None"
+            android:textSize="18sp"
+            android:textStyle="bold" />
+
+        <Button
+            android:id="@+id/btnDevice1"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="Select Device 1" />
+    </LinearLayout>
+
+    <!-- Device 2 -->
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="16dp"
+        android:gravity="center_vertical"
+        android:orientation="horizontal">
+
+        <TextView
+            android:id="@+id/device2Tv"
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="Device 2: None"
+            android:textSize="18sp"
+            android:textStyle="bold" />
+
+        <Button
+            android:id="@+id/btnDevice2"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="Select Device 2" />
+    </LinearLayout>
+
+    <!-- Scan Devices Button -->
+    <Button
+        android:id="@+id/btnScanDevices"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_gravity="center_horizontal"
+        android:layout_marginTop="16dp"
+        android:text="Scan Nearby Devices" />
+        
+    <!--  ListView of unconnected devices  -->
+    <ListView
+        android:id="@+id/unconnectedLv"
+        android:layout_width="364dp"
+        android:layout_height="300dp" />
+</LinearLayout>
diff --git a/_old_Pedonovation/app/src/main/res/layout/activity_graphs.xml b/_old_Pedonovation/app/src/main/res/layout/activity_graphs.xml
index a67c2ae..b084d9c 100644
--- a/_old_Pedonovation/app/src/main/res/layout/activity_graphs.xml
+++ b/_old_Pedonovation/app/src/main/res/layout/activity_graphs.xml
@@ -1,113 +1,113 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    tools:context=".AppActivities.GraphActivity">
-
-
-    <com.melisa.pedonovation.NoTouchScrollView
-        android:layout_width="match_parent"
-        android:layout_height="match_parent"
-        android:fadeScrollbars="false"
-        android:scrollbarSize="15dp"
-        android:scrollbarStyle="insideInset"
-        android:verticalScrollbarPosition="right">
-
-        <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:orientation="vertical"
-            android:padding="18dp">
-
-            <!-- Capacitive Graphs -->
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center_horizontal"
-                android:layout_marginTop="16dp"
-                android:text="Capacitive Data 'calcaneu'" />
-
-            <com.jjoe64.graphview.GraphView
-                android:id="@+id/graph_presure_1"
-                android:layout_width="match_parent"
-                android:layout_height="200dip"
-                android:layout_marginTop="48dp" />
-
-
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center_horizontal"
-                android:layout_marginTop="16dp"
-                android:text="Capacitive Data 'tarsiana'" />
-
-            <com.jjoe64.graphview.GraphView
-                android:id="@+id/graph_presure_2"
-                android:layout_width="match_parent"
-                android:layout_height="200dip"
-                android:layout_marginTop="48dp" />
-
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center_horizontal"
-                android:layout_marginTop="16dp"
-                android:text="Capacitive Data 'metatarsiana'" />
-
-            <com.jjoe64.graphview.GraphView
-                android:id="@+id/graph_presure_3"
-                android:layout_width="match_parent"
-                android:layout_height="200dip"
-                android:layout_marginTop="48dp" />
-
-
-
-            <!-- Accelerometer Graphs -->
-            <TextView
-                android:layout_width="wrap_content"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center_horizontal"
-                android:layout_marginTop="16dp"
-                android:text="Accelerometer Data x-axis" />
-
-            <com.jjoe64.graphview.GraphView
-                android:id="@+id/graph_acc_1"
-                android:layout_width="match_parent"
-                android:layout_height="200dip"
-                android:layout_marginTop="25dp" />
-
-            <TextView
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center_horizontal"
-                android:layout_marginTop="16dp"
-                android:text="Accelerometer Data y-axis" />
-
-            <com.jjoe64.graphview.GraphView
-                android:id="@+id/graph_acc_2"
-                android:layout_width="match_parent"
-                android:layout_height="200dip"
-                android:layout_marginTop="25dp" />
-
-            <TextView
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:layout_gravity="center_horizontal"
-                android:layout_marginTop="16dp"
-                android:text="Accelerometer Data z-axis" />
-
-            <com.jjoe64.graphview.GraphView
-                android:id="@+id/graph_acc_3"
-                android:layout_width="match_parent"
-                android:layout_height="200dip"
-                android:layout_marginTop="25dp" />
-        </LinearLayout>
-    </com.melisa.pedonovation.NoTouchScrollView>
-
-
-    <!-- Back Button -->
-
-
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".AppActivities.GraphActivity">
+
+
+    <com.melisa.pedonovation.NoTouchScrollView
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:fadeScrollbars="false"
+        android:scrollbarSize="15dp"
+        android:scrollbarStyle="insideInset"
+        android:verticalScrollbarPosition="right">
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:orientation="vertical"
+            android:padding="18dp">
+
+            <!-- Capacitive Graphs -->
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:layout_marginTop="16dp"
+                android:text="Capacitive Data 'calcaneu'" />
+
+            <com.jjoe64.graphview.GraphView
+                android:id="@+id/graph_presure_1"
+                android:layout_width="match_parent"
+                android:layout_height="200dip"
+                android:layout_marginTop="48dp" />
+
+
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:layout_marginTop="16dp"
+                android:text="Capacitive Data 'tarsiana'" />
+
+            <com.jjoe64.graphview.GraphView
+                android:id="@+id/graph_presure_2"
+                android:layout_width="match_parent"
+                android:layout_height="200dip"
+                android:layout_marginTop="48dp" />
+
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:layout_marginTop="16dp"
+                android:text="Capacitive Data 'metatarsiana'" />
+
+            <com.jjoe64.graphview.GraphView
+                android:id="@+id/graph_presure_3"
+                android:layout_width="match_parent"
+                android:layout_height="200dip"
+                android:layout_marginTop="48dp" />
+
+
+
+            <!-- Accelerometer Graphs -->
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:layout_marginTop="16dp"
+                android:text="Accelerometer Data x-axis" />
+
+            <com.jjoe64.graphview.GraphView
+                android:id="@+id/graph_acc_1"
+                android:layout_width="match_parent"
+                android:layout_height="200dip"
+                android:layout_marginTop="25dp" />
+
+            <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:layout_marginTop="16dp"
+                android:text="Accelerometer Data y-axis" />
+
+            <com.jjoe64.graphview.GraphView
+                android:id="@+id/graph_acc_2"
+                android:layout_width="match_parent"
+                android:layout_height="200dip"
+                android:layout_marginTop="25dp" />
+
+            <TextView
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center_horizontal"
+                android:layout_marginTop="16dp"
+                android:text="Accelerometer Data z-axis" />
+
+            <com.jjoe64.graphview.GraphView
+                android:id="@+id/graph_acc_3"
+                android:layout_width="match_parent"
+                android:layout_height="200dip"
+                android:layout_marginTop="25dp" />
+        </LinearLayout>
+    </com.melisa.pedonovation.NoTouchScrollView>
+
+
+    <!-- Back Button -->
+
+
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/layout/activity_login.xml b/_old_Pedonovation/app/src/main/res/layout/activity_login.xml
index 317fbd5..fe2ba34 100644
--- a/_old_Pedonovation/app/src/main/res/layout/activity_login.xml
+++ b/_old_Pedonovation/app/src/main/res/layout/activity_login.xml
@@ -1,56 +1,56 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    xmlns:card_view="http://schemas.android.com/apk/res-auto"
-    android:id="@+id/main"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:background="@drawable/loginbkg"
-    tools:context=".AppActivities.LoginActivity">
-
-    <androidx.cardview.widget.CardView
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:layout_margin="30dp"
-        android:layout_gravity="center_vertical"
-        android:background="@drawable/custom_edittext"
-        app:cardCornerRadius="30sp"
-        app:cardElevation="20dp">
-
-        <LinearLayout
-            android:layout_width="match_parent"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center_vertical"
-            android:orientation="vertical"
-            android:padding="24dp">
-
-            <TextView
-                android:id="@+id/loginText"
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content"
-                android:text="Login"
-                android:textAlignment="center"
-                android:textColor="@color/purple_login"
-                android:textSize="36sp"
-                android:textStyle="bold"
-                android:visibility="visible"></TextView>
-
-            <EditText
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content">
-
-            </EditText>
-
-            <EditText
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content">
-
-            </EditText>
-        </LinearLayout>
-    </androidx.cardview.widget.CardView>
-
-
-
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:card_view="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/main"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@drawable/loginbkg"
+    tools:context=".AppActivities.LoginActivity">
+
+    <androidx.cardview.widget.CardView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_margin="30dp"
+        android:layout_gravity="center_vertical"
+        android:background="@drawable/custom_edittext"
+        app:cardCornerRadius="30sp"
+        app:cardElevation="20dp">
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_vertical"
+            android:orientation="vertical"
+            android:padding="24dp">
+
+            <TextView
+                android:id="@+id/loginText"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:text="Login"
+                android:textAlignment="center"
+                android:textColor="@color/purple_login"
+                android:textSize="36sp"
+                android:textStyle="bold"
+                android:visibility="visible"></TextView>
+
+            <EditText
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content">
+
+            </EditText>
+
+            <EditText
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content">
+
+            </EditText>
+        </LinearLayout>
+    </androidx.cardview.widget.CardView>
+
+
+
 </LinearLayout>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/layout/activity_main.xml b/_old_Pedonovation/app/src/main/res/layout/activity_main.xml
index e27c086..ba4f58d 100644
--- a/_old_Pedonovation/app/src/main/res/layout/activity_main.xml
+++ b/_old_Pedonovation/app/src/main/res/layout/activity_main.xml
@@ -1,134 +1,134 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    tools:context=".AppActivities.MainActivity">
-
-    <LinearLayout
-        android:id="@+id/linearLayout"
-        android:layout_width="match_parent"
-        android:layout_height="50dp"
-        android:elevation="2dp"
-        android:orientation="horizontal"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent">
-
-        <Button
-            android:id="@+id/settings_bt"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginHorizontal="5pt"
-            android:onClick="LaunchSettings"
-            android:text="Settings" />
-
-        <Button
-            android:id="@+id/graph_view"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginHorizontal="5pt"
-            android:onClick="LaunchGraphView"
-            android:text="GraphView" />
-
-
-        <Space
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_weight="1" />
-
-        <Button
-            android:id="@+id/start_bt"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_marginHorizontal="5pt"
-            android:enabled="false"
-            android:onClick="startCommand"
-            android:text="Start" />
-    </LinearLayout>
-
-    <EditText
-        android:id="@+id/editTextTextMultiLine"
-        android:layout_width="194dp"
-        android:layout_height="85dp"
-        android:focusable="false"
-        android:ems="10"
-        android:gravity="start|top"
-        android:inputType="textMultiLine"
-        app:layout_constraintBottom_toTopOf="@+id/linearLayout"
-        app:layout_constraintStart_toStartOf="parent" />
-
-    <LinearLayout
-        android:id="@+id/linearLayout2"
-        android:layout_width="match_parent"
-        android:layout_height="200dp"
-        android:orientation="vertical"
-        tools:layout_editor_absoluteX="-16dp"
-        tools:layout_editor_absoluteY="36dp">
-
-        <TextView
-            android:id="@+id/TV_dataRight"
-            android:layout_width="match_parent"
-            android:layout_height="29dp"
-            android:layout_marginTop="20dp"
-            android:background="#C391CC"
-            android:fontFamily="sans-serif-black"
-            android:text="Data from the right device"
-            android:textAlignment="center"
-            android:textSize="16sp"
-            android:textStyle="bold" />
-
-        <TextView
-            android:id="@+id/feedbackDevice1"
-            android:layout_width="376dp"
-            android:layout_height="69dp"
-            android:text="TextView" />
-
-        <TextView
-            android:id="@+id/TV_dataLeft"
-            android:layout_width="match_parent"
-            android:layout_height="33dp"
-            android:background="#C391CC"
-            android:fontFamily="sans-serif-black"
-            android:text="Data from the Left device"
-            android:textAlignment="center"
-            android:textSize="16sp"
-            android:textStyle="bold" />
-
-        <TextView
-            android:id="@+id/feedbackDevice2"
-            android:layout_width="379dp"
-            android:layout_height="70dp"
-            android:text="TextView" />
-    </LinearLayout>
-
-    <ImageView
-        android:id="@+id/imageView4"
-        android:layout_width="411dp"
-        android:layout_height="282dp"
-        app:layout_constraintBottom_toTopOf="@+id/editTextTextMultiLine"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintHorizontal_bias="1.0"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toBottomOf="@+id/linearLayout2"
-        app:layout_constraintVertical_bias="0.658"
-        app:srcCompat="@drawable/position_lying_in_bed" />
-
-    <ToggleButton
-        android:id="@+id/toggleWriteData"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginEnd="16dp"
-        android:checked="false"
-        android:onClick="startWrittingData"
-        android:text="START Writting DATA"
-        android:textOff="START Writting DATA"
-        android:textOn="STOP Writting DATA"
-        app:layout_constraintBottom_toTopOf="@+id/linearLayout"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintTop_toBottomOf="@+id/imageView4" /><![CDATA[ />
-
-
-]]>
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".AppActivities.MainActivity">
+
+    <LinearLayout
+        android:id="@+id/linearLayout"
+        android:layout_width="match_parent"
+        android:layout_height="50dp"
+        android:elevation="2dp"
+        android:orientation="horizontal"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent">
+
+        <Button
+            android:id="@+id/settings_bt"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginHorizontal="5pt"
+            android:onClick="LaunchSettings"
+            android:text="Settings" />
+
+        <Button
+            android:id="@+id/graph_view"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginHorizontal="5pt"
+            android:onClick="LaunchGraphView"
+            android:text="GraphView" />
+
+
+        <Space
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_weight="1" />
+
+        <Button
+            android:id="@+id/start_bt"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginHorizontal="5pt"
+            android:enabled="false"
+            android:onClick="startCommand"
+            android:text="Start" />
+    </LinearLayout>
+
+    <EditText
+        android:id="@+id/editTextTextMultiLine"
+        android:layout_width="194dp"
+        android:layout_height="85dp"
+        android:focusable="false"
+        android:ems="10"
+        android:gravity="start|top"
+        android:inputType="textMultiLine"
+        app:layout_constraintBottom_toTopOf="@+id/linearLayout"
+        app:layout_constraintStart_toStartOf="parent" />
+
+    <LinearLayout
+        android:id="@+id/linearLayout2"
+        android:layout_width="match_parent"
+        android:layout_height="200dp"
+        android:orientation="vertical"
+        tools:layout_editor_absoluteX="-16dp"
+        tools:layout_editor_absoluteY="36dp">
+
+        <TextView
+            android:id="@+id/TV_dataRight"
+            android:layout_width="match_parent"
+            android:layout_height="29dp"
+            android:layout_marginTop="20dp"
+            android:background="#C391CC"
+            android:fontFamily="sans-serif-black"
+            android:text="Data from the right device"
+            android:textAlignment="center"
+            android:textSize="16sp"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/feedbackDevice1"
+            android:layout_width="376dp"
+            android:layout_height="69dp"
+            android:text="TextView" />
+
+        <TextView
+            android:id="@+id/TV_dataLeft"
+            android:layout_width="match_parent"
+            android:layout_height="33dp"
+            android:background="#C391CC"
+            android:fontFamily="sans-serif-black"
+            android:text="Data from the Left device"
+            android:textAlignment="center"
+            android:textSize="16sp"
+            android:textStyle="bold" />
+
+        <TextView
+            android:id="@+id/feedbackDevice2"
+            android:layout_width="379dp"
+            android:layout_height="70dp"
+            android:text="TextView" />
+    </LinearLayout>
+
+    <ImageView
+        android:id="@+id/imageView4"
+        android:layout_width="411dp"
+        android:layout_height="282dp"
+        app:layout_constraintBottom_toTopOf="@+id/editTextTextMultiLine"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintHorizontal_bias="1.0"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toBottomOf="@+id/linearLayout2"
+        app:layout_constraintVertical_bias="0.658"
+        app:srcCompat="@drawable/position_lying_in_bed" />
+
+    <ToggleButton
+        android:id="@+id/toggleWriteData"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginEnd="16dp"
+        android:checked="false"
+        android:onClick="startWrittingData"
+        android:text="START Writting DATA"
+        android:textOff="START Writting DATA"
+        android:textOn="STOP Writting DATA"
+        app:layout_constraintBottom_toTopOf="@+id/linearLayout"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintTop_toBottomOf="@+id/imageView4" /><![CDATA[ />
+
+
+]]>
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/layout/activity_start.xml b/_old_Pedonovation/app/src/main/res/layout/activity_start.xml
index c2774a5..24c3208 100644
--- a/_old_Pedonovation/app/src/main/res/layout/activity_start.xml
+++ b/_old_Pedonovation/app/src/main/res/layout/activity_start.xml
@@ -1,44 +1,44 @@
-<?xml version="1.0" encoding="utf-8"?>
-<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    xmlns:tools="http://schemas.android.com/tools"
-    android:id="@+id/main"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    tools:context=".AppActivities.StartActivity">
-
-    <Button
-        android:id="@+id/monPedo"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginBottom="44dp"
-        android:onClick="mainActivity"
-        android:text="mon_PEDO"
-        app:layout_constraintBottom_toTopOf="@+id/buttonLogin"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintHorizontal_bias="0.498"
-        app:layout_constraintStart_toStartOf="parent" />
-
-    <Button
-        android:id="@+id/buttonLogin"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginBottom="124dp"
-        android:onClick="LaunchLogin"
-        android:text="LOGIN"
-        app:layout_constraintBottom_toBottomOf="parent"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintHorizontal_bias="0.498"
-        app:layout_constraintStart_toStartOf="parent" />
-
-    <ImageView
-        android:id="@+id/imageView3"
-        android:layout_width="259dp"
-        android:layout_height="344dp"
-        app:layout_constraintBottom_toTopOf="@+id/monPedo"
-        app:layout_constraintEnd_toEndOf="parent"
-        app:layout_constraintStart_toStartOf="parent"
-        app:layout_constraintTop_toTopOf="parent"
-        app:srcCompat="@drawable/logo" />
-
+<?xml version="1.0" encoding="utf-8"?>
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/main"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context=".AppActivities.StartActivity">
+
+    <Button
+        android:id="@+id/monPedo"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="44dp"
+        android:onClick="mainActivity"
+        android:text="mon_PEDO"
+        app:layout_constraintBottom_toTopOf="@+id/buttonLogin"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintHorizontal_bias="0.498"
+        app:layout_constraintStart_toStartOf="parent" />
+
+    <Button
+        android:id="@+id/buttonLogin"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginBottom="124dp"
+        android:onClick="LaunchLogin"
+        android:text="LOGIN"
+        app:layout_constraintBottom_toBottomOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintHorizontal_bias="0.498"
+        app:layout_constraintStart_toStartOf="parent" />
+
+    <ImageView
+        android:id="@+id/imageView3"
+        android:layout_width="259dp"
+        android:layout_height="344dp"
+        app:layout_constraintBottom_toTopOf="@+id/monPedo"
+        app:layout_constraintEnd_toEndOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintTop_toTopOf="parent"
+        app:srcCompat="@drawable/logo" />
+
 </androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/layout/device_adapter_view.xml b/_old_Pedonovation/app/src/main/res/layout/device_adapter_view.xml
index 60dbac4..09fb672 100644
--- a/_old_Pedonovation/app/src/main/res/layout/device_adapter_view.xml
+++ b/_old_Pedonovation/app/src/main/res/layout/device_adapter_view.xml
@@ -1,30 +1,30 @@
-<?xml version="1.0" encoding="utf-8"?>
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:app="http://schemas.android.com/apk/res-auto"
-    android:orientation="vertical"
-    android:id="@+id/scanDeviceContainer"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:clickable="true"
-    android:focusable="true"
-    android:background="?android:attr/selectableItemBackground"
-    android:padding="10dp">
-
-    <TextView
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:id="@+id/tvDeviceName"
-        android:textSize="20sp"
-        android:text="test_devName"/>
-
-    <TextView
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:id="@+id/tvDeviceAddress"
-        android:clickable="true"
-        android:textSize="20sp"
-        android:text="test_devName"/>
-
-
-
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    android:orientation="vertical"
+    android:id="@+id/scanDeviceContainer"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:clickable="true"
+    android:focusable="true"
+    android:background="?android:attr/selectableItemBackground"
+    android:padding="10dp">
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tvDeviceName"
+        android:textSize="20sp"
+        android:text="test_devName"/>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:id="@+id/tvDeviceAddress"
+        android:clickable="true"
+        android:textSize="20sp"
+        android:text="test_devName"/>
+
+
+
 </LinearLayout>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher.xml b/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher.xml
index 6f3b755..3766e68 100644
--- a/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher.xml
+++ b/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher.xml
@@ -1,6 +1,6 @@
-<?xml version="1.0" encoding="utf-8"?>
-<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
-    <background android:drawable="@drawable/ic_launcher_background" />
-    <foreground android:drawable="@drawable/ic_launcher_foreground" />
-    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
 </adaptive-icon>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml b/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
index 6f3b755..3766e68 100644
--- a/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
+++ b/_old_Pedonovation/app/src/main/res/mipmap-anydpi/ic_launcher_round.xml
@@ -1,6 +1,6 @@
-<?xml version="1.0" encoding="utf-8"?>
-<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
-    <background android:drawable="@drawable/ic_launcher_background" />
-    <foreground android:drawable="@drawable/ic_launcher_foreground" />
-    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
+<?xml version="1.0" encoding="utf-8"?>
+<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
+    <background android:drawable="@drawable/ic_launcher_background" />
+    <foreground android:drawable="@drawable/ic_launcher_foreground" />
+    <monochrome android:drawable="@drawable/ic_launcher_foreground" />
 </adaptive-icon>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values-land/dimens.xml b/_old_Pedonovation/app/src/main/res/values-land/dimens.xml
index 5f681ae..66aa1bf 100644
--- a/_old_Pedonovation/app/src/main/res/values-land/dimens.xml
+++ b/_old_Pedonovation/app/src/main/res/values-land/dimens.xml
@@ -1,3 +1,3 @@
-<resources>
-    <dimen name="activity_horizontal_margin">48dp</dimen>
+<resources>
+    <dimen name="activity_horizontal_margin">48dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values-night/themes.xml b/_old_Pedonovation/app/src/main/res/values-night/themes.xml
index 752c400..fa77b5c 100644
--- a/_old_Pedonovation/app/src/main/res/values-night/themes.xml
+++ b/_old_Pedonovation/app/src/main/res/values-night/themes.xml
@@ -1,16 +1,16 @@
-<resources xmlns:tools="http://schemas.android.com/tools">
-    <!-- Base application theme. -->
-    <style name="Theme.PedometricSole" parent="Theme.MaterialComponents.DayNight.NoActionBar">
-        <!-- Primary brand color. -->
-        <item name="colorPrimary">@color/purple_200</item>
-        <item name="colorPrimaryVariant">@color/purple_700</item>
-        <item name="colorOnPrimary">@color/black</item>
-        <!-- Secondary brand color. -->
-        <item name="colorSecondary">@color/teal_200</item>
-        <item name="colorSecondaryVariant">@color/teal_200</item>
-        <item name="colorOnSecondary">@color/black</item>
-        <!-- Status bar color. -->
-        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
-        <!-- Customize your theme here. -->
-    </style>
+<resources xmlns:tools="http://schemas.android.com/tools">
+    <!-- Base application theme. -->
+    <style name="Theme.PedometricSole" parent="Theme.MaterialComponents.DayNight.NoActionBar">
+        <!-- Primary brand color. -->
+        <item name="colorPrimary">@color/purple_200</item>
+        <item name="colorPrimaryVariant">@color/purple_700</item>
+        <item name="colorOnPrimary">@color/black</item>
+        <!-- Secondary brand color. -->
+        <item name="colorSecondary">@color/teal_200</item>
+        <item name="colorSecondaryVariant">@color/teal_200</item>
+        <item name="colorOnSecondary">@color/black</item>
+        <!-- Status bar color. -->
+        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
+        <!-- Customize your theme here. -->
+    </style>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values-w1240dp/dimens.xml b/_old_Pedonovation/app/src/main/res/values-w1240dp/dimens.xml
index 7e06511..9d568d2 100644
--- a/_old_Pedonovation/app/src/main/res/values-w1240dp/dimens.xml
+++ b/_old_Pedonovation/app/src/main/res/values-w1240dp/dimens.xml
@@ -1,3 +1,3 @@
-<resources>
-    <dimen name="activity_horizontal_margin">200dp</dimen>
+<resources>
+    <dimen name="activity_horizontal_margin">200dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values-w600dp/dimens.xml b/_old_Pedonovation/app/src/main/res/values-w600dp/dimens.xml
index 5f681ae..66aa1bf 100644
--- a/_old_Pedonovation/app/src/main/res/values-w600dp/dimens.xml
+++ b/_old_Pedonovation/app/src/main/res/values-w600dp/dimens.xml
@@ -1,3 +1,3 @@
-<resources>
-    <dimen name="activity_horizontal_margin">48dp</dimen>
+<resources>
+    <dimen name="activity_horizontal_margin">48dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values/colors.xml b/_old_Pedonovation/app/src/main/res/values/colors.xml
index f06a911..d6840af 100644
--- a/_old_Pedonovation/app/src/main/res/values/colors.xml
+++ b/_old_Pedonovation/app/src/main/res/values/colors.xml
@@ -1,12 +1,12 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <color name="purple_200">#FFBB86FC</color>
-    <color name="purple_500">#FF6200EE</color>
-    <color name="purple_700">#FF3700B3</color>
-    <color name="teal_200">#FF03DAC5</color>
-    <color name="teal_700">#FF018786</color>
-    <color name="black">#FF000000</color>
-    <color name="white">#FFFFFFFF</color>
-    <color name="purple_login">#5D3FD3</color>
-    <color name="purple_Amaranth">#9F2B68</color>
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="purple_200">#FFBB86FC</color>
+    <color name="purple_500">#FF6200EE</color>
+    <color name="purple_700">#FF3700B3</color>
+    <color name="teal_200">#FF03DAC5</color>
+    <color name="teal_700">#FF018786</color>
+    <color name="black">#FF000000</color>
+    <color name="white">#FFFFFFFF</color>
+    <color name="purple_login">#5D3FD3</color>
+    <color name="purple_Amaranth">#9F2B68</color>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values/dimens.xml b/_old_Pedonovation/app/src/main/res/values/dimens.xml
index e00c2dd..0a7d9a5 100644
--- a/_old_Pedonovation/app/src/main/res/values/dimens.xml
+++ b/_old_Pedonovation/app/src/main/res/values/dimens.xml
@@ -1,5 +1,5 @@
-<resources>
-    <!-- Default screen margins, per the Android Design guidelines. -->
-    <dimen name="activity_horizontal_margin">16dp</dimen>
-    <dimen name="activity_vertical_margin">16dp</dimen>
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values/strings.xml b/_old_Pedonovation/app/src/main/res/values/strings.xml
index 3392104..575e845 100644
--- a/_old_Pedonovation/app/src/main/res/values/strings.xml
+++ b/_old_Pedonovation/app/src/main/res/values/strings.xml
@@ -1,12 +1,12 @@
-<resources>
-    <string name="app_name">Pedonovation</string>
-    <string name="title_activity_login">LoginActivity</string>
-    <string name="prompt_email">Email</string>
-    <string name="prompt_password">Password</string>
-    <string name="action_sign_in">Sign in or register</string>
-    <string name="action_sign_in_short">Sign in</string>
-    <string name="welcome">"Welcome !"</string>
-    <string name="invalid_username">Not a valid username</string>
-    <string name="invalid_password">Password must be >5 characters</string>
-    <string name="login_failed">"Login failed"</string>
+<resources>
+    <string name="app_name">Pedonovation</string>
+    <string name="title_activity_login">LoginActivity</string>
+    <string name="prompt_email">Email</string>
+    <string name="prompt_password">Password</string>
+    <string name="action_sign_in">Sign in or register</string>
+    <string name="action_sign_in_short">Sign in</string>
+    <string name="welcome">"Welcome !"</string>
+    <string name="invalid_username">Not a valid username</string>
+    <string name="invalid_password">Password must be >5 characters</string>
+    <string name="login_failed">"Login failed"</string>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/values/themes.xml b/_old_Pedonovation/app/src/main/res/values/themes.xml
index 901302e..febd3b5 100644
--- a/_old_Pedonovation/app/src/main/res/values/themes.xml
+++ b/_old_Pedonovation/app/src/main/res/values/themes.xml
@@ -1,16 +1,16 @@
-<resources xmlns:tools="http://schemas.android.com/tools">
-    <!-- Base application theme. -->
-    <style name="Theme.PedometricSole" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
-        <!-- Primary brand color. -->
-        <item name="colorPrimary">@color/purple_500</item>
-        <item name="colorPrimaryVariant">@color/purple_700</item>
-        <item name="colorOnPrimary">@color/white</item>
-        <!-- Secondary brand color. -->
-        <item name="colorSecondary">@color/teal_200</item>
-        <item name="colorSecondaryVariant">@color/teal_700</item>
-        <item name="colorOnSecondary">@color/black</item>
-        <!-- Status bar color. -->
-        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
-        <!-- Customize your theme here. -->
-    </style>
+<resources xmlns:tools="http://schemas.android.com/tools">
+    <!-- Base application theme. -->
+    <style name="Theme.PedometricSole" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
+        <!-- Primary brand color. -->
+        <item name="colorPrimary">@color/purple_500</item>
+        <item name="colorPrimaryVariant">@color/purple_700</item>
+        <item name="colorOnPrimary">@color/white</item>
+        <!-- Secondary brand color. -->
+        <item name="colorSecondary">@color/teal_200</item>
+        <item name="colorSecondaryVariant">@color/teal_700</item>
+        <item name="colorOnSecondary">@color/black</item>
+        <!-- Status bar color. -->
+        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
+        <!-- Customize your theme here. -->
+    </style>
 </resources>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/xml/backup_rules.xml b/_old_Pedonovation/app/src/main/res/xml/backup_rules.xml
index fa0f996..07e7d14 100644
--- a/_old_Pedonovation/app/src/main/res/xml/backup_rules.xml
+++ b/_old_Pedonovation/app/src/main/res/xml/backup_rules.xml
@@ -1,13 +1,13 @@
-<?xml version="1.0" encoding="utf-8"?><!--
-   Sample backup rules file; uncomment and customize as necessary.
-   See https://developer.android.com/guide/topics/data/autobackup
-   for details.
-   Note: This file is ignored for devices older that API 31
-   See https://developer.android.com/about/versions/12/backup-restore
--->
-<full-backup-content>
-    <!--
-   <include domain="sharedpref" path="."/>
-   <exclude domain="sharedpref" path="device.xml"/>
--->
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample backup rules file; uncomment and customize as necessary.
+   See https://developer.android.com/guide/topics/data/autobackup
+   for details.
+   Note: This file is ignored for devices older that API 31
+   See https://developer.android.com/about/versions/12/backup-restore
+-->
+<full-backup-content>
+    <!--
+   <include domain="sharedpref" path="."/>
+   <exclude domain="sharedpref" path="device.xml"/>
+-->
 </full-backup-content>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/main/res/xml/data_extraction_rules.xml b/_old_Pedonovation/app/src/main/res/xml/data_extraction_rules.xml
index 9ee9997..0ee2a78 100644
--- a/_old_Pedonovation/app/src/main/res/xml/data_extraction_rules.xml
+++ b/_old_Pedonovation/app/src/main/res/xml/data_extraction_rules.xml
@@ -1,19 +1,19 @@
-<?xml version="1.0" encoding="utf-8"?><!--
-   Sample data extraction rules file; uncomment and customize as necessary.
-   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
-   for details.
--->
-<data-extraction-rules>
-    <cloud-backup>
-        <!-- TODO: Use <include> and <exclude> to control what is backed up.
-        <include .../>
-        <exclude .../>
-        -->
-    </cloud-backup>
-    <!--
-    <device-transfer>
-        <include .../>
-        <exclude .../>
-    </device-transfer>
-    -->
+<?xml version="1.0" encoding="utf-8"?><!--
+   Sample data extraction rules file; uncomment and customize as necessary.
+   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
+   for details.
+-->
+<data-extraction-rules>
+    <cloud-backup>
+        <!-- TODO: Use <include> and <exclude> to control what is backed up.
+        <include .../>
+        <exclude .../>
+        -->
+    </cloud-backup>
+    <!--
+    <device-transfer>
+        <include .../>
+        <exclude .../>
+    </device-transfer>
+    -->
 </data-extraction-rules>
\ No newline at end of file
diff --git a/_old_Pedonovation/app/src/test/java/com/melisa/pedonovation/ExampleUnitTest.java b/_old_Pedonovation/app/src/test/java/com/melisa/pedonovation/ExampleUnitTest.java
index ab00169..ad83d20 100644
--- a/_old_Pedonovation/app/src/test/java/com/melisa/pedonovation/ExampleUnitTest.java
+++ b/_old_Pedonovation/app/src/test/java/com/melisa/pedonovation/ExampleUnitTest.java
@@ -1,17 +1,17 @@
-package com.melisa.pedonovation;
-
-import org.junit.Test;
-
-import static org.junit.Assert.*;
-
-/**
- * Example local unit test, which will execute on the development machine (host).
- *
- * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
- */
-public class ExampleUnitTest {
-    @Test
-    public void addition_isCorrect() {
-        assertEquals(4, 2 + 2);
-    }
+package com.melisa.pedonovation;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() {
+        assertEquals(4, 2 + 2);
+    }
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/build.gradle.kts b/_old_Pedonovation/build.gradle.kts
index 3756278..e26c896 100644
--- a/_old_Pedonovation/build.gradle.kts
+++ b/_old_Pedonovation/build.gradle.kts
@@ -1,4 +1,4 @@
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-plugins {
-    alias(libs.plugins.android.application) apply false
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+plugins {
+    alias(libs.plugins.android.application) apply false
 }
\ No newline at end of file
diff --git a/_old_Pedonovation/data/sample_date.in b/_old_Pedonovation/data/sample_date.in
index 3fae0d1..37dc41b 100644
--- a/_old_Pedonovation/data/sample_date.in
+++ b/_old_Pedonovation/data/sample_date.in
@@ -1,1200 +1,1200 @@
-0020 0021 00ff 340a 263c 39fa
-0021 0020 00ff 3407 2634 39fa
-0020 0020 00fe 340e 262e 39f7
-0021 0022 00ff 33fb 2636 39f0
-0022 0020 00ff 33f7 263a 39e3
-0020 001f 00ff 33f8 263d 39fd
-0021 001f 00ff 33ea 263d 3a11
-0020 0022 00ff 33e5 262e 3a1a
-0020 001f 0100 33d8 2644 3a21
-0020 0020 00ff 33ca 263f 3a2c
-0022 0020 00fe 33bc 2647 3a2f
-0021 001f 00ff 33b2 2654 3a25
-0020 0020 00ff 33ad 2655 3a28
-0021 001f 00fe 3390 2649 3a1a
-0021 0020 00fe 3399 2646 3a21
-0021 0020 00fd 3395 2643 3a11
-0021 0020 0100 338e 2636 3a1e
-0021 0020 0100 338b 2649 3a2f
-0020 0020 00ff 3387 2648 3a32
-0021 0020 00ff 3383 264f 3a38
-0020 0020 00fe 3387 2651 3a3e
-0021 0020 0100 338b 2653 3a36
-0021 0021 00ff 3388 2651 3a35
-0021 0020 0101 338c 264c 3a29
-0021 0021 00fe 337c 264f 3a1e
-0021 001f 00fe 3387 2658 3a24
-0021 0020 00fe 339c 2656 3a1e
-0020 001f 0100 33b1 2653 3a1f
-0020 0020 00ff 339d 2654 3a17
-0021 001e 00fd 3392 2657 3a12
-0021 0022 00fe 339f 2657 3a1a
-0022 001f 00ff 33a2 2657 3a26
-0020 001f 00ff 33aa 2653 3a20
-0021 001f 00ff 339d 2649 3a1d
-0022 001f 0100 339a 265c 3a1f
-0022 001f 0100 33a5 2669 3a25
-0022 0020 00fe 33a5 265b 3a2c
-0022 0020 0100 33a9 2658 3a29
-0020 001e 00ff 33a6 264c 3a2f
-0022 0021 00fd 33a4 2645 3a29
-0022 0021 0100 339d 2646 3a2b
-0022 0020 00ff 33ae 263c 3a2b
-0021 001f 00ff 33bd 263e 3a32
-0021 0020 0100 33cb 2641 3a2b
-0020 0021 00ff 33d1 2646 3a20
-0021 0020 00ff 33d5 2630 3a0f
-0021 0021 00ff 33e2 2640 3a08
-0022 0020 0100 33fd 2637 39f4
-0021 0020 0100 33fc 2634 39f2
-0020 0021 00ff 33fb 262b 39eb
-0020 0020 0100 341e 2626 39d9
-001f 0020 0100 343a 2621 39d5
-0021 0021 00ff 342c 262a 39ca
-0020 0020 00ff 342d 2625 39d5
-0021 0020 00ff 343b 2621 39e0
-0020 0021 00ff 343d 2629 39d7
-001f 0021 00ff 343a 261d 39e3
-0021 0020 00ff 3441 2629 39db
-0020 0020 00fd 344e 2626 39e7
-0020 0020 00ff 3459 261f 39e5
-0021 001f 00ff 3437 262a 39ef
-0020 001f 00ff 3448 2624 39ed
-0021 0020 0100 3443 2623 39f1
-0022 0021 00ff 343f 2630 39fb
-0021 001f 00ff 3448 262f 39f2
-001f 001f 00ff 342f 262b 39f3
-0021 0020 00fe 3434 262c 39ed
-0021 0021 00ff 343a 2634 39ea
-0020 0020 00ff 342d 2627 39ec
-001f 0020 00fe 3438 2631 39e2
-0020 0021 0100 3433 2637 39e7
-0020 001f 0100 342d 262b 39e1
-0021 0020 00fe 343e 262c 39e2
-0021 001d 00ff 344f 2624 39dc
-0020 0020 0100 342f 262d 39d8
-0021 0021 00fe 341c 2622 39d8
-0020 0020 00ff 3420 2637 39df
-0021 0020 00ff 342a 263c 39d7
-0021 0021 00ff 3427 262d 39eb
-0023 0020 00ff 341f 2632 39e7
-0020 0021 0100 3410 262c 39ea
-0021 001e 00ff 3422 2628 39eb
-0021 0020 00ff 342b 2620 39f1
-0021 001e 00fe 341f 261f 39f3
-0020 0020 00fe 342b 2630 39ec
-0020 001f 0100 3425 261d 39e9
-0021 0020 00ff 3437 2637 39e4
-0021 001f 0100 343f 2621 39f2
-0021 001f 00ff 3429 262c 39eb
-0020 001f 00ff 341f 2624 39f2
-0020 001f 00fd 3424 2634 39fd
-001f 0020 00ff 3432 2639 39f9
-0020 0021 0100 342f 2631 39fd
-0021 0020 0100 3411 2639 3a0e
-0021 0021 00fe 341b 2634 3a06
-0022 001f 00ff 3407 2647 3a06
-0021 0020 00ff 3427 2645 3a04
-0022 0021 00ff 341f 2648 3a08
-0020 0020 00ff 33f7 2647 3a06
-0020 0021 0100 3403 2648 39fb
-0020 0020 00ff 3413 2642 3a06
-0020 001f 00ff 3410 2640 3a00
-0020 0020 00ff 3415 2653 3a03
-0020 001f 00fe 340c 264a 39f8
-001f 001e 0100 341c 2641 39fb
-0021 0020 00fe 3420 264d 39f2
-0020 001f 00fe 3427 2644 39f2
-0021 0020 00ff 3433 2654 39e8
-0020 0020 00fe 3412 264c 39e6
-001f 001f 0100 3436 264d 39d9
-0020 001f 0101 343a 2649 39d3
-0021 0021 00ff 3431 2646 39d4
-001f 001f 00fe 3426 264c 39d4
-0021 001f 00ff 3440 264d 39c9
-0021 001f 0100 343f 2647 39cf
-0020 0020 0100 344e 263f 39cf
-0022 0020 00fe 3445 263e 39d8
-001f 0021 0100 342d 2638 39e8
-0020 001f 0100 342a 2642 39e9
-001f 0020 00fe 3439 263b 39f0
-0020 001e 00ff 343d 2636 39f0
-0020 001e 00fc 3417 2643 39ff
-001f 001e 00ff 3429 2644 39f5
-0020 001f 00fd 3437 263d 39fe
-0020 0020 0100 341e 2645 3a0b
-0021 0020 00ff 3419 2644 3a0d
-0020 0021 00ff 3427 2642 3a03
-001f 0020 00ff 342e 2638 3a07
-0021 001e 00ff 341e 2643 39fc
-0021 001e 00ff 342c 263b 39e9
-0020 001f 00ff 341f 2635 39d6
-0021 0021 00ff 342b 2637 39da
-0020 0020 00ff 3437 2632 39d1
-0020 001f 00ff 3439 2633 39e1
-0021 0020 0100 3445 2633 39dd
-0020 0020 00ff 343a 262c 39d5
-0021 0020 00fe 3459 2630 39d4
-001f 001f 00ff 3441 262f 39de
-0021 0020 00ff 344e 262b 39e1
-0020 001f 00ff 343f 2628 39e3
-0021 0020 00ff 345e 262a 39dd
-0021 001f 00ff 345b 262d 39db
-0021 0020 00ff 3445 262a 39d7
-0020 0020 00ff 3450 262f 39d6
-0021 0021 00ff 3456 262e 39d5
-001f 001f 00ff 3442 2635 39db
-0020 0020 0101 3433 263d 39d8
-0020 001f 00ff 3440 2632 39d8
-0020 001f 00ff 343e 2633 39dc
-001f 0020 00fe 3437 2630 39da
-0020 001f 00ff 343a 2630 39e0
-001f 001f 00ff 341d 2627 39da
-001f 0020 00fe 3440 2630 39d8
-0020 0021 0100 3438 261c 39db
-001f 001e 00ff 3437 2620 39d5
-0021 0021 00ff 343d 2620 39d6
-001f 0020 0100 3431 2611 39d8
-0020 001f 00fe 3438 2625 39d9
-0021 001f 0100 3444 2625 39cc
-0020 001f 00ff 3439 262b 39c8
-0020 0020 00ff 3433 2631 39cf
-0020 001f 00ff 3420 263a 39cb
-0021 0020 00ff 342e 2634 39d4
-0021 001f 00ff 3435 2639 39d6
-0023 0020 00ff 3424 2636 39cf
-0021 0021 00fe 3424 262d 39ca
-0020 0020 00ff 341a 263e 39ca
-0020 0020 00ff 3438 2631 39c3
-0020 0020 00ff 3446 2633 39be
-0021 0020 00ff 3430 2639 39ba
-0020 0021 00ff 3434 2636 39bd
-0020 001f 00ff 342b 2638 39ba
-0020 0020 00fe 3436 262a 39b7
-0021 0021 00fe 3451 263a 39b4
-0020 0020 00ff 343e 2630 39b1
-0020 0021 00fe 3438 262d 39a9
-0021 0020 00ff 344b 263c 39ad
-0020 0020 00ff 3451 2628 39a3
-0020 001e 00fe 345e 261e 39a8
-001f 001f 00ff 3469 262e 399f
-0020 0020 0100 346c 2612 39a1
-0020 001f 00ff 346f 2616 3996
-001f 0020 00fe 3482 2619 39a2
-0020 001f 00ff 347f 261f 39a2
-0021 001f 00fe 346c 2619 39a8
-0021 001f 00ff 3484 2629 39a4
-001f 001f 00fe 348b 2621 39a1
-0020 0020 00ff 347f 261e 39a3
-0020 0020 0100 3484 2620 39a5
-0020 001f 00ff 347e 2624 39a4
-0021 001f 00fe 348d 261f 39a7
-001f 001e 00ff 3487 2622 39a6
-0021 0020 0100 346e 2613 39a2
-0021 001f 00ff 3484 261b 39a3
-001f 0020 0100 3491 261c 39a1
-0021 0020 00fd 348a 260c 39a6
-0020 001f 00ff 347f 261c 39a9
-0020 001e 00ff 3487 261b 39a2
-0020 0020 00fe 3486 261c 399e
-0020 001f 00fe 3488 2617 39a1
-0020 0020 00fe 3486 2605 39a3
-0021 001f 00ff 345d 2620 39ae
-0021 001f 00ff 3474 2619 39b3
-0020 001f 00fe 3488 261c 39b6
-0022 0021 00fe 3481 262a 39bc
-0021 001f 0100 3479 2632 39b8
-001f 0020 0100 3477 2626 39b2
-0021 001f 0100 347d 2630 39b3
-0020 0020 00ff 347f 2638 39bc
-0020 0020 00fe 3480 2633 39be
-0020 0020 00ff 3476 2630 39bf
-0021 001f 00ff 3476 262c 39b8
-001f 0020 00fd 3483 2638 39b9
-0020 001f 0100 3487 2639 39be
-0020 001f 00fe 348b 263d 39b9
-0021 0020 00ff 348b 2636 39c1
-0020 001e 00ff 3490 2628 39c5
-0021 0020 0100 348a 262c 39ba
-0020 001e 00ff 3495 261e 39ba
-0020 001e 0100 3482 262e 39c3
-0021 001f 00ff 3495 261b 39bf
-001f 0020 00ff 349c 262e 39b9
-001f 0021 00ff 3496 2626 39b1
-0020 001f 00ff 3487 2628 39b0
-0020 001f 00ff 3493 2623 39aa
-0020 0020 00ff 3498 2627 39b0
-0021 0020 0100 3499 261c 39af
-0021 0022 00fe 3481 2623 39ae
-0020 0020 0100 3494 2624 39ab
-0020 001e 0100 34a3 2624 39a9
-0020 0021 00ff 3494 2623 39af
-0021 0020 00fe 348c 262e 39b4
-0020 0020 0100 348e 2626 39b4
-0021 0020 00fe 3493 261b 39ae
-0021 0020 00ff 3496 2628 39ad
-001f 001f 00ff 3498 262d 39aa
-001f 0020 0101 3485 262b 39ac
-0020 0020 00ff 3484 2621 39b4
-0021 0020 00ff 3495 2622 39b4
-0020 0020 00ff 348e 262b 39c3
-001f 0021 00ff 3488 2614 39c5
-0021 0020 00ff 346f 2620 39c1
-0020 0020 00fe 347a 2635 39cb
-0021 001f 0100 348a 2634 39bc
-0021 001f 00fe 3476 2640 39bc
-001f 001f 00ff 347a 263a 39b3
-0020 0020 00fe 347f 263b 39b3
-001f 0020 00ff 3486 2641 39a6
-001f 0020 00ff 3472 263f 39a1
-0020 0020 00ff 348a 262a 399b
-001f 001f 00fe 3483 2628 39a2
-0020 001f 00ff 3485 262d 39a6
-001f 001f 00ff 3477 262f 39a4
-0021 0021 00ff 3472 2625 39a8
-0020 0020 00fe 348d 2629 39a5
-0020 001f 00fe 3480 2612 399e
-0021 0020 0100 3480 2618 39a0
-001f 0020 00ff 346a 2624 39ac
-0020 001f 00ff 3468 2621 39b8
-0021 0021 00fd 3481 2628 39bd
-001f 0020 00ff 3466 2625 39c4
-0021 0020 00fe 346b 2631 39c0
-0020 0020 00ff 3450 2637 39c6
-0021 001f 00ff 345d 2634 39d5
-001f 0020 00ff 3462 2639 39d3
-001f 0020 00ff 345c 2638 39cc
-0021 0020 0100 345e 2648 39d1
-001f 001f 00fe 3457 263e 39b7
-001f 0020 00fd 3455 263a 39af
-0021 001f 00ff 3469 263b 39a9
-0021 001e 0100 345d 262c 39b5
-001f 0021 0100 344a 2638 39b2
-0020 001f 0100 3468 263a 39ae
-0020 001f 00fe 346a 2637 39ad
-0021 0021 00ff 345d 263b 39b3
-0021 0020 00ff 3464 2639 39af
-0021 001f 00ff 345e 2636 39bb
-001d 001f 00ff 346d 2631 39b7
-0020 001e 0100 3456 263b 39bb
-001f 001f 00ff 3446 2648 39c2
-0020 0020 00ff 3445 263c 39d3
-0021 0020 00fd 3452 2644 39d0
-0022 0020 00ff 3452 2646 39df
-0021 001f 00ff 342d 2645 39e2
-0020 001f 00ff 3445 2644 39d9
-0023 0021 00ff 3447 263f 39cd
-001f 001f 00fe 343a 2635 39d2
-0020 0020 00fe 3436 2635 39de
-0020 0021 00fe 342c 263b 39d1
-0021 0020 00fe 3435 2643 39cf
-0021 001f 00ff 344a 2630 39d9
-0022 001f 00ff 3435 2644 39cd
-0021 0020 00fe 341d 2638 39c1
-0020 0020 00ff 3427 263e 39bf
-0020 001f 00fe 3448 263a 39cc
-0021 0020 00fe 341c 2636 39d5
-001f 001f 00fe 342d 2636 39d4
-0022 001f 00ff 3423 2634 39e1
-0022 0020 0100 342d 2635 39e4
-0020 001f 00ff 341c 2641 39e6
-0020 0021 00ff 3416 2635 39f2
-0020 0020 0100 3418 2632 39f8
-0022 0020 00ff 3404 263d 39f5
-0020 0020 00ff 340e 2644 39fa
-0020 001f 0100 340b 262c 39e7
-0021 0020 00ff 33fc 2633 39e5
-0020 0020 00fd 340a 263f 39e3
-0020 0021 0100 3419 263b 39e4
-0021 001d 00ff 3413 263e 39e3
-0020 001f 00ff 341b 263d 39d9
-0021 001f 00ff 3412 2630 39d9
-001f 001e 00fe 3414 263b 39d3
-0021 0021 00ff 341c 263b 39d1
-0020 0020 00fe 3407 2634 39cb
-001f 001f 0100 3412 2638 39c7
-0020 001f 0100 3421 2630 39c7
-0020 0020 00ff 340d 263b 39ec
-0021 0020 00ff 3403 262d 39ea
-0020 001f 00fe 3406 2630 39f0
-0021 0020 00ff 3408 2637 39f1
-0020 0020 00fe 341d 263b 39f7
-0021 001f 00ff 3415 2625 39fc
-0020 0020 00fe 3418 2638 39f6
-0021 001f 00ff 3414 263b 3a08
-0021 001e 00fe 3421 2646 39f6
-0021 0021 00ff 3410 2636 39f2
-0020 0020 00fe 340f 2630 39e7
-0020 001f 0100 3410 263c 39f5
-0020 001f 00ff 3410 263b 39ec
-0022 0020 00ff 3401 2647 39ec
-0020 0021 00ff 33fe 263d 39e0
-0021 0021 0100 3406 263b 39e9
-0020 0022 00ff 3408 2638 39f2
-0021 0020 0100 3413 2641 39f9
-0020 0022 00ff 3402 2628 39e8
-0021 0021 0100 3401 2636 39fa
-0021 0021 00ff 3414 2640 39fe
-0021 0020 00ff 3424 2639 39fc
-0021 001f 0100 3414 2639 3a04
-0021 0020 00ff 3402 262e 39ff
-0021 0020 00ff 3416 2635 39fb
-0021 0020 00fd 3427 2638 39eb
-001f 001f 00ff 341c 2637 39e7
-0020 0020 00ff 3408 2640 39e0
-0020 0020 00ff 3434 2639 39d6
-0020 0020 00fe 3434 2634 39df
-0021 0020 0100 342a 2636 39e7
-0021 0020 00fe 342a 2634 39e5
-0021 001f 00ff 3432 263e 39f2
-0020 001f 00ff 343d 2642 39f8
-0020 0021 0100 342c 263e 39fd
-0021 0020 00ff 341e 2632 39ee
-0020 0022 00ff 343b 2638 39e7
-0020 001f 00fe 3437 2649 39e4
-0020 001f 00ff 342a 2647 39e7
-001f 0021 00ff 3420 2640 39d3
-0021 001f 00ff 3428 263f 39e2
-001f 0022 00fe 3432 2651 39e7
-0020 0021 00ff 3430 2650 39f9
-0020 0020 00ff 340c 2652 3a03
-0021 001f 00fe 3420 264b 39fe
-0021 001f 00ff 3420 2652 39f4
-0021 0020 0100 3423 265b 39eb
-0020 0020 00fe 3410 264c 39ee
-0020 001f 0101 3414 2653 39d7
-0021 0020 00ff 3419 2646 39ec
-0020 001f 00ff 3402 2650 39fc
-0021 001f 00ff 3417 264b 39ff
-0022 001f 00fe 3417 264b 3a05
-0021 001f 00fe 340c 2650 3a0c
-001f 0021 00fe 33f3 264f 3a06
-0021 001e 00ff 33fa 264a 39fc
-0020 0020 00ff 3404 264b 39f5
-0020 0020 0100 3402 2659 39fc
-0021 0020 0100 33f8 2651 39f2
-0021 0020 0100 33f1 264a 39f0
-001f 0020 0100 33f4 2650 39f1
-0020 0020 00ff 33fd 2659 3a01
-0021 0020 00fe 3403 2648 3a03
-0022 0021 0100 33f1 264f 3a0f
-0020 001e 00ff 33ea 2658 3a0c
-0020 001f 00fe 33e7 265a 3a19
-001f 0020 00fe 3402 2656 3a0d
-0021 0021 00ff 33f4 2654 3a08
-0021 0020 00ff 33df 2651 3a0a
-0020 0021 00fe 33e7 264a 3a03
-0020 001f 0100 33f3 2656 39fb
-0020 001e 00fe 33ee 2654 39fd
-0020 0020 00fd 33f1 2647 39f4
-0021 001f 00ff 33db 2650 39ff
-0020 0020 00ff 33ec 2653 3a01
-0021 001f 00ff 33e7 2652 3a08
-0021 001f 00fe 33e8 2653 3a08
-0021 001f 00ff 33d2 2655 3a14
-0020 0020 00ff 33d8 2654 3a19
-001f 0020 0100 33eb 264c 3a0e
-0021 0020 00ff 33d3 264d 3a02
-001f 0020 00ff 33e9 2654 3a02
-0021 0020 00ff 33df 2656 39ff
-0020 0021 00fe 33d6 264c 39fb
-0021 001f 0100 33ef 2651 39f5
-0020 001f 00ff 33e7 2634 39e8
-0021 0020 00fe 33e5 2648 39e8
-0021 001f 00ff 33e4 2646 39ec
-0020 0021 00ff 33f6 2644 39f2
-001f 001f 0100 33f3 263c 39f9
-0021 0020 00fe 33f7 2652 3a00
-0020 0022 00ff 33e5 2646 3a02
-0021 001e 00ff 33e9 2644 3a04
-0021 001f 0100 33e8 264d 3a02
-0021 0020 00fe 33e8 2648 3a03
-0021 0020 00fe 33fa 2632 3a04
-0021 001f 0100 33f6 263e 3a01
-0022 001f 00ff 3401 2649 39f1
-0021 001f 00fe 33ee 2645 39e7
-0021 0022 00ff 3402 2643 39ec
-0020 0020 0100 3413 263b 39dc
-0021 0020 00fe 3417 2642 39dd
-001f 001f 00ff 33f4 2636 39cd
-0021 001f 00fe 3404 2640 39c8
-0020 001f 00ff 3426 264d 39da
-001f 001f 00ff 3421 2644 39d8
-0021 0020 00ff 3412 264c 39d0
-0020 0020 00ff 341f 264a 39e0
-0022 001f 0100 342d 264a 39e0
-0021 001f 0100 3427 264a 39d9
-0020 001f 00fe 3427 2641 39dd
-0021 0020 00ff 343a 2639 39d6
-0020 0020 00ff 342b 263e 39e3
-0020 0020 00ff 3436 263a 39de
-001e 0021 00ff 3437 2646 39e6
-0021 0020 00ff 342e 263f 39eb
-001f 0020 00fd 342b 2645 39e8
-0020 0020 00ff 3427 2645 39dd
-0021 001f 00fe 3420 2647 39dd
-0020 0021 00ff 3416 2642 39d8
-0020 0020 00ff 3412 2643 39dd
-0021 001f 0100 3420 264a 39d9
-0020 0021 00fe 341f 263b 39e5
-0022 0021 00ff 3412 2645 39dc
-001f 0020 00fe 3425 263d 39ce
-0020 0021 0100 341c 2638 39cb
-0022 0022 00ff 3423 263a 39cc
-0020 0020 0100 3421 2635 39c9
-0020 0021 00fe 340c 262f 39c8
-0021 0020 00ff 3422 262d 39c8
-0020 0021 00ff 342f 2630 39c6
-0022 001f 00ff 3431 2637 39bd
-0020 0021 00ff 3426 262c 39bb
-0021 0021 00ff 3439 2633 39c9
-0021 0022 00fe 341e 263d 39d3
-0020 001f 00fe 341f 263f 39ce
-0020 001f 0100 3422 2637 39d4
-0021 0020 00ff 341a 263a 39e1
-0020 001f 00ff 3422 2633 39e4
-0021 001f 00fe 3412 262f 39e1
-0021 0022 00fe 33fd 2632 39e0
-0021 0021 00ff 341a 262f 39e7
-0021 0020 00ff 3423 2638 39e5
-0020 0020 00ff 3413 2635 39e2
-0020 001f 00ff 3420 262d 39f0
-0021 001f 00ff 3412 2637 39ec
-0021 001e 00ff 3410 262b 39e4
-0020 001f 00ff 3418 262f 39e5
-0020 001f 00fe 3416 262b 39e2
-0021 0020 00ff 3411 2622 39d3
-0023 001f 00fe 3408 262d 39d1
-0020 001f 0100 342b 2629 39d4
-0021 0020 0100 3419 262c 39c5
-0021 0020 00ff 3405 2627 39c8
-0020 0020 0100 340d 262b 39c5
-0020 001e 00ff 3422 262f 39d2
-0022 0020 00ff 341a 2633 39da
-0020 001f 00ff 340e 2642 39d4
-0021 001f 00ff 3415 2628 39da
-0021 001f 00fc 340d 2625 39e3
-0021 001f 0100 33fb 2629 39e6
-0021 001e 00ff 340c 2634 39f0
-0021 0021 00fe 3424 262b 39f8
-0021 0020 00fe 3413 262b 39e0
-0022 0020 00ff 33fe 262f 39d9
-0020 0021 00ff 341e 262b 39dc
-001f 001e 00ff 3421 2638 39db
-0020 001f 00ff 341b 262b 39df
-0022 0020 0100 340e 2632 39dd
-0020 0020 00fe 3418 263f 39d6
-0021 001e 00ff 341d 2625 39ce
-0020 001e 00ff 340e 2632 39d2
-0020 0020 00fe 3416 2631 39ce
-0020 001f 00fd 3406 2635 39c4
-0021 0020 0100 341a 2634 39c9
-0022 001f 00ff 3416 2631 39ce
-0021 0020 00ff 340c 262e 39e7
-0020 0021 00fe 3411 263c 39f0
-0021 0020 00ff 3414 2632 39ee
-0021 001f 00fe 3414 262d 39da
-0022 001f 00ff 3411 262c 39d6
-001f 0020 0100 3421 2632 39d6
-0021 001e 0100 3422 2630 39d0
-0020 0020 00ff 3425 2632 39ca
-0020 0020 0100 3420 2627 39c0
-0020 001e 00ff 342f 262a 39c1
-0020 0020 00ff 3436 262c 39c3
-0020 001f 00ff 343d 262a 39b4
-0021 0021 0100 341a 261c 39b6
-0020 001f 00fe 3427 2627 39b6
-0020 001f 00ff 3449 262d 39b6
-0021 001f 00fe 3421 262c 39be
-0020 0020 00ff 341b 263c 39c3
-0020 0020 00fe 3439 262b 39c0
-001f 001f 00ff 342f 262b 39c3
-001f 0020 00ff 3428 2628 39cc
-0021 0020 00ff 3416 2632 39cd
-0020 0021 0100 3426 263a 39ce
-0020 001f 0100 3433 2635 39ca
-0020 001f 0100 3425 262d 39e3
-0021 001f 0100 341c 2630 39e8
-0021 001e 00fd 3418 2634 39e6
-0021 001f 00fe 3434 262c 39e4
-001f 0020 00fe 341d 263b 39e6
-0020 0020 00ff 3427 2639 39e2
-0020 001e 0100 3418 2640 39db
-0020 0020 0100 3419 263e 39d4
-0020 0020 00ff 3427 263f 39de
-0021 001f 00ff 3427 2635 39db
-001f 001f 00ff 340a 263a 39dd
-0020 0020 00fe 3419 2633 39d2
-0022 0020 0100 3434 2637 39cc
-0021 001f 00fe 3422 2638 39cf
-0020 0021 00ff 3414 2634 39ce
-0020 001f 00ff 3410 262e 39ca
-0020 001f 00ff 3417 262f 39c1
-0021 0021 00ff 341d 2638 39c7
-0020 001f 0100 3411 262f 39c5
-0021 0020 00fe 340c 263c 39c6
-0020 001e 0100 3407 262b 39cb
-0021 001f 00ff 3415 263e 39cf
-0021 001f 0100 3412 2637 39db
-0020 0020 00ff 3409 262f 39d0
-0021 0021 0100 3416 2629 39db
-0021 0020 00ff 3408 263d 39da
-0020 0021 00ff 3413 2630 39dd
-0022 0020 0100 3408 262f 39e3
-0020 0020 0100 33f7 2630 39e1
-0021 001f 00ff 3405 2634 39ea
-0022 0021 00ff 340c 262c 39e9
-0021 0021 00fe 340e 262c 39e8
-0020 001e 00ff 33ee 2628 39e9
-0020 0020 00ff 3402 2632 39e7
-0021 001f 0100 33fa 2621 39fa
-0021 0020 00ff 33fd 2620 39f3
-0021 001e 00ff 3402 2624 39f9
-0020 0020 00ff 340c 2626 39db
-0021 0020 00ff 3404 2632 39d2
-0020 0021 00ff 33f2 2631 39c8
-0020 0021 0100 33ff 262d 39c7
-0021 0021 0100 3400 2625 39d5
-0021 0020 00ff 3401 262a 39d7
-0021 0020 00fe 33fe 2621 39d3
-0020 001f 00fe 3400 262b 39d8
-0021 001f 00ff 3406 2628 39df
-0021 001f 00fe 3414 2626 39e0
-0020 0021 00ff 341e 262a 39e2
-0021 001f 0100 3409 262e 39e0
-0020 0020 00ff 341e 2625 39e0
-001f 0020 00fe 341b 2628 39e9
-0021 0020 00ff 342b 262c 39e7
-0021 0020 0100 3422 262c 39e7
-0020 0020 00ff 341f 262b 39e8
-0020 001f 0100 341c 262d 39e0
-0020 001f 00ff 3414 262a 39d2
-0020 0021 00ff 3421 262e 39da
-0020 001f 0100 3436 2631 39d1
-0021 0020 0100 3425 2631 39c9
-0020 001f 00ff 3424 2628 39c9
-0020 0020 00ff 341f 262c 39c8
-001f 001f 00fe 342c 2628 39be
-0022 0021 00ff 3423 262c 39b2
-0021 0020 00ff 342b 2632 39c6
-0020 001f 00ff 3433 262d 39c5
-0020 0020 00ff 3447 2629 39c7
-0021 0020 00ff 3438 263c 39d2
-0020 0020 00fe 3428 2636 39d1
-0021 0021 00ff 343a 262b 39d1
-0021 0020 00fe 3443 2630 39dd
-0020 0020 00ff 3438 262c 39de
-0020 0021 00ff 3438 2624 39df
-001f 001f 00ff 3447 2638 39df
-001f 0020 00ff 3449 2633 39d3
-001f 0020 0100 3435 2626 39ca
-001f 001f 00fe 343f 2637 39ce
-001f 001f 0101 344c 263b 39cf
-0020 0020 00ff 3452 2634 39c4
-0020 0021 00fe 343b 2629 39c2
-0021 0021 0100 3449 2625 39be
-0020 0021 00ff 344e 2626 39ad
-0021 001f 00fe 3443 262b 39a8
-0021 001e 0100 344d 262e 39ac
-0020 001f 00fe 3436 2627 39ba
-0021 001f 00ff 3445 262a 39b6
-0020 0020 00ff 3430 262b 39bc
-0021 0020 00ff 3427 262e 39c2
-0020 0020 00ff 3443 2625 39c1
-0020 0022 00ff 342c 261d 39c2
-0021 0020 0100 3426 2622 39c0
-0021 001e 00ff 3429 262b 39c6
-0020 001e 00ff 3436 2626 39cb
-0020 0020 00fe 342e 2626 39cc
-0021 0020 00ff 342d 2635 39d0
-0020 001f 0101 342e 2624 39d5
-0021 0020 00ff 3433 263a 39d3
-0020 001f 00ff 342c 2626 39db
-0021 0020 00ff 3423 2632 39d2
-001f 0020 00fe 3433 2621 39c8
-0020 0021 00fe 3442 2640 39c4
-0020 001f 00ff 3439 2627 39c0
-0020 001f 00ff 3430 2625 39be
-0020 001f 00fe 3432 2627 39b2
-0020 0020 00ff 3448 262b 39ae
-001f 001f 00ff 342f 262e 39ab
-0020 0020 0100 3432 262d 39a7
-001f 0020 0100 3438 2631 39b5
-0020 0020 00ff 3442 2639 39c0
-0021 0021 00ff 342a 2638 39c6
-0020 0020 00ff 3422 262f 39c1
-0020 0020 0100 3427 262d 39bb
-0021 001f 00ff 343e 262c 39ca
-0021 0020 00ff 3425 2635 39d0
-0020 001f 00ff 341a 2629 39cd
-0020 0021 00ff 3419 262f 39dc
-0020 0020 00fe 3428 262d 39cc
-0021 001f 0100 3423 2631 39ca
-001f 0020 0100 342a 262d 39c9
-0020 001f 0100 342e 2629 39c6
-0021 0021 0101 3421 2636 39ba
-0020 0021 00fe 341a 2637 39bc
-0021 0020 00ff 341e 2638 39a8
-0021 0020 0101 342d 264a 39aa
-0021 001f 0100 341f 2640 39b1
-0021 001f 00ff 3423 2638 39bf
-001f 001f 00ff 3435 263f 39bc
-0021 0020 0100 3431 263b 39c3
-001f 0020 00ff 342e 2635 39cd
-001f 001f 00ff 3434 2638 39d0
-001f 0020 0100 3443 263f 39c5
-0020 001f 0100 341a 2638 39c8
-0020 0020 00fe 341e 263a 39bf
-0021 0020 00ff 3428 2639 39be
-0021 001f 00ff 3448 2635 39ba
-0020 0020 0100 3419 2640 39b7
-0022 0020 0100 341a 2640 39b4
-0021 0020 00ff 3423 263b 39c0
-001f 0020 00fe 342a 2636 39cb
-0021 0020 00ff 3420 263b 39ca
-0020 0020 00ff 3413 264a 39d2
-0020 0020 00ff 341c 2645 39da
-0020 0020 00ff 3423 263d 39da
-0020 0020 00ff 341e 263c 39ee
-0021 0020 00ff 3411 2639 39d9
-0020 001f 00ff 340e 2639 39da
-0020 001f 00fe 3413 2637 39d7
-0021 0021 00fe 3417 263a 39ca
-0021 0020 00fe 3402 2638 39c1
-0020 0021 00ff 340e 262c 39c0
-0021 001f 00ff 3404 2642 39d1
-0021 001f 00fe 33fe 264e 39d6
-0021 001e 00ff 33ff 2640 39d4
-001f 0021 00fe 33ff 2641 39e7
-001f 0021 00ff 33f7 263e 39e5
-001f 0021 0100 33fb 2632 39e7
-0021 0020 00fe 33f5 262d 39fa
-0020 0020 00ff 33fa 262e 39e8
-0021 001f 00ff 3407 2635 39e0
-0020 001f 00ff 33fb 2630 39d7
-0021 0020 00fe 33f7 2639 39ce
-001f 0021 00ff 33e6 263a 39e3
-0021 0020 0100 33e5 263b 39f3
-0020 001f 0100 33e4 2640 39fd
-0021 001f 0100 33df 263b 39f3
-0020 0020 00ff 3407 2644 39f4
-0021 001f 00fe 33f6 2645 39e4
-0020 001f 00ff 33f6 2656 39d6
-0021 0021 00ff 33ec 2656 39dd
-0020 0020 00ff 33f1 2659 39f1
-0021 001f 00ff 33dd 264d 39ff
-0022 001e 0100 33e5 2659 3a0c
-001f 0020 00ff 3408 2658 39ff
-0020 0021 00fe 33f2 2649 39f4
-0022 0022 00ff 33f1 264c 39d8
-0022 0020 00ff 340d 264b 39e6
-0021 0020 00ff 3401 264f 39f2
-0020 001e 00fd 33ef 2649 39f9
-0022 0021 00fe 33f2 2649 3a05
-0021 0020 00ff 33ef 2634 39fa
-0021 0020 00ff 33fc 262a 39f6
-0021 0020 00ff 3400 263f 39ea
-0020 001e 00ff 340a 263b 39d8
-0020 001f 00ff 3403 263c 39e5
-001f 0020 00ff 33fd 2644 39e7
-0021 0020 00fe 33f9 2639 39f5
-0022 0020 00ff 3408 2645 39ff
-0020 001f 0100 33fd 263d 39f1
-0020 0020 00ff 33fe 2642 39ec
-0022 001e 00ff 3410 2642 39e7
-0020 001f 00ff 3413 2646 39d8
-0020 0021 00ff 33fb 2642 39d2
-0020 001f 00ff 340b 2640 39da
-0020 001f 00ff 3417 264a 39e6
-0020 0021 00ff 3411 263f 39e2
-0022 0021 0100 3401 2640 39ec
-0021 0020 0100 341b 263e 39f0
-0021 001f 00fe 340c 2638 39f5
-0020 0020 00ff 340b 264a 3a03
-0020 001f 00fe 33ed 263c 39f6
-0021 0020 0100 340c 2648 39d5
-0021 0020 00ff 3413 2659 39e0
-0021 001f 00ff 340e 2654 39e6
-0020 0021 00ff 33f3 2658 39ea
-0021 001f 00ff 33fb 2651 39f4
-0021 0020 0100 33ff 2650 39f7
-0020 0020 0100 33ff 264f 39f0
-0020 001f 0100 3407 2650 39f4
-0021 001f 00ff 3409 263d 39eb
-0020 0020 00ff 33f6 264b 39e4
-0021 0020 00ff 340c 2644 39d9
-0020 0020 00fd 33fd 2650 39d4
-0021 001f 00fe 33fe 2648 39e1
-0021 001f 0100 3401 263a 39ea
-0021 0021 0101 340e 2646 39f0
-0020 001e 0100 3403 2641 39ec
-0021 001e 00ff 3403 2652 39eb
-0021 001e 00ff 3407 264b 39ff
-0020 0020 0100 3411 2643 3a00
-0021 0020 00ff 3414 2650 39ea
-0020 001f 0101 341a 2646 39e8
-0021 0021 00ff 3425 264a 39d8
-0021 0021 00fe 3402 263f 39ce
-0020 001f 00ff 340b 2631 39d4
-0020 0021 00ff 3413 2623 39e1
-001f 0021 00ff 3419 2626 39e5
-0020 001f 00ff 341f 2630 39f0
-0021 001e 00ff 341d 2635 39ed
-0020 0020 00ff 3422 262f 39d4
-0021 0021 00fe 341f 263d 39ce
-0020 001f 0100 342b 2625 39c8
-001e 001f 00ff 3429 2633 39c6
-0020 001f 00ff 3422 262a 39bf
-0020 0021 00ff 3420 2632 39cd
-0021 0020 00ff 342d 2638 39d5
-0021 0020 00fe 3412 263f 39d9
-0020 0021 00ff 3415 2641 39d7
-0022 0020 00ff 3421 264f 39e2
-001f 0020 00ff 341d 2643 39e3
-0022 0020 0100 340d 264b 39e9
-0020 0020 0100 341a 2658 39dc
-0020 001f 0100 3417 2647 39d9
-0021 0021 00ff 341f 2642 39d8
-0020 0020 00fe 340b 263d 39cd
-0021 001f 00ff 3424 264b 39cf
-0021 0021 00ff 342b 2647 39ba
-0020 0020 00fe 3403 264f 39c2
-0021 0021 00fe 3402 264a 39ce
-0020 001e 0100 3412 2652 39d0
-0021 0020 0100 3411 2646 39d1
-0021 0021 00ff 340a 264a 39dc
-0021 0020 00ff 33fe 2647 39e6
-001f 0020 0100 33f6 263b 39e6
-0020 0020 00ff 3407 2641 39ea
-0021 001f 0100 33fe 2645 39f1
-0020 0020 00fe 33ed 2647 39e2
-0021 0020 0100 33f7 2639 39dd
-0021 001f 00ff 3410 2636 39dc
-0021 0020 00ff 340b 2649 39d4
-0020 0020 00ff 33fa 2639 39d4
-0020 0020 00ff 33f3 263a 39c4
-0021 001f 00fe 33ff 263f 39cd
-0021 0021 00ff 33ff 263e 39d2
-0022 0020 00fe 3404 264a 39d6
-0021 001f 0100 3406 2640 39d1
-001f 0020 00ff 3417 2636 39d5
-0021 0021 0100 341a 2643 39d9
-0021 0020 00ff 340a 2645 39da
-0021 001f 00ff 340e 2631 39e6
-0020 0020 00ff 3414 262c 39e0
-001f 0020 00fe 3407 262b 39dc
-0020 001f 00ff 340b 261d 39d9
-0020 0020 00fe 341c 2611 39cc
-001f 0021 00ff 3413 262c 39c8
-001f 001f 00ff 340a 262d 39cb
-0020 001f 00fe 341f 2627 39bd
-0020 001f 0100 341e 262f 39be
-0020 001f 00ff 341a 262f 39c3
-0020 001f 00ff 3407 262b 39cb
-0020 0020 00ff 340f 263b 39d4
-0022 0020 00fe 342d 2631 39d8
-0020 0020 00fe 340e 2639 39dd
-0020 0021 00fe 3417 263b 39e9
-0020 001f 00ff 3412 2639 39d8
-0021 0020 0100 3420 263c 39d6
-0020 001f 0100 3418 262f 39d3
-0021 0020 00fe 3406 2630 39cd
-0020 0020 00fe 33fa 2630 39c5
-0021 001f 00ff 340a 262e 39c5
-0020 001f 00ff 341f 262b 39c7
-0021 001f 00ff 33fb 2636 39c2
-0020 0020 00ff 3406 262a 39bd
-0020 0020 0100 342a 2638 39b9
-001f 001f 00ff 3419 2638 39c4
-0021 001f 00ff 33fb 263c 39bd
-0021 0020 0100 3419 2633 39bb
-0021 001f 00ff 340d 2630 39b1
-0022 0020 00fe 3417 262c 39b9
-0020 0021 00ff 3424 2637 39b5
-0021 0021 00ff 3419 262b 39ba
-0021 001f 00ff 341c 2637 39b9
-0020 0020 00ff 3419 2636 39c6
-0020 0020 00ff 340f 262c 39bc
-001f 0020 0101 340c 2632 39c5
-0022 0020 00fe 340a 2642 39c1
-001f 0020 0100 340b 263c 39bf
-001f 0020 00ff 3407 2636 39c0
-0020 001f 00ff 3402 263a 39d2
-0022 001f 00ff 3407 264a 39cf
-0020 0021 0100 3402 263c 39d8
-0020 0021 00ff 33f9 2639 39db
-0021 0020 0100 3400 2632 39d5
-0020 0020 00ff 33f6 2635 39d9
-0021 0020 00ff 33ec 2632 39e2
-0021 0020 00fe 33ff 2638 39e6
-0021 0020 00fe 33fd 263a 39e7
-0020 001f 00fe 33e8 262c 39e9
-0020 0020 00fe 33f7 2625 39e9
-0021 0020 00fe 33f4 262c 39ea
-0021 0021 00fe 33fb 263b 39ec
-0021 0021 00ff 33f9 2645 39e9
-001f 001f 00ff 33e0 264d 39f6
-0021 0021 00ff 33f0 263f 39f2
-0022 001f 00fe 33eb 2648 39fc
-0020 001f 00ff 33f1 264f 39f6
-0021 0021 0100 33ed 2648 39f4
-0020 001f 0100 33ea 264e 39f6
-0022 001f 00ff 33ee 265b 39f9
-0020 0020 00ff 33de 264f 39f5
-0020 001f 00ff 33fc 2658 39f2
-0021 0020 00ff 33ef 2650 39f7
-0020 0020 00ff 33e4 265c 39fd
-0020 0020 00ff 33ec 2661 3a01
-0021 0021 00ff 33dc 2654 3a01
-0020 0020 0100 33eb 2662 39e3
-0021 0020 0100 33d9 2659 39e3
-0021 001f 0100 33d7 2654 39ee
-0020 001f 00ff 33e0 2649 39f5
-0021 0020 00ff 33de 264c 3a02
-0021 0021 00ff 33e0 2648 39f7
-0022 001f 00ff 33e8 2648 3a03
-0021 0021 00ff 33cc 2642 3a04
-0020 0022 0101 33dd 263c 3a06
-0020 0020 0100 33e0 2647 3a0e
-0021 001f 00ff 33d9 2648 3a16
-0020 001f 0100 33e2 2647 3a15
-0020 0020 00ff 33d7 264f 3a1d
-0020 0020 00fe 33cf 2646 3a19
-0021 0020 0100 33ec 2643 3a0c
-0020 0021 00ff 33d6 264f 3a0b
-001f 001f 00ff 33d0 264d 3a0e
-0020 0021 00ff 33cd 2648 39fd
-0021 0020 00ff 33db 2648 3a03
-0021 0020 00ff 33bd 2640 39f6
-0021 001f 0100 33d2 2647 39f5
-0020 0020 00ff 33d5 264d 39f9
-0020 001f 00ff 33c2 264e 3a05
-0021 0020 00fe 33dd 2647 3a0b
-0020 001d 00ff 33d2 2643 3a0a
-001f 001f 0100 33cd 264b 3a13
-0021 001f 0101 33cd 264c 3a15
-001f 0020 00ff 33ce 263c 3a1a
-0022 001f 00fe 33d0 2642 3a22
-0020 0020 0100 33c7 2648 3a1f
-0020 0021 0100 33d0 2646 3a19
-0021 0020 0100 33ca 2646 3a0e
-0021 001f 00fe 33c6 2643 3a06
-0023 0020 00fe 33be 264d 39f9
-0021 0020 00fe 33c1 264e 3a0b
-0020 001f 0101 33c2 2643 3a18
-0021 0021 0100 33da 2656 3a19
-001f 001f 00ff 33bc 2647 3a2b
-0021 0020 0100 33c0 2649 3a19
-0021 0022 00fe 33c3 264b 3a0e
-0021 0021 00ff 33cd 2644 3a0d
-0021 0021 00ff 33c4 264e 3a00
-0020 0020 0100 33d0 264b 39f4
-0022 0020 00fe 33ce 2642 39fb
-0020 0020 00fe 33d8 2651 3a02
-0020 001e 00ff 33d7 2654 3a06
-0021 0020 0101 33e0 265f 3a10
-0021 001f 00ff 33df 265f 3a13
-0020 0020 0100 33ef 2655 3a0a
-0022 0020 00ff 33d3 2656 3a07
-0022 0020 00ff 33db 265e 39fc
-0022 001e 00ff 33ec 264d 39f0
-0022 001f 00ff 33f0 265d 39eb
-0022 0020 00ff 33e5 2657 39e1
-0021 0021 0100 33e8 264c 39f3
-0021 0020 00fe 33f3 2652 39f4
-0020 0020 00fd 33f5 264d 39f7
-0022 0021 00ff 3403 2648 3a02
-0022 001f 00ff 33f3 2648 39ff
-0020 001f 00fe 33fc 2644 39f5
-0020 001e 00fe 33fe 2641 39d0
-0020 0020 00fe 33f8 264d 39df
-0020 0021 0100 33ee 264c 39df
-001d 0020 00ff 3400 2645 39dc
-0021 0020 00ff 33ef 263c 39ec
-0021 001f 00ff 33fb 2646 39ef
-001f 0021 00ff 33f5 2640 39f1
-0021 001f 00fd 33ea 263e 39e5
-0021 001f 0100 33e7 2637 39e9
-0020 0021 00ff 33fe 2631 39e3
-0021 001e 00fe 3403 2639 39df
-0021 0021 00ff 33e8 2639 39d6
-0020 001f 00ff 33fc 263a 39de
-0020 001f 00ff 33fd 263b 39d3
-0021 0022 00ff 33e4 2637 39cf
-0020 0020 00ff 33e1 2639 39dd
-0020 0020 00fd 33fa 2637 39df
-0020 0020 0100 33ec 263c 39e1
-0021 0020 00ff 33e8 2642 39e9
-0022 0021 00ff 33e5 2649 39ed
-0021 001f 0100 33ef 263f 39f1
-0020 0021 0100 33ee 263d 39f8
-0020 001e 00ff 33ea 2642 39f7
-0020 001f 00ff 33e6 2644 39f0
-0021 0020 00ff 33e4 264e 39ed
-001f 0020 0100 33e9 264b 39ee
-0021 0020 0100 33f6 263b 39dc
-0020 001f 00ff 33ff 2645 39df
-0020 001e 00ff 33ed 2642 39d2
-0022 0020 00ff 33f5 2649 39e0
-0023 0020 0100 33f0 2636 39e4
-0021 001f 00ff 33ea 263c 39ed
-0020 0020 00ff 33f4 2640 39ec
-0021 0020 00ff 33fa 2624 39f4
-0021 0020 00fd 33ff 2632 39f3
-001f 0022 00ff 33f1 2640 39e6
-0021 0020 0100 33f9 2635 39e7
-0021 0020 0100 3411 2636 39e0
-0021 001f 00fe 33f1 2631 39d7
-0020 001e 0100 33e6 263f 39cd
-0020 001e 00ff 33eb 2639 39e3
-0021 0020 0100 33e5 2647 39f9
-0021 0020 00ff 33fa 2643 3a01
-0022 001f 0100 33f9 263b 39f8
-0020 0021 0100 33ec 2639 39f5
-0020 0020 00ff 33e8 264a 39f6
-0021 001f 00ff 33f5 2644 39e9
-0020 0021 00ff 33fb 265a 39ec
-0021 0020 00fe 33dc 264a 39e4
-0020 0021 00fd 33d9 2656 39f1
-001f 001f 00ff 33e1 265f 39f3
-0020 0020 00ff 33d9 265f 3a0d
-0020 0020 00ff 33da 265b 3a1a
-0020 0020 0100 33ce 2655 3a16
-0022 0020 00ff 33c0 2668 3a0b
-001f 001f 0100 33b4 2657 3a05
-0022 0020 00ff 33ba 2654 3a02
-0021 001f 0100 33b8 265b 39ff
-0022 001f 00ff 33b0 2666 39fc
-0022 0020 00ff 3398 2663 3a15
-0021 0020 00fe 339e 265a 3a13
-0022 0020 00ff 339b 2662 3a2a
-0021 0020 00ff 339f 2664 3a27
-0020 0020 0100 3389 265b 3a24
-0020 001f 00fe 3396 2653 3a19
-0021 0020 00ff 3395 265d 3a0a
-0021 001f 00fe 338c 2655 3a14
-0021 001f 00ff 338b 2655 3a1a
-0020 0020 00ff 3394 265c 3a26
-0021 0022 00ff 3387 2658 3a2b
-0021 001f 00ff 33ab 2667 3a2a
-0021 0020 00ff 3394 265b 3a32
-0021 0020 00fd 3396 2652 3a31
-0021 0020 00ff 3394 2655 3a2d
-0022 001f 00fe 339e 2657 3a1b
-0021 0020 0101 339d 2659 3a23
-001f 0020 00ff 339e 2656 3a1a
-0021 001e 00ff 338e 2665 3a0f
-0022 001f 00ff 33a2 2663 3a11
-0020 0020 00ff 339d 2659 3a0a
-001e 0020 00fe 339a 2650 3a10
-0021 0020 00ff 33a3 2657 3a17
-0022 0020 0100 33a4 265b 3a1c
-0021 001f 00ff 339d 2656 3a28
-0022 0020 00ff 339e 2664 3a2c
-0021 0020 00fe 33aa 265a 3a24
-0021 0020 00ff 338f 265b 3a17
-0020 001e 00ff 33a0 265a 3a0f
-0020 0021 00fe 33a9 2658 3a0a
-001f 0020 00ff 33ac 2650 3a02
-001f 001f 00ff 33b6 264f 39fe
-0022 001e 00ff 33ab 2652 39f6
-0022 0022 0100 33b8 264f 39fd
-0021 0020 0100 33c5 2651 3a02
-0021 001f 00fe 33cb 2637 3a07
-0022 001f 00ff 33b8 2645 3a09
-0020 0021 00ff 33ca 264e 3a07
-0021 0021 00ff 33c2 264f 3a10
-0020 001f 00ff 33cd 2641 3a0b
-0022 0020 0100 33bb 263a 39fb
-0020 001f 00ff 33c8 262b 39f8
-0021 0020 00fe 33e3 262f 39e9
-0021 001e 0100 33d4 2638 39e0
-0021 0020 00ff 33ce 2637 39eb
-0020 0021 00ff 33de 2633 39ef
-0021 001f 00fe 33e0 2638 39f0
-0021 0021 0100 33cf 262b 39f7
-0021 0020 0100 33e3 2648 39f8
-0021 001f 00fe 33e8 2636 3a05
-0021 001f 00ff 33df 2636 39f5
-0021 0020 00ff 33e5 2637 39ec
-001f 0021 00ff 33e0 262d 39e3
-0021 0020 00ff 33ef 2641 39d7
-0020 0020 00fe 33ed 264a 39d6
-0020 0021 0100 33d9 2643 39c9
-0020 001f 00ff 33f6 264b 39d6
-0021 0021 00fe 33fc 264d 39e6
-0021 001e 00ff 33f9 2652 39d7
-0021 0021 00ff 33e2 2651 39e5
-0020 0020 00fe 33dc 265a 39e7
-001f 001f 0100 33fa 2647 39e9
-0021 0021 00ff 33f2 2645 39f9
-0020 0021 00ff 33ed 2649 39f7
-0021 0021 00fe 33e9 2650 39eb
-0020 0021 00fe 33ff 264d 39de
-0020 0020 00ff 33e3 264b 39d6
-0021 0021 00ff 33de 2641 39d0
-0020 001f 00ff 33da 2640 39ce
-0021 0020 00ff 33e2 264a 39dd
-0020 0022 00ff 33e0 2646 39e4
-0021 001f 00fe 33d6 2650 39e9
-0021 0020 0100 33de 263c 39f1
-0021 0020 00ff 33d3 264f 39ee
-0020 0021 0100 33ca 264d 39f3
-0020 0021 00ff 33d4 2643 3a01
-001f 001f 00ff 33ce 2643 3a01
-0020 0020 00ff 33cd 2647 3a08
-0021 0020 00ff 33c6 2649 39f6
-0021 0020 00fe 33c9 263e 39ec
-0020 0020 00fe 33c9 262b 39e4
-0021 001f 00ff 33e4 2638 39de
-0020 001f 00ff 33d7 262c 39ee
-0021 0020 00ff 33c8 2633 39f4
-0020 001f 00ff 33c5 263b 39f8
-0021 001f 00ff 33d2 264a 3a04
-0021 0021 00fe 33d9 263c 3a10
-0021 001f 0100 33c9 2639 39fc
-0021 001f 00ff 33c0 263e 3a00
-0020 0020 00ff 33b8 263e 3a06
-0021 0020 0101 33c2 2643 39fd
-001f 0021 0100 33b1 2642 39f5
-0021 0020 00fe 33a4 263d 3a00
-0021 0020 00fe 33cb 263e 39fb
-0021 0020 00fe 33a7 2646 39fc
-0020 0022 00fe 339f 2641 39fe
-0021 0020 00ff 3398 2644 39f2
-0021 001f 00ff 33a7 2638 39f4
-0022 001f 0100 339e 264c 3a01
-0023 001f 00ff 3392 263d 3a0a
-0021 0020 00ff 3393 2648 3a24
-0021 0021 0101 338c 2644 3a26
-0020 001f 00ff 3398 264f 3a24
-0021 0020 00ff 3392 2645 3a1f
-0022 0020 00fe 338c 264d 3a1b
-0020 0020 00fe 3375 2644 3a1e
-0020 0020 00fe 3385 2657 3a1d
-0021 0020 0100 3388 263f 3a21
-0020 0020 0100 337a 2649 3a1b
-0021 0020 00fd 3370 2644 3a15
-0020 0020 00ff 335e 2646 3a0d
-0022 0021 00ff 335f 264c 3a0e
-0021 0020 00ff 3378 2646 3a0a
-0021 0021 00ff 3373 264c 3a12
-0022 0021 0100 336f 2647 3a19
-0022 0020 00ff 3372 264f 3a1f
-0021 0020 00ff 337c 2646 3a15
-0020 0021 0100 3368 264a 3a1f
-0022 0020 00fe 336b 263f 3a2a
-0021 0020 00ff 3379 264a 3a26
-0021 0020 00fe 337d 2638 3a33
-0022 0020 0100 337d 264c 3a2f
-0021 0020 00fe 336e 263c 3a28
-0020 0020 00fd 3373 2637 3a1f
-0022 001f 0100 3375 2642 3a24
-0021 001d 00ff 3381 2646 3a17
-0023 001f 00ff 337b 2645 3a15
-0022 0020 0100 337c 263a 3a06
-0021 001f 00ff 336c 2647 3a0f
-0021 0020 00ff 3384 2655 3a1a
-0021 001f 00fe 3385 264b 3a20
-0020 0021 00ff 3379 264c 3a25
-0020 001e 0100 3365 264e 3a31
-0022 001e 00ff 336d 2648 3a2f
-0021 001d 00fe 3385 2645 3a26
-0021 001f 0100 3372 2642 3a22
-0020 001f 0100 3357 2650 3a18
-0021 0020 00ff 337a 2651 3a11
-0021 0021 00fe 3382 2652 3a0f
-0022 001f 00ff 336c 2651 3a0e
-0021 0021 00fe 337f 265b 3a04
-0022 0020 0100 337c 265b 3a0d
-0020 0021 0100 3373 2654 3a18
-0020 001e 00ff 337b 2651 3a1f
-0021 001f 00ff 3386 2650 3a1e
-0021 0021 0100 3390 2650 3a2f
-0020 0020 00fe 3399 264c 3a18
-0021 001f 0100 3389 264e 3a0c
-0022 0020 00ff 337f 2651 3a05
-0020 0020 00ff 338f 264b 3a04
-0021 0020 0100 338f 264c 39f6
-001f 0020 00fd 3393 264a 3a00
-001f 0020 00fe 3398 264e 3a0a
-0021 0021 00ff 339b 2646 3a10
-0021 0020 00ff 33a4 2636 3a1a
-0021 001f 00ff 339d 2648 3a1f
-0022 0021 0100 339d 2628 3a14
-0020 0020 00ff 3393 263c 3a11
-0020 001f 00fd 338d 2638 3a0d
-0020 0020 00fe 33a9 2638 39fb
-0022 0020 00ff 33a4 2638 39f9
-0021 001f 00fe 33a0 2639 39f3
-0021 0020 0100 33ac 2640 39f8
-0022 0020 00ff 33a9 2639 39f3
-0021 0020 0100 33b1 2641 3a02
-0020 001f 00fd 33ba 2640 3a0e
-0021 0020 0101 33a6 2640 3a0f
-0021 001f 00ff 33bf 2646 3a09
-0020 0020 00fd 33bb 2643 3a00
-0021 0020 00ff 33b9 2641 39f9
-0020 001e 00fe 33bc 2643 39ed
-0021 001f 00ff 33c1 2648 39f1
-0022 0020 0100 33b4 2655 39e3
-0021 0020 00fe 33a4 2655 39f1
-0020 0021 0100 33ae 264f 39f3
-001f 0021 0100 33c9 2658 39f1
-0021 001f 00ff 33b7 264a 39f9
-0021 0020 00fe 33a5 264c 39fe
-0021 0020 00fe 33c2 2654 39ff
-0020 001f 0100 33c7 2650 3a0a
-0021 0020 00ff 33b7 2647 39fe
-0020 0020 00fe 33be 263f 39f7
-0020 0021 00ff 33b8 263d 39fc
-0020 0020 0100 33c5 263f 39f2
-0020 0020 00fe 33bf 2649 39e9
-0020 0021 00ff 33a8 263f 39df
-0021 0020 0100 33bf 2643 39f0
-0020 0021 0100 33c9 2638 39f9
-001f 001e 0100 33c7 2626 39fc
-0020 0020 00ff 33bc 2634 39fe
-0021 0020 00ff 33b1 2630 3a0b
-0020 0020 00fd 33ac 2633 39f8
-0022 0021 00fe 33be 263a 39fd
-0020 0020 00ff 33ae 263a 39ff
-0020 001f 00ff 33b2 263f 39fa
-0021 0020 00ff 33c1 2632 39dd
-001f 0020 00ff 33b2 263a 39f2
-0021 001f 0100 33a4 263d 39ec
-0020 0020 00ff 33a5 2641 39fb
-0020 001e 00ff 33b6 263f 3a02
-0020 0021 00fe 33b8 2644 3a06
-0021 0020 0100 33ab 263b 3a0b
-0021 0021 00ff 33af 263c 39fe
-0021 001f 00ff 33ba 263c 39e9
-0022 0020 00fe 33ad 2640 39f2
-0020 0020 0100 3398 2647 39fc
-0020 0020 00fe 33aa 264f 3a0d
-0022 0021 00fe 33a6 2663 3a09
-001f 001f 00fe 339c 2655 3a21
-0021 0021 0100 3391 2651 3a0b
-0021 0021 00ff 339b 2657 3a11
-0022 0020 00ff 3396 2659 3a00
-0021 001f 00ff 338f 2655 39f3
-0020 001f 00ff 3384 264f 39f0
-0021 001f 0100 337d 2655 3a0d
-0021 0020 00fe 3390 264e 3a0b
-0021 0020 00fe 3385 2656 3a17
-0020 0020 00ff 336f 2658 3a23
-0020 0020 00fe 337d 2649 3a0d
-0020 0021 00ff 3389 264a 3a0a
-0021 0020 00fe 3381 264e 39f5
-0022 0020 00ff 3392 2649 39ff
-0021 001e 00ff 3385 2648 3a0a
-0020 001f 00ff 338f 2637 3a12
-0020 001f 00ff 33a1 2641 3a0e
-0021 0021 00ff 33a2 262f 3a14
-0021 0021 0100 3398 2633 3a0e
-0020 0020 00ff 33a1 2628 3a05
-0021 001f 00ff 33a6 2631 3a06
-0022 0021 00fe 339b 2629 3a00
-0020 0020 00ff 33a0 2627 39fc
-001f 001f 00fe 3394 262e 39ee
+0020 0021 00ff 340a 263c 39fa
+0021 0020 00ff 3407 2634 39fa
+0020 0020 00fe 340e 262e 39f7
+0021 0022 00ff 33fb 2636 39f0
+0022 0020 00ff 33f7 263a 39e3
+0020 001f 00ff 33f8 263d 39fd
+0021 001f 00ff 33ea 263d 3a11
+0020 0022 00ff 33e5 262e 3a1a
+0020 001f 0100 33d8 2644 3a21
+0020 0020 00ff 33ca 263f 3a2c
+0022 0020 00fe 33bc 2647 3a2f
+0021 001f 00ff 33b2 2654 3a25
+0020 0020 00ff 33ad 2655 3a28
+0021 001f 00fe 3390 2649 3a1a
+0021 0020 00fe 3399 2646 3a21
+0021 0020 00fd 3395 2643 3a11
+0021 0020 0100 338e 2636 3a1e
+0021 0020 0100 338b 2649 3a2f
+0020 0020 00ff 3387 2648 3a32
+0021 0020 00ff 3383 264f 3a38
+0020 0020 00fe 3387 2651 3a3e
+0021 0020 0100 338b 2653 3a36
+0021 0021 00ff 3388 2651 3a35
+0021 0020 0101 338c 264c 3a29
+0021 0021 00fe 337c 264f 3a1e
+0021 001f 00fe 3387 2658 3a24
+0021 0020 00fe 339c 2656 3a1e
+0020 001f 0100 33b1 2653 3a1f
+0020 0020 00ff 339d 2654 3a17
+0021 001e 00fd 3392 2657 3a12
+0021 0022 00fe 339f 2657 3a1a
+0022 001f 00ff 33a2 2657 3a26
+0020 001f 00ff 33aa 2653 3a20
+0021 001f 00ff 339d 2649 3a1d
+0022 001f 0100 339a 265c 3a1f
+0022 001f 0100 33a5 2669 3a25
+0022 0020 00fe 33a5 265b 3a2c
+0022 0020 0100 33a9 2658 3a29
+0020 001e 00ff 33a6 264c 3a2f
+0022 0021 00fd 33a4 2645 3a29
+0022 0021 0100 339d 2646 3a2b
+0022 0020 00ff 33ae 263c 3a2b
+0021 001f 00ff 33bd 263e 3a32
+0021 0020 0100 33cb 2641 3a2b
+0020 0021 00ff 33d1 2646 3a20
+0021 0020 00ff 33d5 2630 3a0f
+0021 0021 00ff 33e2 2640 3a08
+0022 0020 0100 33fd 2637 39f4
+0021 0020 0100 33fc 2634 39f2
+0020 0021 00ff 33fb 262b 39eb
+0020 0020 0100 341e 2626 39d9
+001f 0020 0100 343a 2621 39d5
+0021 0021 00ff 342c 262a 39ca
+0020 0020 00ff 342d 2625 39d5
+0021 0020 00ff 343b 2621 39e0
+0020 0021 00ff 343d 2629 39d7
+001f 0021 00ff 343a 261d 39e3
+0021 0020 00ff 3441 2629 39db
+0020 0020 00fd 344e 2626 39e7
+0020 0020 00ff 3459 261f 39e5
+0021 001f 00ff 3437 262a 39ef
+0020 001f 00ff 3448 2624 39ed
+0021 0020 0100 3443 2623 39f1
+0022 0021 00ff 343f 2630 39fb
+0021 001f 00ff 3448 262f 39f2
+001f 001f 00ff 342f 262b 39f3
+0021 0020 00fe 3434 262c 39ed
+0021 0021 00ff 343a 2634 39ea
+0020 0020 00ff 342d 2627 39ec
+001f 0020 00fe 3438 2631 39e2
+0020 0021 0100 3433 2637 39e7
+0020 001f 0100 342d 262b 39e1
+0021 0020 00fe 343e 262c 39e2
+0021 001d 00ff 344f 2624 39dc
+0020 0020 0100 342f 262d 39d8
+0021 0021 00fe 341c 2622 39d8
+0020 0020 00ff 3420 2637 39df
+0021 0020 00ff 342a 263c 39d7
+0021 0021 00ff 3427 262d 39eb
+0023 0020 00ff 341f 2632 39e7
+0020 0021 0100 3410 262c 39ea
+0021 001e 00ff 3422 2628 39eb
+0021 0020 00ff 342b 2620 39f1
+0021 001e 00fe 341f 261f 39f3
+0020 0020 00fe 342b 2630 39ec
+0020 001f 0100 3425 261d 39e9
+0021 0020 00ff 3437 2637 39e4
+0021 001f 0100 343f 2621 39f2
+0021 001f 00ff 3429 262c 39eb
+0020 001f 00ff 341f 2624 39f2
+0020 001f 00fd 3424 2634 39fd
+001f 0020 00ff 3432 2639 39f9
+0020 0021 0100 342f 2631 39fd
+0021 0020 0100 3411 2639 3a0e
+0021 0021 00fe 341b 2634 3a06
+0022 001f 00ff 3407 2647 3a06
+0021 0020 00ff 3427 2645 3a04
+0022 0021 00ff 341f 2648 3a08
+0020 0020 00ff 33f7 2647 3a06
+0020 0021 0100 3403 2648 39fb
+0020 0020 00ff 3413 2642 3a06
+0020 001f 00ff 3410 2640 3a00
+0020 0020 00ff 3415 2653 3a03
+0020 001f 00fe 340c 264a 39f8
+001f 001e 0100 341c 2641 39fb
+0021 0020 00fe 3420 264d 39f2
+0020 001f 00fe 3427 2644 39f2
+0021 0020 00ff 3433 2654 39e8
+0020 0020 00fe 3412 264c 39e6
+001f 001f 0100 3436 264d 39d9
+0020 001f 0101 343a 2649 39d3
+0021 0021 00ff 3431 2646 39d4
+001f 001f 00fe 3426 264c 39d4
+0021 001f 00ff 3440 264d 39c9
+0021 001f 0100 343f 2647 39cf
+0020 0020 0100 344e 263f 39cf
+0022 0020 00fe 3445 263e 39d8
+001f 0021 0100 342d 2638 39e8
+0020 001f 0100 342a 2642 39e9
+001f 0020 00fe 3439 263b 39f0
+0020 001e 00ff 343d 2636 39f0
+0020 001e 00fc 3417 2643 39ff
+001f 001e 00ff 3429 2644 39f5
+0020 001f 00fd 3437 263d 39fe
+0020 0020 0100 341e 2645 3a0b
+0021 0020 00ff 3419 2644 3a0d
+0020 0021 00ff 3427 2642 3a03
+001f 0020 00ff 342e 2638 3a07
+0021 001e 00ff 341e 2643 39fc
+0021 001e 00ff 342c 263b 39e9
+0020 001f 00ff 341f 2635 39d6
+0021 0021 00ff 342b 2637 39da
+0020 0020 00ff 3437 2632 39d1
+0020 001f 00ff 3439 2633 39e1
+0021 0020 0100 3445 2633 39dd
+0020 0020 00ff 343a 262c 39d5
+0021 0020 00fe 3459 2630 39d4
+001f 001f 00ff 3441 262f 39de
+0021 0020 00ff 344e 262b 39e1
+0020 001f 00ff 343f 2628 39e3
+0021 0020 00ff 345e 262a 39dd
+0021 001f 00ff 345b 262d 39db
+0021 0020 00ff 3445 262a 39d7
+0020 0020 00ff 3450 262f 39d6
+0021 0021 00ff 3456 262e 39d5
+001f 001f 00ff 3442 2635 39db
+0020 0020 0101 3433 263d 39d8
+0020 001f 00ff 3440 2632 39d8
+0020 001f 00ff 343e 2633 39dc
+001f 0020 00fe 3437 2630 39da
+0020 001f 00ff 343a 2630 39e0
+001f 001f 00ff 341d 2627 39da
+001f 0020 00fe 3440 2630 39d8
+0020 0021 0100 3438 261c 39db
+001f 001e 00ff 3437 2620 39d5
+0021 0021 00ff 343d 2620 39d6
+001f 0020 0100 3431 2611 39d8
+0020 001f 00fe 3438 2625 39d9
+0021 001f 0100 3444 2625 39cc
+0020 001f 00ff 3439 262b 39c8
+0020 0020 00ff 3433 2631 39cf
+0020 001f 00ff 3420 263a 39cb
+0021 0020 00ff 342e 2634 39d4
+0021 001f 00ff 3435 2639 39d6
+0023 0020 00ff 3424 2636 39cf
+0021 0021 00fe 3424 262d 39ca
+0020 0020 00ff 341a 263e 39ca
+0020 0020 00ff 3438 2631 39c3
+0020 0020 00ff 3446 2633 39be
+0021 0020 00ff 3430 2639 39ba
+0020 0021 00ff 3434 2636 39bd
+0020 001f 00ff 342b 2638 39ba
+0020 0020 00fe 3436 262a 39b7
+0021 0021 00fe 3451 263a 39b4
+0020 0020 00ff 343e 2630 39b1
+0020 0021 00fe 3438 262d 39a9
+0021 0020 00ff 344b 263c 39ad
+0020 0020 00ff 3451 2628 39a3
+0020 001e 00fe 345e 261e 39a8
+001f 001f 00ff 3469 262e 399f
+0020 0020 0100 346c 2612 39a1
+0020 001f 00ff 346f 2616 3996
+001f 0020 00fe 3482 2619 39a2
+0020 001f 00ff 347f 261f 39a2
+0021 001f 00fe 346c 2619 39a8
+0021 001f 00ff 3484 2629 39a4
+001f 001f 00fe 348b 2621 39a1
+0020 0020 00ff 347f 261e 39a3
+0020 0020 0100 3484 2620 39a5
+0020 001f 00ff 347e 2624 39a4
+0021 001f 00fe 348d 261f 39a7
+001f 001e 00ff 3487 2622 39a6
+0021 0020 0100 346e 2613 39a2
+0021 001f 00ff 3484 261b 39a3
+001f 0020 0100 3491 261c 39a1
+0021 0020 00fd 348a 260c 39a6
+0020 001f 00ff 347f 261c 39a9
+0020 001e 00ff 3487 261b 39a2
+0020 0020 00fe 3486 261c 399e
+0020 001f 00fe 3488 2617 39a1
+0020 0020 00fe 3486 2605 39a3
+0021 001f 00ff 345d 2620 39ae
+0021 001f 00ff 3474 2619 39b3
+0020 001f 00fe 3488 261c 39b6
+0022 0021 00fe 3481 262a 39bc
+0021 001f 0100 3479 2632 39b8
+001f 0020 0100 3477 2626 39b2
+0021 001f 0100 347d 2630 39b3
+0020 0020 00ff 347f 2638 39bc
+0020 0020 00fe 3480 2633 39be
+0020 0020 00ff 3476 2630 39bf
+0021 001f 00ff 3476 262c 39b8
+001f 0020 00fd 3483 2638 39b9
+0020 001f 0100 3487 2639 39be
+0020 001f 00fe 348b 263d 39b9
+0021 0020 00ff 348b 2636 39c1
+0020 001e 00ff 3490 2628 39c5
+0021 0020 0100 348a 262c 39ba
+0020 001e 00ff 3495 261e 39ba
+0020 001e 0100 3482 262e 39c3
+0021 001f 00ff 3495 261b 39bf
+001f 0020 00ff 349c 262e 39b9
+001f 0021 00ff 3496 2626 39b1
+0020 001f 00ff 3487 2628 39b0
+0020 001f 00ff 3493 2623 39aa
+0020 0020 00ff 3498 2627 39b0
+0021 0020 0100 3499 261c 39af
+0021 0022 00fe 3481 2623 39ae
+0020 0020 0100 3494 2624 39ab
+0020 001e 0100 34a3 2624 39a9
+0020 0021 00ff 3494 2623 39af
+0021 0020 00fe 348c 262e 39b4
+0020 0020 0100 348e 2626 39b4
+0021 0020 00fe 3493 261b 39ae
+0021 0020 00ff 3496 2628 39ad
+001f 001f 00ff 3498 262d 39aa
+001f 0020 0101 3485 262b 39ac
+0020 0020 00ff 3484 2621 39b4
+0021 0020 00ff 3495 2622 39b4
+0020 0020 00ff 348e 262b 39c3
+001f 0021 00ff 3488 2614 39c5
+0021 0020 00ff 346f 2620 39c1
+0020 0020 00fe 347a 2635 39cb
+0021 001f 0100 348a 2634 39bc
+0021 001f 00fe 3476 2640 39bc
+001f 001f 00ff 347a 263a 39b3
+0020 0020 00fe 347f 263b 39b3
+001f 0020 00ff 3486 2641 39a6
+001f 0020 00ff 3472 263f 39a1
+0020 0020 00ff 348a 262a 399b
+001f 001f 00fe 3483 2628 39a2
+0020 001f 00ff 3485 262d 39a6
+001f 001f 00ff 3477 262f 39a4
+0021 0021 00ff 3472 2625 39a8
+0020 0020 00fe 348d 2629 39a5
+0020 001f 00fe 3480 2612 399e
+0021 0020 0100 3480 2618 39a0
+001f 0020 00ff 346a 2624 39ac
+0020 001f 00ff 3468 2621 39b8
+0021 0021 00fd 3481 2628 39bd
+001f 0020 00ff 3466 2625 39c4
+0021 0020 00fe 346b 2631 39c0
+0020 0020 00ff 3450 2637 39c6
+0021 001f 00ff 345d 2634 39d5
+001f 0020 00ff 3462 2639 39d3
+001f 0020 00ff 345c 2638 39cc
+0021 0020 0100 345e 2648 39d1
+001f 001f 00fe 3457 263e 39b7
+001f 0020 00fd 3455 263a 39af
+0021 001f 00ff 3469 263b 39a9
+0021 001e 0100 345d 262c 39b5
+001f 0021 0100 344a 2638 39b2
+0020 001f 0100 3468 263a 39ae
+0020 001f 00fe 346a 2637 39ad
+0021 0021 00ff 345d 263b 39b3
+0021 0020 00ff 3464 2639 39af
+0021 001f 00ff 345e 2636 39bb
+001d 001f 00ff 346d 2631 39b7
+0020 001e 0100 3456 263b 39bb
+001f 001f 00ff 3446 2648 39c2
+0020 0020 00ff 3445 263c 39d3
+0021 0020 00fd 3452 2644 39d0
+0022 0020 00ff 3452 2646 39df
+0021 001f 00ff 342d 2645 39e2
+0020 001f 00ff 3445 2644 39d9
+0023 0021 00ff 3447 263f 39cd
+001f 001f 00fe 343a 2635 39d2
+0020 0020 00fe 3436 2635 39de
+0020 0021 00fe 342c 263b 39d1
+0021 0020 00fe 3435 2643 39cf
+0021 001f 00ff 344a 2630 39d9
+0022 001f 00ff 3435 2644 39cd
+0021 0020 00fe 341d 2638 39c1
+0020 0020 00ff 3427 263e 39bf
+0020 001f 00fe 3448 263a 39cc
+0021 0020 00fe 341c 2636 39d5
+001f 001f 00fe 342d 2636 39d4
+0022 001f 00ff 3423 2634 39e1
+0022 0020 0100 342d 2635 39e4
+0020 001f 00ff 341c 2641 39e6
+0020 0021 00ff 3416 2635 39f2
+0020 0020 0100 3418 2632 39f8
+0022 0020 00ff 3404 263d 39f5
+0020 0020 00ff 340e 2644 39fa
+0020 001f 0100 340b 262c 39e7
+0021 0020 00ff 33fc 2633 39e5
+0020 0020 00fd 340a 263f 39e3
+0020 0021 0100 3419 263b 39e4
+0021 001d 00ff 3413 263e 39e3
+0020 001f 00ff 341b 263d 39d9
+0021 001f 00ff 3412 2630 39d9
+001f 001e 00fe 3414 263b 39d3
+0021 0021 00ff 341c 263b 39d1
+0020 0020 00fe 3407 2634 39cb
+001f 001f 0100 3412 2638 39c7
+0020 001f 0100 3421 2630 39c7
+0020 0020 00ff 340d 263b 39ec
+0021 0020 00ff 3403 262d 39ea
+0020 001f 00fe 3406 2630 39f0
+0021 0020 00ff 3408 2637 39f1
+0020 0020 00fe 341d 263b 39f7
+0021 001f 00ff 3415 2625 39fc
+0020 0020 00fe 3418 2638 39f6
+0021 001f 00ff 3414 263b 3a08
+0021 001e 00fe 3421 2646 39f6
+0021 0021 00ff 3410 2636 39f2
+0020 0020 00fe 340f 2630 39e7
+0020 001f 0100 3410 263c 39f5
+0020 001f 00ff 3410 263b 39ec
+0022 0020 00ff 3401 2647 39ec
+0020 0021 00ff 33fe 263d 39e0
+0021 0021 0100 3406 263b 39e9
+0020 0022 00ff 3408 2638 39f2
+0021 0020 0100 3413 2641 39f9
+0020 0022 00ff 3402 2628 39e8
+0021 0021 0100 3401 2636 39fa
+0021 0021 00ff 3414 2640 39fe
+0021 0020 00ff 3424 2639 39fc
+0021 001f 0100 3414 2639 3a04
+0021 0020 00ff 3402 262e 39ff
+0021 0020 00ff 3416 2635 39fb
+0021 0020 00fd 3427 2638 39eb
+001f 001f 00ff 341c 2637 39e7
+0020 0020 00ff 3408 2640 39e0
+0020 0020 00ff 3434 2639 39d6
+0020 0020 00fe 3434 2634 39df
+0021 0020 0100 342a 2636 39e7
+0021 0020 00fe 342a 2634 39e5
+0021 001f 00ff 3432 263e 39f2
+0020 001f 00ff 343d 2642 39f8
+0020 0021 0100 342c 263e 39fd
+0021 0020 00ff 341e 2632 39ee
+0020 0022 00ff 343b 2638 39e7
+0020 001f 00fe 3437 2649 39e4
+0020 001f 00ff 342a 2647 39e7
+001f 0021 00ff 3420 2640 39d3
+0021 001f 00ff 3428 263f 39e2
+001f 0022 00fe 3432 2651 39e7
+0020 0021 00ff 3430 2650 39f9
+0020 0020 00ff 340c 2652 3a03
+0021 001f 00fe 3420 264b 39fe
+0021 001f 00ff 3420 2652 39f4
+0021 0020 0100 3423 265b 39eb
+0020 0020 00fe 3410 264c 39ee
+0020 001f 0101 3414 2653 39d7
+0021 0020 00ff 3419 2646 39ec
+0020 001f 00ff 3402 2650 39fc
+0021 001f 00ff 3417 264b 39ff
+0022 001f 00fe 3417 264b 3a05
+0021 001f 00fe 340c 2650 3a0c
+001f 0021 00fe 33f3 264f 3a06
+0021 001e 00ff 33fa 264a 39fc
+0020 0020 00ff 3404 264b 39f5
+0020 0020 0100 3402 2659 39fc
+0021 0020 0100 33f8 2651 39f2
+0021 0020 0100 33f1 264a 39f0
+001f 0020 0100 33f4 2650 39f1
+0020 0020 00ff 33fd 2659 3a01
+0021 0020 00fe 3403 2648 3a03
+0022 0021 0100 33f1 264f 3a0f
+0020 001e 00ff 33ea 2658 3a0c
+0020 001f 00fe 33e7 265a 3a19
+001f 0020 00fe 3402 2656 3a0d
+0021 0021 00ff 33f4 2654 3a08
+0021 0020 00ff 33df 2651 3a0a
+0020 0021 00fe 33e7 264a 3a03
+0020 001f 0100 33f3 2656 39fb
+0020 001e 00fe 33ee 2654 39fd
+0020 0020 00fd 33f1 2647 39f4
+0021 001f 00ff 33db 2650 39ff
+0020 0020 00ff 33ec 2653 3a01
+0021 001f 00ff 33e7 2652 3a08
+0021 001f 00fe 33e8 2653 3a08
+0021 001f 00ff 33d2 2655 3a14
+0020 0020 00ff 33d8 2654 3a19
+001f 0020 0100 33eb 264c 3a0e
+0021 0020 00ff 33d3 264d 3a02
+001f 0020 00ff 33e9 2654 3a02
+0021 0020 00ff 33df 2656 39ff
+0020 0021 00fe 33d6 264c 39fb
+0021 001f 0100 33ef 2651 39f5
+0020 001f 00ff 33e7 2634 39e8
+0021 0020 00fe 33e5 2648 39e8
+0021 001f 00ff 33e4 2646 39ec
+0020 0021 00ff 33f6 2644 39f2
+001f 001f 0100 33f3 263c 39f9
+0021 0020 00fe 33f7 2652 3a00
+0020 0022 00ff 33e5 2646 3a02
+0021 001e 00ff 33e9 2644 3a04
+0021 001f 0100 33e8 264d 3a02
+0021 0020 00fe 33e8 2648 3a03
+0021 0020 00fe 33fa 2632 3a04
+0021 001f 0100 33f6 263e 3a01
+0022 001f 00ff 3401 2649 39f1
+0021 001f 00fe 33ee 2645 39e7
+0021 0022 00ff 3402 2643 39ec
+0020 0020 0100 3413 263b 39dc
+0021 0020 00fe 3417 2642 39dd
+001f 001f 00ff 33f4 2636 39cd
+0021 001f 00fe 3404 2640 39c8
+0020 001f 00ff 3426 264d 39da
+001f 001f 00ff 3421 2644 39d8
+0021 0020 00ff 3412 264c 39d0
+0020 0020 00ff 341f 264a 39e0
+0022 001f 0100 342d 264a 39e0
+0021 001f 0100 3427 264a 39d9
+0020 001f 00fe 3427 2641 39dd
+0021 0020 00ff 343a 2639 39d6
+0020 0020 00ff 342b 263e 39e3
+0020 0020 00ff 3436 263a 39de
+001e 0021 00ff 3437 2646 39e6
+0021 0020 00ff 342e 263f 39eb
+001f 0020 00fd 342b 2645 39e8
+0020 0020 00ff 3427 2645 39dd
+0021 001f 00fe 3420 2647 39dd
+0020 0021 00ff 3416 2642 39d8
+0020 0020 00ff 3412 2643 39dd
+0021 001f 0100 3420 264a 39d9
+0020 0021 00fe 341f 263b 39e5
+0022 0021 00ff 3412 2645 39dc
+001f 0020 00fe 3425 263d 39ce
+0020 0021 0100 341c 2638 39cb
+0022 0022 00ff 3423 263a 39cc
+0020 0020 0100 3421 2635 39c9
+0020 0021 00fe 340c 262f 39c8
+0021 0020 00ff 3422 262d 39c8
+0020 0021 00ff 342f 2630 39c6
+0022 001f 00ff 3431 2637 39bd
+0020 0021 00ff 3426 262c 39bb
+0021 0021 00ff 3439 2633 39c9
+0021 0022 00fe 341e 263d 39d3
+0020 001f 00fe 341f 263f 39ce
+0020 001f 0100 3422 2637 39d4
+0021 0020 00ff 341a 263a 39e1
+0020 001f 00ff 3422 2633 39e4
+0021 001f 00fe 3412 262f 39e1
+0021 0022 00fe 33fd 2632 39e0
+0021 0021 00ff 341a 262f 39e7
+0021 0020 00ff 3423 2638 39e5
+0020 0020 00ff 3413 2635 39e2
+0020 001f 00ff 3420 262d 39f0
+0021 001f 00ff 3412 2637 39ec
+0021 001e 00ff 3410 262b 39e4
+0020 001f 00ff 3418 262f 39e5
+0020 001f 00fe 3416 262b 39e2
+0021 0020 00ff 3411 2622 39d3
+0023 001f 00fe 3408 262d 39d1
+0020 001f 0100 342b 2629 39d4
+0021 0020 0100 3419 262c 39c5
+0021 0020 00ff 3405 2627 39c8
+0020 0020 0100 340d 262b 39c5
+0020 001e 00ff 3422 262f 39d2
+0022 0020 00ff 341a 2633 39da
+0020 001f 00ff 340e 2642 39d4
+0021 001f 00ff 3415 2628 39da
+0021 001f 00fc 340d 2625 39e3
+0021 001f 0100 33fb 2629 39e6
+0021 001e 00ff 340c 2634 39f0
+0021 0021 00fe 3424 262b 39f8
+0021 0020 00fe 3413 262b 39e0
+0022 0020 00ff 33fe 262f 39d9
+0020 0021 00ff 341e 262b 39dc
+001f 001e 00ff 3421 2638 39db
+0020 001f 00ff 341b 262b 39df
+0022 0020 0100 340e 2632 39dd
+0020 0020 00fe 3418 263f 39d6
+0021 001e 00ff 341d 2625 39ce
+0020 001e 00ff 340e 2632 39d2
+0020 0020 00fe 3416 2631 39ce
+0020 001f 00fd 3406 2635 39c4
+0021 0020 0100 341a 2634 39c9
+0022 001f 00ff 3416 2631 39ce
+0021 0020 00ff 340c 262e 39e7
+0020 0021 00fe 3411 263c 39f0
+0021 0020 00ff 3414 2632 39ee
+0021 001f 00fe 3414 262d 39da
+0022 001f 00ff 3411 262c 39d6
+001f 0020 0100 3421 2632 39d6
+0021 001e 0100 3422 2630 39d0
+0020 0020 00ff 3425 2632 39ca
+0020 0020 0100 3420 2627 39c0
+0020 001e 00ff 342f 262a 39c1
+0020 0020 00ff 3436 262c 39c3
+0020 001f 00ff 343d 262a 39b4
+0021 0021 0100 341a 261c 39b6
+0020 001f 00fe 3427 2627 39b6
+0020 001f 00ff 3449 262d 39b6
+0021 001f 00fe 3421 262c 39be
+0020 0020 00ff 341b 263c 39c3
+0020 0020 00fe 3439 262b 39c0
+001f 001f 00ff 342f 262b 39c3
+001f 0020 00ff 3428 2628 39cc
+0021 0020 00ff 3416 2632 39cd
+0020 0021 0100 3426 263a 39ce
+0020 001f 0100 3433 2635 39ca
+0020 001f 0100 3425 262d 39e3
+0021 001f 0100 341c 2630 39e8
+0021 001e 00fd 3418 2634 39e6
+0021 001f 00fe 3434 262c 39e4
+001f 0020 00fe 341d 263b 39e6
+0020 0020 00ff 3427 2639 39e2
+0020 001e 0100 3418 2640 39db
+0020 0020 0100 3419 263e 39d4
+0020 0020 00ff 3427 263f 39de
+0021 001f 00ff 3427 2635 39db
+001f 001f 00ff 340a 263a 39dd
+0020 0020 00fe 3419 2633 39d2
+0022 0020 0100 3434 2637 39cc
+0021 001f 00fe 3422 2638 39cf
+0020 0021 00ff 3414 2634 39ce
+0020 001f 00ff 3410 262e 39ca
+0020 001f 00ff 3417 262f 39c1
+0021 0021 00ff 341d 2638 39c7
+0020 001f 0100 3411 262f 39c5
+0021 0020 00fe 340c 263c 39c6
+0020 001e 0100 3407 262b 39cb
+0021 001f 00ff 3415 263e 39cf
+0021 001f 0100 3412 2637 39db
+0020 0020 00ff 3409 262f 39d0
+0021 0021 0100 3416 2629 39db
+0021 0020 00ff 3408 263d 39da
+0020 0021 00ff 3413 2630 39dd
+0022 0020 0100 3408 262f 39e3
+0020 0020 0100 33f7 2630 39e1
+0021 001f 00ff 3405 2634 39ea
+0022 0021 00ff 340c 262c 39e9
+0021 0021 00fe 340e 262c 39e8
+0020 001e 00ff 33ee 2628 39e9
+0020 0020 00ff 3402 2632 39e7
+0021 001f 0100 33fa 2621 39fa
+0021 0020 00ff 33fd 2620 39f3
+0021 001e 00ff 3402 2624 39f9
+0020 0020 00ff 340c 2626 39db
+0021 0020 00ff 3404 2632 39d2
+0020 0021 00ff 33f2 2631 39c8
+0020 0021 0100 33ff 262d 39c7
+0021 0021 0100 3400 2625 39d5
+0021 0020 00ff 3401 262a 39d7
+0021 0020 00fe 33fe 2621 39d3
+0020 001f 00fe 3400 262b 39d8
+0021 001f 00ff 3406 2628 39df
+0021 001f 00fe 3414 2626 39e0
+0020 0021 00ff 341e 262a 39e2
+0021 001f 0100 3409 262e 39e0
+0020 0020 00ff 341e 2625 39e0
+001f 0020 00fe 341b 2628 39e9
+0021 0020 00ff 342b 262c 39e7
+0021 0020 0100 3422 262c 39e7
+0020 0020 00ff 341f 262b 39e8
+0020 001f 0100 341c 262d 39e0
+0020 001f 00ff 3414 262a 39d2
+0020 0021 00ff 3421 262e 39da
+0020 001f 0100 3436 2631 39d1
+0021 0020 0100 3425 2631 39c9
+0020 001f 00ff 3424 2628 39c9
+0020 0020 00ff 341f 262c 39c8
+001f 001f 00fe 342c 2628 39be
+0022 0021 00ff 3423 262c 39b2
+0021 0020 00ff 342b 2632 39c6
+0020 001f 00ff 3433 262d 39c5
+0020 0020 00ff 3447 2629 39c7
+0021 0020 00ff 3438 263c 39d2
+0020 0020 00fe 3428 2636 39d1
+0021 0021 00ff 343a 262b 39d1
+0021 0020 00fe 3443 2630 39dd
+0020 0020 00ff 3438 262c 39de
+0020 0021 00ff 3438 2624 39df
+001f 001f 00ff 3447 2638 39df
+001f 0020 00ff 3449 2633 39d3
+001f 0020 0100 3435 2626 39ca
+001f 001f 00fe 343f 2637 39ce
+001f 001f 0101 344c 263b 39cf
+0020 0020 00ff 3452 2634 39c4
+0020 0021 00fe 343b 2629 39c2
+0021 0021 0100 3449 2625 39be
+0020 0021 00ff 344e 2626 39ad
+0021 001f 00fe 3443 262b 39a8
+0021 001e 0100 344d 262e 39ac
+0020 001f 00fe 3436 2627 39ba
+0021 001f 00ff 3445 262a 39b6
+0020 0020 00ff 3430 262b 39bc
+0021 0020 00ff 3427 262e 39c2
+0020 0020 00ff 3443 2625 39c1
+0020 0022 00ff 342c 261d 39c2
+0021 0020 0100 3426 2622 39c0
+0021 001e 00ff 3429 262b 39c6
+0020 001e 00ff 3436 2626 39cb
+0020 0020 00fe 342e 2626 39cc
+0021 0020 00ff 342d 2635 39d0
+0020 001f 0101 342e 2624 39d5
+0021 0020 00ff 3433 263a 39d3
+0020 001f 00ff 342c 2626 39db
+0021 0020 00ff 3423 2632 39d2
+001f 0020 00fe 3433 2621 39c8
+0020 0021 00fe 3442 2640 39c4
+0020 001f 00ff 3439 2627 39c0
+0020 001f 00ff 3430 2625 39be
+0020 001f 00fe 3432 2627 39b2
+0020 0020 00ff 3448 262b 39ae
+001f 001f 00ff 342f 262e 39ab
+0020 0020 0100 3432 262d 39a7
+001f 0020 0100 3438 2631 39b5
+0020 0020 00ff 3442 2639 39c0
+0021 0021 00ff 342a 2638 39c6
+0020 0020 00ff 3422 262f 39c1
+0020 0020 0100 3427 262d 39bb
+0021 001f 00ff 343e 262c 39ca
+0021 0020 00ff 3425 2635 39d0
+0020 001f 00ff 341a 2629 39cd
+0020 0021 00ff 3419 262f 39dc
+0020 0020 00fe 3428 262d 39cc
+0021 001f 0100 3423 2631 39ca
+001f 0020 0100 342a 262d 39c9
+0020 001f 0100 342e 2629 39c6
+0021 0021 0101 3421 2636 39ba
+0020 0021 00fe 341a 2637 39bc
+0021 0020 00ff 341e 2638 39a8
+0021 0020 0101 342d 264a 39aa
+0021 001f 0100 341f 2640 39b1
+0021 001f 00ff 3423 2638 39bf
+001f 001f 00ff 3435 263f 39bc
+0021 0020 0100 3431 263b 39c3
+001f 0020 00ff 342e 2635 39cd
+001f 001f 00ff 3434 2638 39d0
+001f 0020 0100 3443 263f 39c5
+0020 001f 0100 341a 2638 39c8
+0020 0020 00fe 341e 263a 39bf
+0021 0020 00ff 3428 2639 39be
+0021 001f 00ff 3448 2635 39ba
+0020 0020 0100 3419 2640 39b7
+0022 0020 0100 341a 2640 39b4
+0021 0020 00ff 3423 263b 39c0
+001f 0020 00fe 342a 2636 39cb
+0021 0020 00ff 3420 263b 39ca
+0020 0020 00ff 3413 264a 39d2
+0020 0020 00ff 341c 2645 39da
+0020 0020 00ff 3423 263d 39da
+0020 0020 00ff 341e 263c 39ee
+0021 0020 00ff 3411 2639 39d9
+0020 001f 00ff 340e 2639 39da
+0020 001f 00fe 3413 2637 39d7
+0021 0021 00fe 3417 263a 39ca
+0021 0020 00fe 3402 2638 39c1
+0020 0021 00ff 340e 262c 39c0
+0021 001f 00ff 3404 2642 39d1
+0021 001f 00fe 33fe 264e 39d6
+0021 001e 00ff 33ff 2640 39d4
+001f 0021 00fe 33ff 2641 39e7
+001f 0021 00ff 33f7 263e 39e5
+001f 0021 0100 33fb 2632 39e7
+0021 0020 00fe 33f5 262d 39fa
+0020 0020 00ff 33fa 262e 39e8
+0021 001f 00ff 3407 2635 39e0
+0020 001f 00ff 33fb 2630 39d7
+0021 0020 00fe 33f7 2639 39ce
+001f 0021 00ff 33e6 263a 39e3
+0021 0020 0100 33e5 263b 39f3
+0020 001f 0100 33e4 2640 39fd
+0021 001f 0100 33df 263b 39f3
+0020 0020 00ff 3407 2644 39f4
+0021 001f 00fe 33f6 2645 39e4
+0020 001f 00ff 33f6 2656 39d6
+0021 0021 00ff 33ec 2656 39dd
+0020 0020 00ff 33f1 2659 39f1
+0021 001f 00ff 33dd 264d 39ff
+0022 001e 0100 33e5 2659 3a0c
+001f 0020 00ff 3408 2658 39ff
+0020 0021 00fe 33f2 2649 39f4
+0022 0022 00ff 33f1 264c 39d8
+0022 0020 00ff 340d 264b 39e6
+0021 0020 00ff 3401 264f 39f2
+0020 001e 00fd 33ef 2649 39f9
+0022 0021 00fe 33f2 2649 3a05
+0021 0020 00ff 33ef 2634 39fa
+0021 0020 00ff 33fc 262a 39f6
+0021 0020 00ff 3400 263f 39ea
+0020 001e 00ff 340a 263b 39d8
+0020 001f 00ff 3403 263c 39e5
+001f 0020 00ff 33fd 2644 39e7
+0021 0020 00fe 33f9 2639 39f5
+0022 0020 00ff 3408 2645 39ff
+0020 001f 0100 33fd 263d 39f1
+0020 0020 00ff 33fe 2642 39ec
+0022 001e 00ff 3410 2642 39e7
+0020 001f 00ff 3413 2646 39d8
+0020 0021 00ff 33fb 2642 39d2
+0020 001f 00ff 340b 2640 39da
+0020 001f 00ff 3417 264a 39e6
+0020 0021 00ff 3411 263f 39e2
+0022 0021 0100 3401 2640 39ec
+0021 0020 0100 341b 263e 39f0
+0021 001f 00fe 340c 2638 39f5
+0020 0020 00ff 340b 264a 3a03
+0020 001f 00fe 33ed 263c 39f6
+0021 0020 0100 340c 2648 39d5
+0021 0020 00ff 3413 2659 39e0
+0021 001f 00ff 340e 2654 39e6
+0020 0021 00ff 33f3 2658 39ea
+0021 001f 00ff 33fb 2651 39f4
+0021 0020 0100 33ff 2650 39f7
+0020 0020 0100 33ff 264f 39f0
+0020 001f 0100 3407 2650 39f4
+0021 001f 00ff 3409 263d 39eb
+0020 0020 00ff 33f6 264b 39e4
+0021 0020 00ff 340c 2644 39d9
+0020 0020 00fd 33fd 2650 39d4
+0021 001f 00fe 33fe 2648 39e1
+0021 001f 0100 3401 263a 39ea
+0021 0021 0101 340e 2646 39f0
+0020 001e 0100 3403 2641 39ec
+0021 001e 00ff 3403 2652 39eb
+0021 001e 00ff 3407 264b 39ff
+0020 0020 0100 3411 2643 3a00
+0021 0020 00ff 3414 2650 39ea
+0020 001f 0101 341a 2646 39e8
+0021 0021 00ff 3425 264a 39d8
+0021 0021 00fe 3402 263f 39ce
+0020 001f 00ff 340b 2631 39d4
+0020 0021 00ff 3413 2623 39e1
+001f 0021 00ff 3419 2626 39e5
+0020 001f 00ff 341f 2630 39f0
+0021 001e 00ff 341d 2635 39ed
+0020 0020 00ff 3422 262f 39d4
+0021 0021 00fe 341f 263d 39ce
+0020 001f 0100 342b 2625 39c8
+001e 001f 00ff 3429 2633 39c6
+0020 001f 00ff 3422 262a 39bf
+0020 0021 00ff 3420 2632 39cd
+0021 0020 00ff 342d 2638 39d5
+0021 0020 00fe 3412 263f 39d9
+0020 0021 00ff 3415 2641 39d7
+0022 0020 00ff 3421 264f 39e2
+001f 0020 00ff 341d 2643 39e3
+0022 0020 0100 340d 264b 39e9
+0020 0020 0100 341a 2658 39dc
+0020 001f 0100 3417 2647 39d9
+0021 0021 00ff 341f 2642 39d8
+0020 0020 00fe 340b 263d 39cd
+0021 001f 00ff 3424 264b 39cf
+0021 0021 00ff 342b 2647 39ba
+0020 0020 00fe 3403 264f 39c2
+0021 0021 00fe 3402 264a 39ce
+0020 001e 0100 3412 2652 39d0
+0021 0020 0100 3411 2646 39d1
+0021 0021 00ff 340a 264a 39dc
+0021 0020 00ff 33fe 2647 39e6
+001f 0020 0100 33f6 263b 39e6
+0020 0020 00ff 3407 2641 39ea
+0021 001f 0100 33fe 2645 39f1
+0020 0020 00fe 33ed 2647 39e2
+0021 0020 0100 33f7 2639 39dd
+0021 001f 00ff 3410 2636 39dc
+0021 0020 00ff 340b 2649 39d4
+0020 0020 00ff 33fa 2639 39d4
+0020 0020 00ff 33f3 263a 39c4
+0021 001f 00fe 33ff 263f 39cd
+0021 0021 00ff 33ff 263e 39d2
+0022 0020 00fe 3404 264a 39d6
+0021 001f 0100 3406 2640 39d1
+001f 0020 00ff 3417 2636 39d5
+0021 0021 0100 341a 2643 39d9
+0021 0020 00ff 340a 2645 39da
+0021 001f 00ff 340e 2631 39e6
+0020 0020 00ff 3414 262c 39e0
+001f 0020 00fe 3407 262b 39dc
+0020 001f 00ff 340b 261d 39d9
+0020 0020 00fe 341c 2611 39cc
+001f 0021 00ff 3413 262c 39c8
+001f 001f 00ff 340a 262d 39cb
+0020 001f 00fe 341f 2627 39bd
+0020 001f 0100 341e 262f 39be
+0020 001f 00ff 341a 262f 39c3
+0020 001f 00ff 3407 262b 39cb
+0020 0020 00ff 340f 263b 39d4
+0022 0020 00fe 342d 2631 39d8
+0020 0020 00fe 340e 2639 39dd
+0020 0021 00fe 3417 263b 39e9
+0020 001f 00ff 3412 2639 39d8
+0021 0020 0100 3420 263c 39d6
+0020 001f 0100 3418 262f 39d3
+0021 0020 00fe 3406 2630 39cd
+0020 0020 00fe 33fa 2630 39c5
+0021 001f 00ff 340a 262e 39c5
+0020 001f 00ff 341f 262b 39c7
+0021 001f 00ff 33fb 2636 39c2
+0020 0020 00ff 3406 262a 39bd
+0020 0020 0100 342a 2638 39b9
+001f 001f 00ff 3419 2638 39c4
+0021 001f 00ff 33fb 263c 39bd
+0021 0020 0100 3419 2633 39bb
+0021 001f 00ff 340d 2630 39b1
+0022 0020 00fe 3417 262c 39b9
+0020 0021 00ff 3424 2637 39b5
+0021 0021 00ff 3419 262b 39ba
+0021 001f 00ff 341c 2637 39b9
+0020 0020 00ff 3419 2636 39c6
+0020 0020 00ff 340f 262c 39bc
+001f 0020 0101 340c 2632 39c5
+0022 0020 00fe 340a 2642 39c1
+001f 0020 0100 340b 263c 39bf
+001f 0020 00ff 3407 2636 39c0
+0020 001f 00ff 3402 263a 39d2
+0022 001f 00ff 3407 264a 39cf
+0020 0021 0100 3402 263c 39d8
+0020 0021 00ff 33f9 2639 39db
+0021 0020 0100 3400 2632 39d5
+0020 0020 00ff 33f6 2635 39d9
+0021 0020 00ff 33ec 2632 39e2
+0021 0020 00fe 33ff 2638 39e6
+0021 0020 00fe 33fd 263a 39e7
+0020 001f 00fe 33e8 262c 39e9
+0020 0020 00fe 33f7 2625 39e9
+0021 0020 00fe 33f4 262c 39ea
+0021 0021 00fe 33fb 263b 39ec
+0021 0021 00ff 33f9 2645 39e9
+001f 001f 00ff 33e0 264d 39f6
+0021 0021 00ff 33f0 263f 39f2
+0022 001f 00fe 33eb 2648 39fc
+0020 001f 00ff 33f1 264f 39f6
+0021 0021 0100 33ed 2648 39f4
+0020 001f 0100 33ea 264e 39f6
+0022 001f 00ff 33ee 265b 39f9
+0020 0020 00ff 33de 264f 39f5
+0020 001f 00ff 33fc 2658 39f2
+0021 0020 00ff 33ef 2650 39f7
+0020 0020 00ff 33e4 265c 39fd
+0020 0020 00ff 33ec 2661 3a01
+0021 0021 00ff 33dc 2654 3a01
+0020 0020 0100 33eb 2662 39e3
+0021 0020 0100 33d9 2659 39e3
+0021 001f 0100 33d7 2654 39ee
+0020 001f 00ff 33e0 2649 39f5
+0021 0020 00ff 33de 264c 3a02
+0021 0021 00ff 33e0 2648 39f7
+0022 001f 00ff 33e8 2648 3a03
+0021 0021 00ff 33cc 2642 3a04
+0020 0022 0101 33dd 263c 3a06
+0020 0020 0100 33e0 2647 3a0e
+0021 001f 00ff 33d9 2648 3a16
+0020 001f 0100 33e2 2647 3a15
+0020 0020 00ff 33d7 264f 3a1d
+0020 0020 00fe 33cf 2646 3a19
+0021 0020 0100 33ec 2643 3a0c
+0020 0021 00ff 33d6 264f 3a0b
+001f 001f 00ff 33d0 264d 3a0e
+0020 0021 00ff 33cd 2648 39fd
+0021 0020 00ff 33db 2648 3a03
+0021 0020 00ff 33bd 2640 39f6
+0021 001f 0100 33d2 2647 39f5
+0020 0020 00ff 33d5 264d 39f9
+0020 001f 00ff 33c2 264e 3a05
+0021 0020 00fe 33dd 2647 3a0b
+0020 001d 00ff 33d2 2643 3a0a
+001f 001f 0100 33cd 264b 3a13
+0021 001f 0101 33cd 264c 3a15
+001f 0020 00ff 33ce 263c 3a1a
+0022 001f 00fe 33d0 2642 3a22
+0020 0020 0100 33c7 2648 3a1f
+0020 0021 0100 33d0 2646 3a19
+0021 0020 0100 33ca 2646 3a0e
+0021 001f 00fe 33c6 2643 3a06
+0023 0020 00fe 33be 264d 39f9
+0021 0020 00fe 33c1 264e 3a0b
+0020 001f 0101 33c2 2643 3a18
+0021 0021 0100 33da 2656 3a19
+001f 001f 00ff 33bc 2647 3a2b
+0021 0020 0100 33c0 2649 3a19
+0021 0022 00fe 33c3 264b 3a0e
+0021 0021 00ff 33cd 2644 3a0d
+0021 0021 00ff 33c4 264e 3a00
+0020 0020 0100 33d0 264b 39f4
+0022 0020 00fe 33ce 2642 39fb
+0020 0020 00fe 33d8 2651 3a02
+0020 001e 00ff 33d7 2654 3a06
+0021 0020 0101 33e0 265f 3a10
+0021 001f 00ff 33df 265f 3a13
+0020 0020 0100 33ef 2655 3a0a
+0022 0020 00ff 33d3 2656 3a07
+0022 0020 00ff 33db 265e 39fc
+0022 001e 00ff 33ec 264d 39f0
+0022 001f 00ff 33f0 265d 39eb
+0022 0020 00ff 33e5 2657 39e1
+0021 0021 0100 33e8 264c 39f3
+0021 0020 00fe 33f3 2652 39f4
+0020 0020 00fd 33f5 264d 39f7
+0022 0021 00ff 3403 2648 3a02
+0022 001f 00ff 33f3 2648 39ff
+0020 001f 00fe 33fc 2644 39f5
+0020 001e 00fe 33fe 2641 39d0
+0020 0020 00fe 33f8 264d 39df
+0020 0021 0100 33ee 264c 39df
+001d 0020 00ff 3400 2645 39dc
+0021 0020 00ff 33ef 263c 39ec
+0021 001f 00ff 33fb 2646 39ef
+001f 0021 00ff 33f5 2640 39f1
+0021 001f 00fd 33ea 263e 39e5
+0021 001f 0100 33e7 2637 39e9
+0020 0021 00ff 33fe 2631 39e3
+0021 001e 00fe 3403 2639 39df
+0021 0021 00ff 33e8 2639 39d6
+0020 001f 00ff 33fc 263a 39de
+0020 001f 00ff 33fd 263b 39d3
+0021 0022 00ff 33e4 2637 39cf
+0020 0020 00ff 33e1 2639 39dd
+0020 0020 00fd 33fa 2637 39df
+0020 0020 0100 33ec 263c 39e1
+0021 0020 00ff 33e8 2642 39e9
+0022 0021 00ff 33e5 2649 39ed
+0021 001f 0100 33ef 263f 39f1
+0020 0021 0100 33ee 263d 39f8
+0020 001e 00ff 33ea 2642 39f7
+0020 001f 00ff 33e6 2644 39f0
+0021 0020 00ff 33e4 264e 39ed
+001f 0020 0100 33e9 264b 39ee
+0021 0020 0100 33f6 263b 39dc
+0020 001f 00ff 33ff 2645 39df
+0020 001e 00ff 33ed 2642 39d2
+0022 0020 00ff 33f5 2649 39e0
+0023 0020 0100 33f0 2636 39e4
+0021 001f 00ff 33ea 263c 39ed
+0020 0020 00ff 33f4 2640 39ec
+0021 0020 00ff 33fa 2624 39f4
+0021 0020 00fd 33ff 2632 39f3
+001f 0022 00ff 33f1 2640 39e6
+0021 0020 0100 33f9 2635 39e7
+0021 0020 0100 3411 2636 39e0
+0021 001f 00fe 33f1 2631 39d7
+0020 001e 0100 33e6 263f 39cd
+0020 001e 00ff 33eb 2639 39e3
+0021 0020 0100 33e5 2647 39f9
+0021 0020 00ff 33fa 2643 3a01
+0022 001f 0100 33f9 263b 39f8
+0020 0021 0100 33ec 2639 39f5
+0020 0020 00ff 33e8 264a 39f6
+0021 001f 00ff 33f5 2644 39e9
+0020 0021 00ff 33fb 265a 39ec
+0021 0020 00fe 33dc 264a 39e4
+0020 0021 00fd 33d9 2656 39f1
+001f 001f 00ff 33e1 265f 39f3
+0020 0020 00ff 33d9 265f 3a0d
+0020 0020 00ff 33da 265b 3a1a
+0020 0020 0100 33ce 2655 3a16
+0022 0020 00ff 33c0 2668 3a0b
+001f 001f 0100 33b4 2657 3a05
+0022 0020 00ff 33ba 2654 3a02
+0021 001f 0100 33b8 265b 39ff
+0022 001f 00ff 33b0 2666 39fc
+0022 0020 00ff 3398 2663 3a15
+0021 0020 00fe 339e 265a 3a13
+0022 0020 00ff 339b 2662 3a2a
+0021 0020 00ff 339f 2664 3a27
+0020 0020 0100 3389 265b 3a24
+0020 001f 00fe 3396 2653 3a19
+0021 0020 00ff 3395 265d 3a0a
+0021 001f 00fe 338c 2655 3a14
+0021 001f 00ff 338b 2655 3a1a
+0020 0020 00ff 3394 265c 3a26
+0021 0022 00ff 3387 2658 3a2b
+0021 001f 00ff 33ab 2667 3a2a
+0021 0020 00ff 3394 265b 3a32
+0021 0020 00fd 3396 2652 3a31
+0021 0020 00ff 3394 2655 3a2d
+0022 001f 00fe 339e 2657 3a1b
+0021 0020 0101 339d 2659 3a23
+001f 0020 00ff 339e 2656 3a1a
+0021 001e 00ff 338e 2665 3a0f
+0022 001f 00ff 33a2 2663 3a11
+0020 0020 00ff 339d 2659 3a0a
+001e 0020 00fe 339a 2650 3a10
+0021 0020 00ff 33a3 2657 3a17
+0022 0020 0100 33a4 265b 3a1c
+0021 001f 00ff 339d 2656 3a28
+0022 0020 00ff 339e 2664 3a2c
+0021 0020 00fe 33aa 265a 3a24
+0021 0020 00ff 338f 265b 3a17
+0020 001e 00ff 33a0 265a 3a0f
+0020 0021 00fe 33a9 2658 3a0a
+001f 0020 00ff 33ac 2650 3a02
+001f 001f 00ff 33b6 264f 39fe
+0022 001e 00ff 33ab 2652 39f6
+0022 0022 0100 33b8 264f 39fd
+0021 0020 0100 33c5 2651 3a02
+0021 001f 00fe 33cb 2637 3a07
+0022 001f 00ff 33b8 2645 3a09
+0020 0021 00ff 33ca 264e 3a07
+0021 0021 00ff 33c2 264f 3a10
+0020 001f 00ff 33cd 2641 3a0b
+0022 0020 0100 33bb 263a 39fb
+0020 001f 00ff 33c8 262b 39f8
+0021 0020 00fe 33e3 262f 39e9
+0021 001e 0100 33d4 2638 39e0
+0021 0020 00ff 33ce 2637 39eb
+0020 0021 00ff 33de 2633 39ef
+0021 001f 00fe 33e0 2638 39f0
+0021 0021 0100 33cf 262b 39f7
+0021 0020 0100 33e3 2648 39f8
+0021 001f 00fe 33e8 2636 3a05
+0021 001f 00ff 33df 2636 39f5
+0021 0020 00ff 33e5 2637 39ec
+001f 0021 00ff 33e0 262d 39e3
+0021 0020 00ff 33ef 2641 39d7
+0020 0020 00fe 33ed 264a 39d6
+0020 0021 0100 33d9 2643 39c9
+0020 001f 00ff 33f6 264b 39d6
+0021 0021 00fe 33fc 264d 39e6
+0021 001e 00ff 33f9 2652 39d7
+0021 0021 00ff 33e2 2651 39e5
+0020 0020 00fe 33dc 265a 39e7
+001f 001f 0100 33fa 2647 39e9
+0021 0021 00ff 33f2 2645 39f9
+0020 0021 00ff 33ed 2649 39f7
+0021 0021 00fe 33e9 2650 39eb
+0020 0021 00fe 33ff 264d 39de
+0020 0020 00ff 33e3 264b 39d6
+0021 0021 00ff 33de 2641 39d0
+0020 001f 00ff 33da 2640 39ce
+0021 0020 00ff 33e2 264a 39dd
+0020 0022 00ff 33e0 2646 39e4
+0021 001f 00fe 33d6 2650 39e9
+0021 0020 0100 33de 263c 39f1
+0021 0020 00ff 33d3 264f 39ee
+0020 0021 0100 33ca 264d 39f3
+0020 0021 00ff 33d4 2643 3a01
+001f 001f 00ff 33ce 2643 3a01
+0020 0020 00ff 33cd 2647 3a08
+0021 0020 00ff 33c6 2649 39f6
+0021 0020 00fe 33c9 263e 39ec
+0020 0020 00fe 33c9 262b 39e4
+0021 001f 00ff 33e4 2638 39de
+0020 001f 00ff 33d7 262c 39ee
+0021 0020 00ff 33c8 2633 39f4
+0020 001f 00ff 33c5 263b 39f8
+0021 001f 00ff 33d2 264a 3a04
+0021 0021 00fe 33d9 263c 3a10
+0021 001f 0100 33c9 2639 39fc
+0021 001f 00ff 33c0 263e 3a00
+0020 0020 00ff 33b8 263e 3a06
+0021 0020 0101 33c2 2643 39fd
+001f 0021 0100 33b1 2642 39f5
+0021 0020 00fe 33a4 263d 3a00
+0021 0020 00fe 33cb 263e 39fb
+0021 0020 00fe 33a7 2646 39fc
+0020 0022 00fe 339f 2641 39fe
+0021 0020 00ff 3398 2644 39f2
+0021 001f 00ff 33a7 2638 39f4
+0022 001f 0100 339e 264c 3a01
+0023 001f 00ff 3392 263d 3a0a
+0021 0020 00ff 3393 2648 3a24
+0021 0021 0101 338c 2644 3a26
+0020 001f 00ff 3398 264f 3a24
+0021 0020 00ff 3392 2645 3a1f
+0022 0020 00fe 338c 264d 3a1b
+0020 0020 00fe 3375 2644 3a1e
+0020 0020 00fe 3385 2657 3a1d
+0021 0020 0100 3388 263f 3a21
+0020 0020 0100 337a 2649 3a1b
+0021 0020 00fd 3370 2644 3a15
+0020 0020 00ff 335e 2646 3a0d
+0022 0021 00ff 335f 264c 3a0e
+0021 0020 00ff 3378 2646 3a0a
+0021 0021 00ff 3373 264c 3a12
+0022 0021 0100 336f 2647 3a19
+0022 0020 00ff 3372 264f 3a1f
+0021 0020 00ff 337c 2646 3a15
+0020 0021 0100 3368 264a 3a1f
+0022 0020 00fe 336b 263f 3a2a
+0021 0020 00ff 3379 264a 3a26
+0021 0020 00fe 337d 2638 3a33
+0022 0020 0100 337d 264c 3a2f
+0021 0020 00fe 336e 263c 3a28
+0020 0020 00fd 3373 2637 3a1f
+0022 001f 0100 3375 2642 3a24
+0021 001d 00ff 3381 2646 3a17
+0023 001f 00ff 337b 2645 3a15
+0022 0020 0100 337c 263a 3a06
+0021 001f 00ff 336c 2647 3a0f
+0021 0020 00ff 3384 2655 3a1a
+0021 001f 00fe 3385 264b 3a20
+0020 0021 00ff 3379 264c 3a25
+0020 001e 0100 3365 264e 3a31
+0022 001e 00ff 336d 2648 3a2f
+0021 001d 00fe 3385 2645 3a26
+0021 001f 0100 3372 2642 3a22
+0020 001f 0100 3357 2650 3a18
+0021 0020 00ff 337a 2651 3a11
+0021 0021 00fe 3382 2652 3a0f
+0022 001f 00ff 336c 2651 3a0e
+0021 0021 00fe 337f 265b 3a04
+0022 0020 0100 337c 265b 3a0d
+0020 0021 0100 3373 2654 3a18
+0020 001e 00ff 337b 2651 3a1f
+0021 001f 00ff 3386 2650 3a1e
+0021 0021 0100 3390 2650 3a2f
+0020 0020 00fe 3399 264c 3a18
+0021 001f 0100 3389 264e 3a0c
+0022 0020 00ff 337f 2651 3a05
+0020 0020 00ff 338f 264b 3a04
+0021 0020 0100 338f 264c 39f6
+001f 0020 00fd 3393 264a 3a00
+001f 0020 00fe 3398 264e 3a0a
+0021 0021 00ff 339b 2646 3a10
+0021 0020 00ff 33a4 2636 3a1a
+0021 001f 00ff 339d 2648 3a1f
+0022 0021 0100 339d 2628 3a14
+0020 0020 00ff 3393 263c 3a11
+0020 001f 00fd 338d 2638 3a0d
+0020 0020 00fe 33a9 2638 39fb
+0022 0020 00ff 33a4 2638 39f9
+0021 001f 00fe 33a0 2639 39f3
+0021 0020 0100 33ac 2640 39f8
+0022 0020 00ff 33a9 2639 39f3
+0021 0020 0100 33b1 2641 3a02
+0020 001f 00fd 33ba 2640 3a0e
+0021 0020 0101 33a6 2640 3a0f
+0021 001f 00ff 33bf 2646 3a09
+0020 0020 00fd 33bb 2643 3a00
+0021 0020 00ff 33b9 2641 39f9
+0020 001e 00fe 33bc 2643 39ed
+0021 001f 00ff 33c1 2648 39f1
+0022 0020 0100 33b4 2655 39e3
+0021 0020 00fe 33a4 2655 39f1
+0020 0021 0100 33ae 264f 39f3
+001f 0021 0100 33c9 2658 39f1
+0021 001f 00ff 33b7 264a 39f9
+0021 0020 00fe 33a5 264c 39fe
+0021 0020 00fe 33c2 2654 39ff
+0020 001f 0100 33c7 2650 3a0a
+0021 0020 00ff 33b7 2647 39fe
+0020 0020 00fe 33be 263f 39f7
+0020 0021 00ff 33b8 263d 39fc
+0020 0020 0100 33c5 263f 39f2
+0020 0020 00fe 33bf 2649 39e9
+0020 0021 00ff 33a8 263f 39df
+0021 0020 0100 33bf 2643 39f0
+0020 0021 0100 33c9 2638 39f9
+001f 001e 0100 33c7 2626 39fc
+0020 0020 00ff 33bc 2634 39fe
+0021 0020 00ff 33b1 2630 3a0b
+0020 0020 00fd 33ac 2633 39f8
+0022 0021 00fe 33be 263a 39fd
+0020 0020 00ff 33ae 263a 39ff
+0020 001f 00ff 33b2 263f 39fa
+0021 0020 00ff 33c1 2632 39dd
+001f 0020 00ff 33b2 263a 39f2
+0021 001f 0100 33a4 263d 39ec
+0020 0020 00ff 33a5 2641 39fb
+0020 001e 00ff 33b6 263f 3a02
+0020 0021 00fe 33b8 2644 3a06
+0021 0020 0100 33ab 263b 3a0b
+0021 0021 00ff 33af 263c 39fe
+0021 001f 00ff 33ba 263c 39e9
+0022 0020 00fe 33ad 2640 39f2
+0020 0020 0100 3398 2647 39fc
+0020 0020 00fe 33aa 264f 3a0d
+0022 0021 00fe 33a6 2663 3a09
+001f 001f 00fe 339c 2655 3a21
+0021 0021 0100 3391 2651 3a0b
+0021 0021 00ff 339b 2657 3a11
+0022 0020 00ff 3396 2659 3a00
+0021 001f 00ff 338f 2655 39f3
+0020 001f 00ff 3384 264f 39f0
+0021 001f 0100 337d 2655 3a0d
+0021 0020 00fe 3390 264e 3a0b
+0021 0020 00fe 3385 2656 3a17
+0020 0020 00ff 336f 2658 3a23
+0020 0020 00fe 337d 2649 3a0d
+0020 0021 00ff 3389 264a 3a0a
+0021 0020 00fe 3381 264e 39f5
+0022 0020 00ff 3392 2649 39ff
+0021 001e 00ff 3385 2648 3a0a
+0020 001f 00ff 338f 2637 3a12
+0020 001f 00ff 33a1 2641 3a0e
+0021 0021 00ff 33a2 262f 3a14
+0021 0021 0100 3398 2633 3a0e
+0020 0020 00ff 33a1 2628 3a05
+0021 001f 00ff 33a6 2631 3a06
+0022 0021 00fe 339b 2629 3a00
+0020 0020 00ff 33a0 2627 39fc
+001f 001f 00fe 3394 262e 39ee
 0020 0020 00ff 339c 262e 39f5
\ No newline at end of file
diff --git a/_old_Pedonovation/gradle.properties b/_old_Pedonovation/gradle.properties
index 28718c2..ccb0792 100644
--- a/_old_Pedonovation/gradle.properties
+++ b/_old_Pedonovation/gradle.properties
@@ -1,24 +1,24 @@
-# Project-wide Gradle settings.
-# IDE (e.g. Android Studio) users:
-# Gradle settings configured through the IDE *will override*
-# any settings specified in this file.
-# For more details on how to configure your build environment visit
-# http://www.gradle.org/docs/current/userguide/build_environment.html
-# Specifies the JVM arguments used for the daemon process.
-# The setting is particularly useful for tweaking memory settings.
-org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
-# When configured, Gradle will run in incubating parallel mode.
-# This option should only be used with decoupled projects. For more details, visit
-# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
-# org.gradle.parallel=true
-# AndroidX package structure to make it clearer which packages are bundled with the
-# Android operating system, and which are packaged with your app's APK
-# https://developer.android.com/topic/libraries/support-library/androidx-rn
-android.useAndroidX=true
-# Enables namespacing of each library's R class so that its R class includes only the
-# resources declared in the library itself and none from the library's dependencies,
-# thereby reducing the size of the R class for that library
-android.nonTransitiveRClass=true
-android.enableJetifier=true
-# Improving performance on build
+# Project-wide Gradle settings.
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. For more details, visit
+# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
+# org.gradle.parallel=true
+# AndroidX package structure to make it clearer which packages are bundled with the
+# Android operating system, and which are packaged with your app's APK
+# https://developer.android.com/topic/libraries/support-library/androidx-rn
+android.useAndroidX=true
+# Enables namespacing of each library's R class so that its R class includes only the
+# resources declared in the library itself and none from the library's dependencies,
+# thereby reducing the size of the R class for that library
+android.nonTransitiveRClass=true
+android.enableJetifier=true
+# Improving performance on build
 org.gradle.configuration-cache=true
\ No newline at end of file
diff --git a/_old_Pedonovation/gradle/libs.versions.toml b/_old_Pedonovation/gradle/libs.versions.toml
index 730fc3d..7fa219f 100644
--- a/_old_Pedonovation/gradle/libs.versions.toml
+++ b/_old_Pedonovation/gradle/libs.versions.toml
@@ -1,30 +1,30 @@
-[versions]
-agp = "8.4.0"
-junit = "4.13.2"
-junitVersion = "1.1.5"
-espressoCore = "3.5.1"
-appcompat = "1.6.1"
-material = "1.12.0"
-constraintlayout = "2.1.4"
-graphview = "4.2.2"
-activity = "1.9.0"
-annotation = "1.6.0"
-lifecycleLivedataKtx = "2.8.6"
-lifecycleViewmodelKtx = "2.8.6"
-
-[libraries]
-junit = { group = "junit", name = "junit", version.ref = "junit" }
-ext-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
-appcompat = { group = "androidx.appcompat", name = "appcompat", version = "1.7.0" }
-material = { group = "com.google.android.material", name = "material", version.ref = "material" }
-constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
-graphview = { group = "com.jjoe64", name = "graphview", version.ref = "graphview" }
-activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
-annotation = { group = "androidx.annotation", name = "annotation", version.ref = "annotation" }
-lifecycle-livedata-ktx = { group = "androidx.lifecycle", name = "lifecycle-livedata-ktx", version.ref = "lifecycleLivedataKtx" }
-lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleViewmodelKtx" }
-
-[plugins]
-android-application = { id = "com.android.application", version.ref = "agp" }
-
+[versions]
+agp = "8.4.0"
+junit = "4.13.2"
+junitVersion = "1.1.5"
+espressoCore = "3.5.1"
+appcompat = "1.6.1"
+material = "1.12.0"
+constraintlayout = "2.1.4"
+graphview = "4.2.2"
+activity = "1.9.0"
+annotation = "1.6.0"
+lifecycleLivedataKtx = "2.8.6"
+lifecycleViewmodelKtx = "2.8.6"
+
+[libraries]
+junit = { group = "junit", name = "junit", version.ref = "junit" }
+ext-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
+espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
+appcompat = { group = "androidx.appcompat", name = "appcompat", version = "1.7.0" }
+material = { group = "com.google.android.material", name = "material", version.ref = "material" }
+constraintlayout = { group = "androidx.constraintlayout", name = "constraintlayout", version.ref = "constraintlayout" }
+graphview = { group = "com.jjoe64", name = "graphview", version.ref = "graphview" }
+activity = { group = "androidx.activity", name = "activity", version.ref = "activity" }
+annotation = { group = "androidx.annotation", name = "annotation", version.ref = "annotation" }
+lifecycle-livedata-ktx = { group = "androidx.lifecycle", name = "lifecycle-livedata-ktx", version.ref = "lifecycleLivedataKtx" }
+lifecycle-viewmodel-ktx = { group = "androidx.lifecycle", name = "lifecycle-viewmodel-ktx", version.ref = "lifecycleViewmodelKtx" }
+
+[plugins]
+android-application = { id = "com.android.application", version.ref = "agp" }
+
diff --git a/_old_Pedonovation/gradle/wrapper/gradle-wrapper.properties b/_old_Pedonovation/gradle/wrapper/gradle-wrapper.properties
index f72ae45..0e0b173 100644
--- a/_old_Pedonovation/gradle/wrapper/gradle-wrapper.properties
+++ b/_old_Pedonovation/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sun May 12 12:40:10 EEST 2024
-distributionBase=GRADLE_USER_HOME
-distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
-zipStoreBase=GRADLE_USER_HOME
-zipStorePath=wrapper/dists
+#Sun May 12 12:40:10 EEST 2024
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/_old_Pedonovation/gradlew b/_old_Pedonovation/gradlew
index 4f906e0..02640cb 100644
--- a/_old_Pedonovation/gradlew
+++ b/_old_Pedonovation/gradlew
@@ -1,185 +1,185 @@
-#!/usr/bin/env sh
-
-#
-# Copyright 2015 the original author or authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      https://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-##############################################################################
-##
-##  Gradle start up script for UN*X
-##
-##############################################################################
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
-APP_NAME="Gradle"
-APP_BASE_NAME=`basename "$0"`
-
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
-
-# Use the maximum available, or set MAX_FD != -1 to use that value.
-MAX_FD="maximum"
-
-warn () {
-    echo "$*"
-}
-
-die () {
-    echo
-    echo "$*"
-    echo
-    exit 1
-}
-
-# OS specific support (must be 'true' or 'false').
-cygwin=false
-msys=false
-darwin=false
-nonstop=false
-case "`uname`" in
-  CYGWIN* )
-    cygwin=true
-    ;;
-  Darwin* )
-    darwin=true
-    ;;
-  MINGW* )
-    msys=true
-    ;;
-  NONSTOP* )
-    nonstop=true
-    ;;
-esac
-
-CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
-
-
-# Determine the Java command to use to start the JVM.
-if [ -n "$JAVA_HOME" ] ; then
-    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
-        # IBM's JDK on AIX uses strange locations for the executables
-        JAVACMD="$JAVA_HOME/jre/sh/java"
-    else
-        JAVACMD="$JAVA_HOME/bin/java"
-    fi
-    if [ ! -x "$JAVACMD" ] ; then
-        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-    fi
-else
-    JAVACMD="java"
-    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-
-Please set the JAVA_HOME variable in your environment to match the
-location of your Java installation."
-fi
-
-# Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
-    MAX_FD_LIMIT=`ulimit -H -n`
-    if [ $? -eq 0 ] ; then
-        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
-            MAX_FD="$MAX_FD_LIMIT"
-        fi
-        ulimit -n $MAX_FD
-        if [ $? -ne 0 ] ; then
-            warn "Could not set maximum file descriptor limit: $MAX_FD"
-        fi
-    else
-        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
-    fi
-fi
-
-# For Darwin, add options to specify how the application appears in the dock
-if $darwin; then
-    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
-fi
-
-# For Cygwin or MSYS, switch paths to Windows format before running java
-if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
-    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
-    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
-
-    JAVACMD=`cygpath --unix "$JAVACMD"`
-
-    # We build the pattern for arguments to be converted via cygpath
-    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
-    SEP=""
-    for dir in $ROOTDIRSRAW ; do
-        ROOTDIRS="$ROOTDIRS$SEP$dir"
-        SEP="|"
-    done
-    OURCYGPATTERN="(^($ROOTDIRS))"
-    # Add a user-defined pattern to the cygpath arguments
-    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
-        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
-    fi
-    # Now convert the arguments - kludge to limit ourselves to /bin/sh
-    i=0
-    for arg in "$@" ; do
-        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
-        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
-
-        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
-            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
-        else
-            eval `echo args$i`="\"$arg\""
-        fi
-        i=`expr $i + 1`
-    done
-    case $i in
-        0) set -- ;;
-        1) set -- "$args0" ;;
-        2) set -- "$args0" "$args1" ;;
-        3) set -- "$args0" "$args1" "$args2" ;;
-        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
-        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
-        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
-        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
-        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
-        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
-    esac
-fi
-
-# Escape application args
-save () {
-    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
-    echo " "
-}
-APP_ARGS=`save "$@"`
-
-# Collect all arguments for the java command, following the shell quoting and substitution rules
-eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
-
-exec "$JAVACMD" "$@"
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      https://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin or MSYS, switch paths to Windows format before running java
+if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=`expr $i + 1`
+    done
+    case $i in
+        0) set -- ;;
+        1) set -- "$args0" ;;
+        2) set -- "$args0" "$args1" ;;
+        3) set -- "$args0" "$args1" "$args2" ;;
+        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=`save "$@"`
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+exec "$JAVACMD" "$@"
diff --git a/_old_Pedonovation/gradlew.bat b/_old_Pedonovation/gradlew.bat
index 107acd3..ac1b06f 100644
--- a/_old_Pedonovation/gradlew.bat
+++ b/_old_Pedonovation/gradlew.bat
@@ -1,89 +1,89 @@
-@rem
-@rem Copyright 2015 the original author or authors.
-@rem
-@rem Licensed under the Apache License, Version 2.0 (the "License");
-@rem you may not use this file except in compliance with the License.
-@rem You may obtain a copy of the License at
-@rem
-@rem      https://www.apache.org/licenses/LICENSE-2.0
-@rem
-@rem Unless required by applicable law or agreed to in writing, software
-@rem distributed under the License is distributed on an "AS IS" BASIS,
-@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@rem See the License for the specific language governing permissions and
-@rem limitations under the License.
-@rem
-
-@if "%DEBUG%" == "" @echo off
-@rem ##########################################################################
-@rem
-@rem  Gradle startup script for Windows
-@rem
-@rem ##########################################################################
-
-@rem Set local scope for the variables with windows NT shell
-if "%OS%"=="Windows_NT" setlocal
-
-set DIRNAME=%~dp0
-if "%DIRNAME%" == "" set DIRNAME=.
-set APP_BASE_NAME=%~n0
-set APP_HOME=%DIRNAME%
-
-@rem Resolve any "." and ".." in APP_HOME to make it shorter.
-for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
-
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
-
-@rem Find java.exe
-if defined JAVA_HOME goto findJavaFromJavaHome
-
-set JAVA_EXE=java.exe
-%JAVA_EXE% -version >NUL 2>&1
-if "%ERRORLEVEL%" == "0" goto execute
-
-echo.
-echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:findJavaFromJavaHome
-set JAVA_HOME=%JAVA_HOME:"=%
-set JAVA_EXE=%JAVA_HOME%/bin/java.exe
-
-if exist "%JAVA_EXE%" goto execute
-
-echo.
-echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
-echo.
-echo Please set the JAVA_HOME variable in your environment to match the
-echo location of your Java installation.
-
-goto fail
-
-:execute
-@rem Setup the command line
-
-set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
-
-
-@rem Execute Gradle
-"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
-
-:end
-@rem End local scope for the variables with windows NT shell
-if "%ERRORLEVEL%"=="0" goto mainEnd
-
-:fail
-rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
-rem the _cmd.exe /c_ return code!
-if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
-exit /b 1
-
-:mainEnd
-if "%OS%"=="Windows_NT" endlocal
-
-:omega
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      https://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Resolve any "." and ".." in APP_HOME to make it shorter.
+for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto execute
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/_old_Pedonovation/settings.gradle.kts b/_old_Pedonovation/settings.gradle.kts
index 0b46234..85b848c 100644
--- a/_old_Pedonovation/settings.gradle.kts
+++ b/_old_Pedonovation/settings.gradle.kts
@@ -1,24 +1,24 @@
-pluginManagement {
-    repositories {
-        google {
-            content {
-                includeGroupByRegex("com\\.android.*")
-                includeGroupByRegex("com\\.google.*")
-                includeGroupByRegex("androidx.*")
-            }
-        }
-        mavenCentral()
-        gradlePluginPortal()
-    }
-}
-dependencyResolutionManagement {
-    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
-    repositories {
-        google()
-        mavenCentral()
-    }
-}
-
-rootProject.name = "Pedonovation"
-include(":app")
+pluginManagement {
+    repositories {
+        google {
+            content {
+                includeGroupByRegex("com\\.android.*")
+                includeGroupByRegex("com\\.google.*")
+                includeGroupByRegex("androidx.*")
+            }
+        }
+        mavenCentral()
+        gradlePluginPortal()
+    }
+}
+dependencyResolutionManagement {
+    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
+    repositories {
+        google()
+        mavenCentral()
+    }
+}
+
+rootProject.name = "Pedonovation"
+include(":app")
  
\ No newline at end of file
